<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="##一、简介由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete。程序员忘记 delete，流程太复杂，最终导致没有 delete，异常导致程序过早退出，没有执行 delete 的情况并不罕见。用智能指针便可以有效缓解这类问题，本文主要讲解参见的智能指针的用法。包括：std::auto_ptr、boost::scoped_ptr、boost::shared_">
<meta property="og:type" content="article">
<meta property="og:title" content="C++智能指针详解">
<meta property="og:url" content="http://www.njiang.cn/2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/index.html">
<meta property="og:site_name" content="天空の城">
<meta property="og:description" content="##一、简介由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete。程序员忘记 delete，流程太复杂，最终导致没有 delete，异常导致程序过早退出，没有执行 delete 的情况并不罕见。用智能指针便可以有效缓解这类问题，本文主要讲解参见的智能指针的用法。包括：std::auto_ptr、boost::scoped_ptr、boost::shared_">
<meta property="og:updated_time" content="2016-12-26T08:40:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++智能指针详解">
<meta name="twitter:description" content="##一、简介由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete。程序员忘记 delete，流程太复杂，最终导致没有 delete，异常导致程序过早退出，没有执行 delete 的情况并不罕见。用智能指针便可以有效缓解这类问题，本文主要讲解参见的智能指针的用法。包括：std::auto_ptr、boost::scoped_ptr、boost::shared_">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.njiang.cn/2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/"/>





  <title> C++智能指针详解 | 天空の城 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-43682645-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">天空の城</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">愤怒的程序员，梦想着有一天也能飞！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++智能指针详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-02T11:38:11+08:00">
              2014-09-02
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>##一、简介<br>由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete。程序员忘记 delete，流程太复杂，最终导致没有 delete，异常导致程序过早退出，没有执行 delete 的情况并不罕见。<br>用智能指针便可以有效缓解这类问题，本文主要讲解参见的智能指针的用法。包括：<code>std::auto_ptr</code>、<code>boost::scoped_ptr</code>、<code>boost::shared_ptr</code>、<code>boost::scoped_array</code>、<code>boost::shared_array</code>、<code>boost::weak_ptr</code>、<code>boost:: intrusive_ptr</code>。你可能会想，如此多的智能指针就为了解决new、delete匹配问题，真的有必要吗？看完这篇文章后，我想你心里自然会有答案。下面就按照顺序讲解如上 7 种智能指针（smart_ptr）。</p>
<p>##二、具体使用</p>
<p>###1、总括<br>对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。<br>访问智能指针包含的裸指针则可以用 get() 函数。由于智能指针是一个对象，所以<code>if (my_smart_object)</code>永远为真，要判断智能指针的裸指针是否为空，需要这样判断：<code>if (my_smart_object.get())</code>。<br>智能指针包含了 <code>reset()</code> 方法，如果不传递参数（或者传递 NULL），则智能指针会释放当前管理的内存。如果传递一个对象，则智能指针会释放当前对象，来管理新传入的对象。<br>我们编写一个测试类来辅助分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Simple &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Simple(<span class="keyword">int</span> param = <span class="number">0</span>) &#123;</div><div class="line">    number = param;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  ~Simple() &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PrintSomething: "</span> &lt;&lt; info_extend.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> info_extend;</div><div class="line">  <span class="keyword">int</span> number;</div><div class="line">&#125;;</div><div class="line">``` </div><div class="line"></div><div class="line">###<span class="number">2</span>、<span class="built_in">std</span>::<span class="built_in">auto_ptr</span></div><div class="line">`<span class="built_in">std</span>::<span class="built_in">auto_ptr</span>` 属于 STL，当然在 <span class="keyword">namespace</span> <span class="built_in">std</span> 中，包含头文件 <span class="string">"#include&lt;memory&gt;"</span>便可以使用。<span class="built_in">std</span>::<span class="built_in">auto_ptr</span> 能够方便的管理单个堆内存对象。</div><div class="line">我们从代码开始分析：</div><div class="line"></div><div class="line">```<span class="function">cpp</span></div><div class="line"><span class="keyword">void</span> <span class="title">TestAutoPtr</span><span class="params">()</span> </div><div class="line">&#123;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));   <span class="comment">// 创建对象，输出：Simple：1</span></div><div class="line"><span class="keyword">if</span> (my_memory.get()) &#123;                            <span class="comment">// 判断智能指针是否为空</span></div><div class="line">my_memory-&gt;PrintSomething();                    <span class="comment">// 使用 operator-&gt; 调用智能指针对象中的函数</span></div><div class="line">my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>;      <span class="comment">// 使用 get() 返回裸指针，然后给内部对象赋值</span></div><div class="line">my_memory-&gt;PrintSomething();                    <span class="comment">// 再次打印，表明上述赋值成功</span></div><div class="line"></div><div class="line">(*my_memory).info_extend += <span class="string">" other"</span>;			<span class="comment">// 使用 operator* 返回智能指针内部对象，然后用"."调用智能指针对象中的函数</span></div><div class="line"></div><div class="line">my_memory-&gt;PrintSomething();                    <span class="comment">// 再次打印，表明上述赋值成功</span></div><div class="line">&#125;</div><div class="line">&#125;                                              <span class="comment">// my_memory 栈对象即将结束生命期，析构堆对象 Simple(1)</span></div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">1</span></div><div class="line">PrintSomething:</div><div class="line">PrintSomething: Addition</div><div class="line">PrintSomething: Addition other</div><div class="line"></div><div class="line">~Simple: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>上述为正常使用 <code>std::auto_ptr</code>的代码，一切似乎都良好，无论如何不用我们显示使用该死的 delete 了。</p>
<p>其实好景不长，我们看看如下的另一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr2</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory2;   <span class="comment">// 创建一个新的 my_memory2 对象</span></div><div class="line">    my_memory2 = my_memory;             <span class="comment">// 复制旧的 my_memory 给 my_memory2</span></div><div class="line">    my_memory2-&gt;PrintSomething();       <span class="comment">// 输出信息，复制成功 </span></div><div class="line">  	my_memory-&gt;PrintSomething();        <span class="comment">// 崩溃</span></div><div class="line">  	</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终如上代码导致崩溃，如上代码时绝对符合 C++ 编程思想的，居然崩溃了，跟进 std::auto_ptr 的源码后，我们看到，罪魁祸首是<code>my_memory2 = my_memory</code>，这行代码，my_memory2 完全夺取了 my_memory 的内存管理所有权，导致 my_memory 悬空，最后使用时导致崩溃。<br>所以，使用 <code>std::auto_ptr</code> 时，绝对不能使用“operator=”操作符。作为一个库，不允许用户使用，确没有明确拒绝[1]，多少会觉得有点出乎预料。</p>
<p>看完 <code>std::auto_ptr</code> 好景不长的第一个例子后，让我们再来看一个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line"> </div><div class="line"> <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory.release();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>看到什么异常了吗？我们创建出来的对象没有被析构，没有输出“~Simple: 1”，导致内存泄露。当我们不想让 my_memory 继续生存下去，我们调用 release() 函数释放内存，结果却导致内存泄露（在内存受限系统中，如果my_memory占用太多内存，我们会考虑在使用完成后，立刻归还，而不是等到 my_memory 结束生命期后才归还）。正确的代码应该为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    Simple* temp_memory = my_memory.release();</div><div class="line">    <span class="keyword">delete</span> temp_memory;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory.reset();  <span class="comment">// 释放 my_memory 内部管理的内存</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来<code>std::auto_ptr</code>的 release() 函数只是让出内存所有权，这显然也不符合 C++ 编程思想。<br>总结：<code>std::auto_ptr</code>可用来管理单个对象的对内存，但是，请注意如下几点：<br>（1）    尽量不要使用“operator=”。如果使用了，请不要再使用先前对象。<br>（2）    记住 release() 函数不会释放对象，仅仅归还所有权。<br>（3）    std::auto_ptr 最好不要当成参数传递（读者可以自行写代码确定为什么不能）。<br>（4）    由于<code>std::auto_ptr</code>的“operator=”问题，有其管理的对象不能放入<code>std::vector</code>等容器中。<br>（5）    ……<br>使用一个<code>std::auto_ptr</code>的限制还真多，还不能用来管理堆内存数组，这应该是你目前在想的事情吧，我也觉得限制挺多的，哪天一个不小心，就导致问题了。<br>由于<code>std::auto_ptr</code>引发了诸多问题，一些设计并不是非常符合 C++ 编程思想，所以引发了下面 boost 的智能指针，boost 智能指针可以解决如上问题。<br>让我们继续向下看。</p>
<p>###3、boost::scoped_ptr<br><code>boost::scoped_ptr</code>属于 boost 库，定义在<code>namespace boost</code>中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt;</code>便可以使用。<code>boost::scoped_ptr</code>跟<code>std::auto_ptr</code>一样，可以方便的管理单个堆内存对象，特别的是，boost::scoped_ptr 独享所有权，避免了 <code>std::auto_ptr</code>恼人的几个问题。<br>我们还是从代码开始分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestScopedPtr</span><span class="params">()</span> </span>&#123;</div><div class="line">  boost::scoped_ptr&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">    my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">    (*my_memory).info_extend += <span class="string">" other"</span>;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">   </div><div class="line">   	my_memory.release();           <span class="comment">// 编译 error: scoped_ptr 没有 release 函数</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory2;</div><div class="line">    my_memory2 = my_memory;        <span class="comment">// 编译 error: scoped_ptr 没有重载 operator=，不会导致所有权转移</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们可以看到，<code>boost::scoped_ptr</code>也可以像<code>auto_ptr</code>一样正常使用。但其没有<code>release()</code>函数，不会导致先前的内存泄露问题。其次，由于<code>boost::scoped_ptr</code>是独享所有权的，所以明确拒绝用户写“my_memory2 = my_memory”之类的语句，可以缓解<code>std::auto_ptr</code>几个恼人的问题。</p>
<p>由于<code>boost::scoped_ptr</code>独享所有权，当我们真真需要复制智能指针时，需求便满足不了了，如此我们再引入一个智能指针，专门用于处理复制，参数传递的情况，这便是如下的<code>boost::shared_ptr</code>。</p>
<p>###4、boost::shared_ptr<br><code>boost::shared_ptr</code>属于 boost 库，定义在 namespace boost 中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt;</code>便可以使用。在上面我们看到<code>boost::scoped_ptr</code>独享所有权，不允许赋值、拷贝，<code>boost::shared_ptr</code>是专门用于共享所有权的，由于要共享所有权，其在内部使用了引用计数。boost::shared_ptr 也是用于管理单个堆内存对象的。<br>我们还是从代码开始分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedPtr</span><span class="params">(boost::<span class="built_in">shared_ptr</span>&lt;Simple&gt; memory)</span> </span>&#123;  <span class="comment">// 注意：无需使用 reference (或 const reference)</span></div><div class="line">  memory-&gt;PrintSomething();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedPtr UseCount: "</span> &lt;&lt; memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedPtr2</span><span class="params">()</span> </span>&#123;</div><div class="line">  boost::<span class="built_in">shared_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">    my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">    (*my_memory).info_extend += <span class="string">" other"</span>;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedPtr2 UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  TestSharedPtr(my_memory);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedPtr2 UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="comment">//my_memory.release();// 编译 error: 同样，shared_ptr 也没有 release 函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">1</span></div><div class="line">PrintSomething:</div><div class="line">PrintSomething: Addition</div><div class="line">PrintSomething: Addition other</div><div class="line">TestSharedPtr2 UseCount: <span class="number">1</span></div><div class="line">PrintSomething: Addition other</div><div class="line">TestSharedPtr UseCount: <span class="number">2</span></div><div class="line">TestSharedPtr2 UseCount: <span class="number">1</span></div><div class="line"></div><div class="line">~Simple: <span class="number">1</span></div></pre></td></tr></table></figure>
<p><code>boost::shared_ptr</code>也可以很方便的使用。并且没有<code>release()</code>函数。关键的一点，boost::shared_ptr 内部维护了一个引用计数，由此可以支持复制、参数传递等。boost::shared_ptr 提供了一个函数 use_count() ，此函数返回 boost::shared_ptr 内部的引用计数。查看执行结果，我们可以看到在 TestSharedPtr2 函数中，引用计数为 1，传递参数后（此处进行了一次复制），在函数TestSharedPtr 内部，引用计数为2，在 TestSharedPtr 返回后，引用计数又降低为 1。当我们需要使用一个共享对象的时候，boost::shared_ptr 是再好不过的了。<br>在此，我们已经看完单个对象的智能指针管理，关于智能指针管理数组，我们接下来讲到。</p>
<p>###5、boost::scoped_array<br><code>boost::scoped_array</code> 属于 boost 库，定义在<code>namespace boost</code>中，包含头文件 #include<boost smart_ptr.hpp=""> 便可以使用。<br>    boost::scoped_array 便是用于管理动态数组的。跟 boost::scoped_ptr 一样，也是独享所有权的。<br>我们还是从代码开始分析：</boost></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestScopedArray</span><span class="params">()</span> </span>&#123;</div><div class="line">   boost::scoped_array&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple[<span class="number">2</span>]); <span class="comment">// 使用内存数组来初始化</span></div><div class="line">   <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">     my_memory[<span class="number">0</span>].PrintSomething();</div><div class="line">     my_memory.get()[<span class="number">0</span>].info_extend = <span class="string">"Addition"</span>;</div><div class="line">     my_memory[<span class="number">0</span>].PrintSomething();</div><div class="line">     </div><div class="line">  	(*my_memory)[<span class="number">0</span>].info_extend += <span class="string">" other"</span>;            <span class="comment">// 编译 error，scoped_ptr 没有重载 operator*</span></div><div class="line">     my_memory[<span class="number">0</span>].release();                             <span class="comment">// 同上，没有 release 函数</span></div><div class="line">     boost::scoped_array&lt;Simple&gt; my_memory2;</div><div class="line">     my_memory2 = my_memory;                             <span class="comment">// 编译 error，同上，没有重载 operator=</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>boost::scoped_array 的使用跟 boost::scoped_ptr 差不多，不支持复制，并且初始化的时候需要使用动态数组。另外，boost::scoped_array 没有重载“operator*”，其实这并无大碍，一般情况下，我们使用 get() 函数更明确些。</p>
<p>下面肯定应该讲 boost::shared_array 了，一个用引用计数解决复制、参数传递的智能指针类。</p>
<p>###6、boost::shared_array<br>boost::shared_array 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost smart_ptr.hpp=""> 便可以使用。</boost></p>
<p>由于 boost::scoped_array 独享所有权，显然在很多情况下（参数传递、对象赋值等）不满足需求，由此我们引入 boost::shared_array。跟 boost::shared_ptr 一样，内部使用了引用计数。<br>我们还是从代码开始分析:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedArray</span><span class="params">(boost::shared_array&lt;Simple&gt; memory)</span> </span>&#123;  <span class="comment">// 注意：无需使用 reference (或 const reference)</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedArray UseCount: "</span> &lt;&lt; memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedArray2</span><span class="params">()</span> </span>&#123;</div><div class="line">  boost::shared_array&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple[<span class="number">2</span>]);</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory[<span class="number">0</span>].PrintSomething();</div><div class="line">    my_memory.get()[<span class="number">0</span>].info_extend = <span class="string">"Addition 00"</span>;</div><div class="line">    my_memory[<span class="number">0</span>].PrintSomething();</div><div class="line">    my_memory[<span class="number">1</span>].PrintSomething();</div><div class="line">    my_memory.get()[<span class="number">1</span>].info_extend = <span class="string">"Addition 11"</span>;</div><div class="line">    my_memory[<span class="number">1</span>].PrintSomething();</div><div class="line">    <span class="comment">//(*my_memory)[0].info_extend += " other";  // 编译 error，scoped_ptr 没有重载 operator*</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedArray2 UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  TestSharedArray(my_memory);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedArray2 UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">0</span></div><div class="line">Simple: <span class="number">0</span></div><div class="line">PrintSomething:</div><div class="line">PrintSomething: Addition <span class="number">00</span></div><div class="line">PrintSomething:</div><div class="line">PrintSomething: Addition <span class="number">11</span></div><div class="line">TestSharedArray2 UseCount: <span class="number">1</span></div><div class="line">TestSharedArray UseCount: <span class="number">2</span></div><div class="line">TestSharedArray2 UseCount: <span class="number">1</span></div><div class="line"></div><div class="line">~Simple: <span class="number">0</span></div><div class="line">~Simple: <span class="number">0</span></div></pre></td></tr></table></figure>
<p>跟<code>boost::shared_ptr</code>一样，使用了引用计数，可以复制，通过参数来传递。</p>
<p>至此，我们讲过的智能指针有<code>std::auto_ptr</code>、<code>boost::scoped_ptr</code>、<code>boost::shared_ptr</code>、<code>boost::scoped_array</code>、<code>boost::shared_array</code>。这几个智能指针已经基本够我们使用了，90% 的使用过标准智能指针的代码就这 5 种。可如下还有两种智能指针，它们肯定有用，但有什么用处呢，一起看看吧。</p>
<p>###7、boost::weak_ptr<br>boost::weak_ptr 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost smart_ptr.hpp=""> 便可以使用。<br>在讲 boost::weak_ptr 之前，让我们先回顾一下前面讲解的内容。似乎 boost::scoped_ptr、boost::shared_ptr 这两个智能指针就可以解决所有单个对象内存的管理了，这儿还多出一个 boost::weak_ptr，是否还有某些情况我们没纳入考虑呢？<br>回答：有。首先 boost::weak_ptr 是专门为 boost::shared_ptr 而准备的。有时候，我们只关心能否使用对象，并不关心内部的引用计数。boost::weak_ptr 是 boost::shared_ptr 的观察者（Observer）对象，观察者意味着 boost::weak_ptr 只对 boost::shared_ptr 进行引用，而不改变其引用计数，当被观察的 boost::shared_ptr 失效后，相应的 boost::weak_ptr 也相应失效。<br>我们还是从代码开始分析：</boost></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestWeakPtr</span><span class="params">()</span> </span>&#123;</div><div class="line">  boost::weak_ptr&lt;Simple&gt; my_memory_weak;</div><div class="line">  boost::<span class="built_in">shared_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestWeakPtr boost::shared_ptr UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  my_memory_weak = my_memory;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestWeakPtr boost::shared_ptr UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">1</span></div><div class="line">TestWeakPtr boost::<span class="built_in">shared_ptr</span> UseCount: <span class="number">1</span></div><div class="line">TestWeakPtr boost::<span class="built_in">shared_ptr</span> UseCount: <span class="number">1</span></div><div class="line"></div><div class="line">~Simple: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们看到，尽管被赋值了，内部的引用计数并没有什么变化，当然，读者也可以试试传递参数等其他情况。<br>现在要说的问题是，<code>boost::weak_ptr</code>到底有什么作用呢？从上面那个例子看来，似乎没有任何作用，其实<code>boost::weak_ptr</code>主要用在软件架构设计中，可以在基类（此处的基类并非抽象基类，而是指继承于抽象基类的虚基类）中定义一个<code>boost::weak_ptr</code>，用于指向子类的 boost::shared_ptr，这样基类仅仅观察自己的 boost::weak_ptr 是否为空就知道子类有没对自己赋值了，而不用影响子类 boost::shared_ptr 的引用计数，用以降低复杂度，更好的管理对象。</p>
<p>###8、boost::intrusive_ptr<br><code>boost::intrusive_ptr</code>属于 boost 库，定义在 namespace boost 中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt;</code>便可以使用。<br>讲完如上 6 种智能指针后，对于一般程序来说 C++ 堆内存管理就够用了，现在有多了一种<code>boost::intrusive_ptr</code>，这是一种插入式的智能指针，内部不含有引用计数，需要程序员自己加入引用计数，不然编译不过（⊙﹏⊙b汗）。个人感觉这个智能指针没太大用处，至少我没用过。有兴趣的朋友自己研究一下源代码哦J。</p>
<p>##三、总结<br>如上讲了这么多智能指针，有必要对这些智能指针做个总结：<br>1、在可以使用 boost 库的场合下，拒绝使用 std::auto_ptr，因为其不仅不符合 C++ 编程思想，而且极容易出错[2]。<br>2、在确定对象无需共享的情况下，使用 boost::scoped_ptr（当然动态数组使用 boost::scoped_array）。<br>3、在对象需要共享的情况下，使用 boost::shared_ptr（当然动态数组使用 boost::shared_array）。<br>4、在需要访问 boost::shared_ptr 对象，而又不想改变其引用计数的情况下，使用 boost::weak_ptr，一般常用于软件框架设计中。<br>5、最后一点，也是要求最苛刻一点：在你的代码中，不要出现 delete 关键字（或 C 语言的 free 函数），因为可以用智能指针去管理。</p>
<hr>
<p>[1]参见《effective C++（3rd）》，条款06 。<br>[2]关于 boost 库的使用，可本博客另外一篇文章：《在 Windows 中编译 boost1.42.0》。<br>[3]读者应该看到了，在我所有的名字前，都加了命名空间标识符std::（或boost::），这不是我不想写 using namespace XXX 之类的语句，在大型项目中，有可能会用到 N 个第三方库，如果把命名空间全放出来，命名污染（Naming conflicts）问题很难避免，到时要改回来是极端麻烦的事情。当然，如果你只是写 Demo，可以例外。</p>
<p>转自：<a href="http://blog.csdn.net/xt_xiaotian/article/details/5714477" target="_blank" rel="external">http://blog.csdn.net/xt_xiaotian/article/details/5714477</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/09/01/she-ji-mo-shi-shi-ba-ce-lue-mo-shi-strategy(dui-xiang-xing-wei-xing/" rel="next" title="设计模式 ( 十八 ) 策略模式Strategy（对象行为型)">
                <i class="fa fa-chevron-left"></i> 设计模式 ( 十八 ) 策略模式Strategy（对象行为型)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/09/03/auto-ptrde-shi-xian-c-plus-plus/" rel="prev" title="auto_ptr的实现及CTCI">
                auto_ptr的实现及CTCI <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/"
           data-title="C++智能指针详解" data-url="http://www.njiang.cn/2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar/avatar.jpg"
               alt="姜楠" />
          <p class="site-author-name" itemprop="name">姜楠</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">117</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/njiang1987" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姜楠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"njiang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
