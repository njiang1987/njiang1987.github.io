<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="转自：http://objccn.io/issue-7-3/
Key-value coding (KVC) 和 key-value observing (KVO) 是两种能让我们驾驭 Objective-C 动态特性并简化代码的机制。在这篇文章里，我们将接触一些如何利用这些特性的例子。
##观察 model 对象的变化在 Cocoa 的模型-视图-控制器 (Model-view-controlle">
<meta property="og:type" content="article">
<meta property="og:title" content="KVO和KVC读书笔记（一）">
<meta property="og:url" content="http://www.njiang.cn/2014/10/31/KVO和KVC读书笔记（一）/index.html">
<meta property="og:site_name" content="天空の城">
<meta property="og:description" content="转自：http://objccn.io/issue-7-3/
Key-value coding (KVC) 和 key-value observing (KVO) 是两种能让我们驾驭 Objective-C 动态特性并简化代码的机制。在这篇文章里，我们将接触一些如何利用这些特性的例子。
##观察 model 对象的变化在 Cocoa 的模型-视图-控制器 (Model-view-controlle">
<meta property="og:image" content="http://www.njiang.cn/uploads/header/meinv.jpg">
<meta property="og:updated_time" content="2016-12-26T08:40:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KVO和KVC读书笔记（一）">
<meta name="twitter:description" content="转自：http://objccn.io/issue-7-3/
Key-value coding (KVC) 和 key-value observing (KVO) 是两种能让我们驾驭 Objective-C 动态特性并简化代码的机制。在这篇文章里，我们将接触一些如何利用这些特性的例子。
##观察 model 对象的变化在 Cocoa 的模型-视图-控制器 (Model-view-controlle">
<meta name="twitter:image" content="http://www.njiang.cn/uploads/header/meinv.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.njiang.cn/2014/10/31/KVO和KVC读书笔记（一）/"/>





  <title> KVO和KVC读书笔记（一） | 天空の城 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-43682645-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">天空の城</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">愤怒的程序员，梦想着有一天也能飞！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/31/KVO和KVC读书笔记（一）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                KVO和KVC读书笔记（一）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-31T21:53:19+08:00">
              2014-10-31
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/31/KVO和KVC读书笔记（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/31/KVO和KVC读书笔记（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/meinv.jpg" rel="gallery_cj0lrx90x0070c8ti7tobs9wx"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/meinv.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        <p>转自：<a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">http://objccn.io/issue-7-3/</a></p>
<p>Key-value coding (KVC) 和 key-value observing (KVO) 是两种能让我们驾驭 Objective-C 动态特性并简化代码的机制。在这篇文章里，我们将接触一些如何利用这些特性的例子。</p>
<p>##观察 model 对象的变化<br>在 Cocoa 的模型-视图-控制器 (Model-view-controller)架构里，控制器负责让视图和模型同步。这一共有两步：当 model 对象改变的时候，视图应该随之改变以反映模型的变化；当用户和控制器交互的时候，模型也应该做出相应的改变。</p>
<p>KVO 能帮助我们让视图和模型保持同步。控制器可以观察视图依赖的属性变化。</p>
<p>让我们看一个例子：我们的模型类 LabColor 代表一种 Lab色彩空间里的颜色。和 RGB 不同，这种色彩空间有三个元素 L, a, b。我们要做一个用来改变这些值的滑块和一个显示颜色的方块区域。</p>
<p>我们的模型类有以下三个用来代表颜色的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> lComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> aComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> bComponent;</div></pre></td></tr></table></figure>
<p>##依赖的属性<br>我们需要从这个类创建一个 UIColor 对象来显示出颜色。我们添加三个额外的属性，分别对应 R, G, B：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> redComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> greenComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> blueComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *color;</div></pre></td></tr></table></figure>
<p>有了这些以后，我们就可以创建这个类的接口了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LabColor</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> lComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> aComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> bComponent;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> redComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> greenComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> blueComponent;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *color;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><a href="http://www.baidu.com" target="_blank" rel="external">维基百科</a>提供了转换 RGB 到 Lab 色彩空间的算法。写成方法之后如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">double</span>)greenComponent;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> D65TristimulusValues[<span class="number">1</span>] * inverseF(<span class="number">1.</span>/<span class="number">116.</span> * (<span class="keyword">self</span>.lComponent + <span class="number">16</span>) + <span class="number">1.</span>/<span class="number">500.</span> * <span class="keyword">self</span>.aComponent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[...]</div><div class="line"></div><div class="line">- (<span class="built_in">UIColor</span> *)color</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">UIColor</span> colorWithRed:<span class="keyword">self</span>.redComponent * <span class="number">0.01</span> green:<span class="keyword">self</span>.greenComponent * <span class="number">0.01</span> blue:<span class="keyword">self</span>.blueComponent * <span class="number">0.01</span> alpha:<span class="number">1.</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些代码没什么令人激动的地方。有趣的是<code>greenComponent</code> 属性依赖于<code>lComponent</code>和<code>aComponent</code>。不论何时设置 <code>lComponent</code>的值，我们需要让 RGB 三个 component 中与其相关的成员以及 color 属性都要得到通知以保持一致。这一点这在 KVO 中很重要。</p>
<p>Foundation 框架提供的表示属性依赖的机制如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>更详细的如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffecting&lt;键名&gt;</div></pre></td></tr></table></figure></p>
<p>在我们的例子中如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingRedComponent</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"lComponent"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingGreenComponent</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lComponent"</span>, <span class="string">@"aComponent"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingBlueComponent</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lComponent"</span>, <span class="string">@"bComponent"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingColor</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"redComponent"</span>, <span class="string">@"greenComponent"</span>, <span class="string">@"blueComponent"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们完整的表达了属性之间的依赖关系。请注意，我们可以把这些属性链接起来。打个比方，如果我们写一个子类去 override <code>redComponent</code> 方法，这些依赖关系仍然能正常工作。</p>
<blockquote>
<p>[Nan]:这个是系统回调函数，在这边提供依赖的关系，SDK会建立依赖关系链；比如color-&gt;redComponent-&gt;lComponent,当lComponent改变时，最终会影响到color。</p>
</blockquote>
<p>##观察变化<br>现在让我们目光转向控制器。<code>NSViewController</code>的子类拥有 LabColor model 对象作为其属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) LabColor *labColor;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们把视图控制器注册为观察者来接收 KVO 的通知，这可以用以下 NSObject 的方法来实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>这会让以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>在当 keyPath 的值改变的时候在观察者 anObserver 上面被调用。这个 API 看起来有一点吓人。更糟糕的是，我们还得记得调用以下的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div></pre></td></tr></table></figure>
<p>来移除观察者，否则我们我们的 app 会因为某些奇怪的原因崩溃。</p>
<p>对于大多数的应用来说，KVO 可以通过辅助类用一种更简单优雅的方式实现。我们在视图控制器添加以下的观察记号（Observation token）属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> colorObserveToken;</div></pre></td></tr></table></figure>
<p>当 labColor 在视图控制器中被设置时，我们只要 override labColor 的 setter 方法就行了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setLabColor:(LabColor *)labColor</div><div class="line">&#123;</div><div class="line">    _labColor = labColor;</div><div class="line">    <span class="keyword">self</span>.colorObserveToken = [KeyValueObserver observeObject:labColor                                               keyPath:<span class="string">@"color"</span>                                            target:<span class="keyword">self</span>                                          selector:<span class="keyword">@selector</span>(colorDidChange:)                                        options:<span class="built_in">NSKeyValueObservingOptionInitial</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)colorDidChange:(<span class="built_in">NSDictionary</span> *)change;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.colorView.backgroundColor = <span class="keyword">self</span>.labColor.color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>KeyValueObserver 辅助类 封装了<code>-addObserver:forKeyPath:options:context:，-observeValueForKeyPath:ofObject:change:context:和-removeObserverForKeyPath:</code>的调用，让视图控制器远离杂乱的代码。</p>
<blockquote>
<p>[Nan]:以后可以尝试应用此方法，当需要addObserver/removeObserver的时候，可以定义一个类，专门来控制添加删除的操作。</p>
</blockquote>
<p>##整合到一起<br>视图控制器需要对 L，a，b 的滑块控制做出反应：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)updateLComponent:(<span class="built_in">UISlider</span> *)sender;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.labColor.lComponent = sender.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)updateAComponent:(<span class="built_in">UISlider</span> *)sender;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.labColor.aComponent = sender.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)updateBComponent:(<span class="built_in">UISlider</span> *)sender;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.labColor.bComponent = sender.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所有的代码都在我们的 GitHub <a href="https://github.com/objcio/issue-7-lab-color-space-explorer" target="_blank" rel="external">示例代码</a> 中找到。</p>
<p>##手动通知 vs 自动通知<br>我们刚才所做的事情有点神奇，但是实际上发生的事情是，当 LabColor 实例的 -setLComponent: 等方法被调用的时候以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>和：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>会在运行 <code>-setLComponent:</code> 中的代码之前以及之后被自动调用。如果我们写了 -setLComponent: 或者我们选择使用自动 synthesize 的 lComponent 的 accessor 到时候就会发生这样的事情。</p>
<p>有些情况下当我们需要 override -setLComponent: 并且我们要控制是否发送键值改变的通知的时候，我们要做以下的事情：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//此方法关闭了lComponent得自动通知功能</span></div><div class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForLComponent;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setLComponent:(<span class="keyword">double</span>)lComponent;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_lComponent == lComponent) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"lComponent"</span>];</div><div class="line">    _lComponent = lComponent;</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"lComponent"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们关闭了 <code>-willChangeValueForKey:</code>和 <code>-didChangeValueForKey:</code> 的自动调用，然后我们手动调用他们。我们只应该在关闭了自动调用的时候我们才需要在 setter 方法里手动调用 <code>-willChangeValueForKey:</code>和 <code>-didChangeValueForKey:</code>。大多数情况下，这样优化不会给我们带来太多好处。</p>
<p>如果我们在 accessor 方法之外改变实例对象（如 _lComponent ），我们要特别小心地和刚才一样封装 -willChangeValueForKey: 和 -didChangeValueForKey:。不过在多数情况下，我们只用 accessor 方法的话就可以了，这样代码会简洁很多。</p>
<blockquote>
<p>[Nan]:如果在添加observer的时候用参数<code>NSKeyValueObservingOptionPrior</code>的话，再加上手动发送消息，就会受到2此相同的信息。</p>
</blockquote>
<p>##KVO 和 context<br>有时我们会有理由不想用 KeyValueObserver 辅助类。创建另一个对象会有额外的性能开销。如果我们观察很多个键的话，这个开销可能会变得明显。</p>
<p>如果我们在实现一个类的时候把它自己注册为观察者的话：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>一个非常重要的点是我们要传入一个这个类唯一的 <code>context</code>。我们推荐把以下代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> PrivateKVOContext;</div></pre></td></tr></table></figure>
<p>写在这个类 .m 文件的顶端，然后我们像这样调用 API 并传入 <code>PrivateKVOContext</code> 的指针：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[otherObject addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"someKey"</span> options:someOptions context:&amp;PrivateKVOContext];</div></pre></td></tr></table></figure>
<p>然后我们这样写 <code>-observeValueForKeyPath:...</code> 的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (context == &amp;PrivateKVOContext) &#123;</div><div class="line">        <span class="comment">// 这里写相关的观察代码</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将确保我们写的子类都是正确的。如此一来，子类和父类都能安全的观察同样的键值而不会冲突。否则我们将会碰到难以 debug 的奇怪行为。</p>
<p>##进阶 KVO<br>我们常常需要当一个值改变的时候更新 UI，但是我们也要在第一次运行代码的时候更新一次 UI。我们可以用 KVO 并添加<code>NSKeyValueObservingOptionInitial</code>的选项 来一箭双雕地做好这样的事情。这将会让 KVO 通知在调用 <code>-addObserver:forKeyPath:...</code>到时候也被触发。</p>
<p>###之前和之后<br>当我们注册 KVO 通知的时候，我们可以添加 <code>NSKeyValueObservingOptionPrior</code> 选项，这能使我们在键值改变之前被通知。这和<code>-willChangeValueForKey:</code>被触发的时间相对应。</p>
<p>如果我们注册通知的时候附加了 <code>NSKeyValueObservingOptionPrior</code> 选项，我们将会收到两个通知：一个在值变更前，另一个在变更之后。变更前的通知将会在 change 字典中有不同的键。我们可以像以下这样区分通知是在改变之前还是之后被触发的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNotificationIsPriorKey</span>] boolValue]) &#123;</div><div class="line">    <span class="comment">// 改变之前</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 改变之后</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###值<br>如果我们需要改变前后的值，我们可以在 KVO 选项中加入 <code>NSKeyValueObservingOptionNew</code>和/或 <code>NSKeyValueObservingOptionOld</code>。</p>
<p>更简单的办法是用 <code>NSKeyValueObservingOptionPrior</code> 选项，随后我们就可以用以下方式提取出改变前后的值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> oldValue = change[<span class="built_in">NSKeyValueChangeOldKey</span>];</div><div class="line"><span class="keyword">id</span> newValue = change[<span class="built_in">NSKeyValueChangeNewKey</span>];</div></pre></td></tr></table></figure>
<p>通常来说 KVO 会在<code>-willChangeValueForKey:</code> 和 <code>-didChangeValueForKey:</code> 被调用的时候存储相应键的值。</p>
<p>##索引<br>KVO 对一些集合类也有很强的支持，以下方法会返回集合对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-mutableArrayValueForKey:</div><div class="line">-mutableSetValueForKey:</div><div class="line">-mutableOrderedSetValueForKey:</div></pre></td></tr></table></figure></p>
<p>我们将会详细解释这是怎么工作的。如果你使用这些方法，change 字典里会包含键值变化的类型（添加、删除和替换）。对于有序的集合，change 字典会包含受影响的 index。</p>
<p>集合代理对象和变化的通知在用于更新UI的时候非常有效，尤其是处理大集合的时候。但是它们需要花费你一些心思。</p>
<p>##KVO 和线程<br>一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。没有队列或者 Run-loop 的处理。手动或者自动调用 -didChange… 会触发 KVO 通知。</p>
<p>所以，当我们试图从其他线程改变属性值的时候我们应当十分小心，除非能确定所有的观察者都用线程安全的方法处理 KVO 通知。通常来说，我们不推荐把 KVO 和多线程混起来。如果我们要用多个队列和线程，我们不应该在它们互相之间用 KVO。</p>
<p>KVO 是同步运行的这个特性非常强大，只要我们在单一线程上面运行（比如主队列 main queue），KVO 会保证下列两种情况的发生：</p>
<p>首先，如果我们调用一个支持 KVO 的 setter 方法，如下所示：</p>
<p>self.exchangeRate = 2.345;<br>KVO 能保证所有 exchangeRate 的观察者在 setter 方法返回前被通知到。</p>
<p>其次，如果某个键被观察的时候附上了 NSKeyValueObservingOptionPrior 选项，直到 -observe… 被调用之前， exchangeRate 的 accessor 方法都会返回同样的值。</p>
<p>KVC<br>最简单的 KVC 能让我们通过以下的形式访问属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div></pre></td></tr></table></figure></p>
<p>取值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *n = [object valueForKey:<span class="string">@"name"</span>]</div></pre></td></tr></table></figure></p>
<p>设定：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:<span class="string">@"Daniel"</span> forKey:<span class="string">@"name"</span>]</div></pre></td></tr></table></figure></p>
<p>值得注意的是这个不仅可以访问作为对象属性，而且也能访问一些标量（例如 int 和 CGFloat）和 struct（例如 CGRect）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> height;</div></pre></td></tr></table></figure></p>
<p>我们可以这样设置它：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:@(<span class="number">20</span>) forKey:<span class="string">@"height"</span>]</div></pre></td></tr></table></figure></p>
<p>KVC 允许我们用属性的字符串名称来访问属性，字符串在这儿叫做键。有些情况下，这会使我们非常灵活地简化代码。我们下一节介绍例子简化列表 UI。</p>
<p>KVC 还有更多可以谈的。集合（NSArray，NSSet 等）结合 KVC 可以拥有一些强大的集合操作。还有，对象可以支持用 KVC 通过代理对象访问非常规的属性。</p>
<p>##简化列表 UI<br>假设我们有这样一个对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Contact</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickname;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *email;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *city;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>还有一个 detail 视图控制器，含有四个对应的 UITextField 属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DetailViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *nameField;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *nicknameField;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *emailField;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *cityField;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们可以简化更新 UI 的逻辑。首先我们需要两个方法：一个返回 model 里我们用到的所有键的方法，一个把键映射到对应的文本框的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)contactStringKeys;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>, <span class="string">@"nickname"</span>, <span class="string">@"email"</span>, <span class="string">@"city"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UITextField</span> *)textFieldForModelKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> valueForKey:[key stringByAppendingString:<span class="string">@"Field"</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了这个，我们可以从 model 里更新文本框，如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updateTextFields;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> <span class="keyword">self</span>.contactStringKeys) &#123;</div><div class="line">        [<span class="keyword">self</span> textFieldForModelKey:key].text = [<span class="keyword">self</span>.contact valueForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也可以用一个 action 方法让四个文本框都能实时更新 model：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)fieldEditingDidEnd:(<span class="built_in">UITextField</span> *)sender</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> <span class="keyword">self</span>.contactStringKeys) &#123;</div><div class="line">        <span class="built_in">UITextField</span> *field = [<span class="keyword">self</span> textFieldForModelKey:key];</div><div class="line">        <span class="keyword">if</span> (field == sender) &#123;</div><div class="line">            [<span class="keyword">self</span>.contact setValue:sender.text forKey:key];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：我们之后会添加验证输入的部分，在键值验证里会提到。</p>
<p>最后，我们需要确认文本框在需要的时候被更新：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</div><div class="line">    [<span class="keyword">self</span> updateTextFields];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setContact:(Contact *)contact</div><div class="line">&#123;</div><div class="line">    _contact = contact;</div><div class="line">    [<span class="keyword">self</span> updateTextFields];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了这个，我们的 detail 视图控制器 就能正常工作了。</p>
<p>整个项目可以在 <a href="https://github.com/objcio/issue-7-contact-editor" target="_blank" rel="external">GitHub</a> 上找到。它也用了我们后面提到的键值验证。</p>
<p>###键路径（Key Path）<br>KVC 同样允许我们通过关系来访问对象。假设 person 对象有属性 address，address 有属性 city，我们可以这样通过 person 来访问 city：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person valueForKeyPath:<span class="string">@"address.city"</span>]</div></pre></td></tr></table></figure></p>
<p>值得注意的是这里我们调用 <code>-valueForKeyPath:</code> 而不是 <code>-valueForKey:</code>。</p>
<p>##Key-Value Coding Without @property<br>不需要 @property 的 KVC<br>我们可以实现一个支持 KVC 而不用 @property 和 @synthesize 或是自动 synthesize 的属性。最直接的方式是添加 -<key> 和 -set<key>: 方法。例如我们想要 name ，我们这样做：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)name;</div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</div></pre></td></tr></table></figure></key></key></p>
<p>这完全等于 @property 的实现方式。</p>
<p>但是当标量和 struct 的值被传入 nil 的时候尤其需要注意。假设我们要 height 属性支持 KVC 我们写了以下的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)height;</div><div class="line">- (<span class="keyword">void</span>)setHeight:(<span class="built_in">CGFloat</span>)height;</div></pre></td></tr></table></figure></p>
<p>然后我们这样调用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:<span class="literal">nil</span> forKey:<span class="string">@"height"</span>]</div></pre></td></tr></table></figure></p>
<p>这会抛出一个 exception。要正确的处理 nil，我们要像这样 override <code>-setNilValueForKey:</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"height"</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> setValue:@<span class="number">0</span> forKey:key];</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        [<span class="keyword">super</span> setNilValueForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以通过 override 这些方法来让一个类支持 KVC：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure></p>
<p>这也许看起来很怪，但这可以让一个类动态的支持一些键的访问。但是这两个方法会在性能上拖后腿。</p>
<p>附注：Foundation 框架支持直接访问实例变量。请小心的使用这个特性。你可以去查看 +accessInstanceVariablesDirectly 的文档。这个值默认是 YES 的时候，Foundation 会按照 _<key>, _is<key>, <key> 和 is<key> 的顺序查找实例变量。</key></key></key></key></p>
<p>###集合的操作<br>一个常常被忽视的 KVC 特性是它对集合操作的支持。举个例子，我们可以这样来获得一个数组中最大的值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *a = @[@<span class="number">4</span>, @<span class="number">84</span>, @<span class="number">2</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"max = %@"</span>, [a valueForKeyPath:<span class="string">@"@max.self"</span>]);</div></pre></td></tr></table></figure></p>
<p>或者说，我们有一个 Transaction 对象的数组，对象有属性 amount 的话，我们可以这样获得最大的 amount：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *a = @[transaction1, transaction2, transaction3];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"max = %@"</span>, [a valueForKeyPath:<span class="string">@"@max.amount"</span>]);</div></pre></td></tr></table></figure></p>
<p>当我们调用<code>[a valueForKeyPath:@&quot;@max.amount&quot;]</code> 的时候，它会在数组 a 的每个元素中调用 <code>-valueForKey:@&quot;amount&quot;</code>然后返回最大的那个。</p>
<p>KVC 的苹果官方文档有一个章节 Collection Operators 详细的讲述了类似的用法。</p>
<p>通过集合代理对象来实现 KVC<br>虽然我们可以像对待一般的对象一样用 KVC 深入集合内部（NSArray 和 NSSet 等），但是通过集合代理对象， KVC 也让我们实现一个兼容 KVC 的集合。这是一个颇为高端的技巧。</p>
<p>当我们在对象上调用 -valueForKey: 的时候，它可以返回 NSArray，NSSet 或是 NSOrderedSet 的集合代理对象。这个类没有实现通常的 -<key> 方法，但是它实现了代理对象所需要使用的很多方法。</key></p>
<p>如果我们希望一个类支持通过代理对象的 contacts 键返回一个 NSArray，我们可以这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)countOfContacts;</div><div class="line">- (<span class="keyword">id</span>)objectInContactsAtIndex:(<span class="built_in">NSUInteger</span>)idx;</div></pre></td></tr></table></figure></p>
<p>这样做的话，当我们调用 [object valueForKey:@”contacts”] 的时候，它会返回一个由这两个方法来代理所有调用方法的 NSArray 对象。这个数组支持所有正常的对 NSArray 的调用。换句话说，调用者并不知道返回的是一个真正的 NSArray， 还是一个代理的数组。</p>
<p>对于 NSSet 和 NSOrderedSet，如果要做同样的事情，我们需要实现的方法是：</p>
<table>
<thead>
<tr>
<th>NSArray</th>
<th>NSSet</th>
<th>NSOrderedSet   </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-countOf&lt;Key&gt;</code></td>
<td><code>-countOf&lt;Key&gt;</code></td>
<td><code>-countOf&lt;Key&gt;</code></td>
</tr>
<tr>
<td>-</td>
<td><code>-enumeratorOf&lt;Key&gt;</code></td>
<td><code>-indexIn&lt;Key&gt;OfObject:</code></td>
</tr>
<tr>
<td> -</td>
<td><code>-memberOf&lt;Key&gt;:</code></td>
<td>-</td>
</tr>
<tr>
<td>以下两者二选一</td>
<td>-</td>
<td>以下两者二选一</td>
</tr>
<tr>
<td><code>-objectIn&lt;Key&gt;AtIndex:</code></td>
<td>-</td>
<td><code>-objectIn&lt;Key&gt;AtIndex:</code></td>
</tr>
<tr>
<td><code>-&lt;key&gt;AtIndexes:</code></td>
<td>-</td>
<td><code>-&lt;key&gt;AtIndexes:</code>     </td>
</tr>
<tr>
<td>可选（增强性能）</td>
<td>-</td>
<td>可选（增强性能）</td>
</tr>
<tr>
<td><code>-get&lt;Key&gt;:range:</code></td>
<td>-</td>
<td><code>-get&lt;Key&gt;:range:</code></td>
</tr>
</tbody>
</table>
<p>可选 的一些方法可以增强代理对象的性能。</p>
<p>虽然只有特殊情况下我们用这些代理对象才会有意义，但是在这些情况下代理对象非常的有用。想象一下我们有一个很大的数据结构，调用者不需要（一次性）访问所有的对象。</p>
<p>举一个（也许比较做作的）例子说，我们想写一个包含有很长一串质数的类。如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Primes</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *primes;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Primes</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> int32_t <span class="keyword">const</span> primes[] = &#123;</div><div class="line">    <span class="number">2</span>, <span class="number">101</span>, <span class="number">233</span>, <span class="number">383</span>, <span class="number">3</span>, <span class="number">103</span>, <span class="number">239</span>, <span class="number">389</span>, <span class="number">5</span>, <span class="number">107</span>, <span class="number">241</span>, <span class="number">397</span>, <span class="number">7</span>, <span class="number">109</span>,</div><div class="line">    <span class="number">251</span>, <span class="number">401</span>, <span class="number">11</span>, <span class="number">113</span>, <span class="number">257</span>, <span class="number">409</span>, <span class="number">13</span>, <span class="number">127</span>, <span class="number">263</span>, <span class="number">419</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">269</span>,</div><div class="line">    <span class="number">421</span>, <span class="number">19</span>, <span class="number">137</span>, <span class="number">271</span>, <span class="number">431</span>, <span class="number">23</span>, <span class="number">139</span>, <span class="number">277</span>, <span class="number">433</span>, <span class="number">29</span>, <span class="number">149</span>, <span class="number">281</span>, <span class="number">439</span>,</div><div class="line">    <span class="number">31</span>, <span class="number">151</span>, <span class="number">283</span>, <span class="number">443</span>, <span class="number">37</span>, <span class="number">157</span>, <span class="number">293</span>, <span class="number">449</span>, <span class="number">41</span>, <span class="number">163</span>, <span class="number">307</span>, <span class="number">457</span>, <span class="number">43</span>,</div><div class="line">    <span class="number">167</span>, <span class="number">311</span>, <span class="number">461</span>, <span class="number">47</span>, <span class="number">173</span>, <span class="number">313</span>, <span class="number">463</span>, <span class="number">53</span>, <span class="number">179</span>, <span class="number">317</span>, <span class="number">467</span>, <span class="number">59</span>, <span class="number">181</span>,</div><div class="line">    <span class="number">331</span>, <span class="number">479</span>, <span class="number">61</span>, <span class="number">191</span>, <span class="number">337</span>, <span class="number">487</span>, <span class="number">67</span>, <span class="number">193</span>, <span class="number">347</span>, <span class="number">491</span>, <span class="number">71</span>, <span class="number">197</span>, <span class="number">349</span>,</div><div class="line">    <span class="number">499</span>, <span class="number">73</span>, <span class="number">199</span>, <span class="number">353</span>, <span class="number">503</span>, <span class="number">79</span>, <span class="number">211</span>, <span class="number">359</span>, <span class="number">509</span>, <span class="number">83</span>, <span class="number">223</span>, <span class="number">367</span>, <span class="number">521</span>,</div><div class="line">    <span class="number">89</span>, <span class="number">227</span>, <span class="number">373</span>, <span class="number">523</span>, <span class="number">97</span>, <span class="number">229</span>, <span class="number">379</span>, <span class="number">541</span>, <span class="number">547</span>, <span class="number">701</span>, <span class="number">877</span>, <span class="number">1049</span>,</div><div class="line">    <span class="number">557</span>, <span class="number">709</span>, <span class="number">881</span>, <span class="number">1051</span>, <span class="number">563</span>, <span class="number">719</span>, <span class="number">883</span>, <span class="number">1061</span>, <span class="number">569</span>, <span class="number">727</span>, <span class="number">887</span>,</div><div class="line">    <span class="number">1063</span>, <span class="number">571</span>, <span class="number">733</span>, <span class="number">907</span>, <span class="number">1069</span>, <span class="number">577</span>, <span class="number">739</span>, <span class="number">911</span>, <span class="number">1087</span>, <span class="number">587</span>, <span class="number">743</span>,</div><div class="line">    <span class="number">919</span>, <span class="number">1091</span>, <span class="number">593</span>, <span class="number">751</span>, <span class="number">929</span>, <span class="number">1093</span>, <span class="number">599</span>, <span class="number">757</span>, <span class="number">937</span>, <span class="number">1097</span>, <span class="number">601</span>,</div><div class="line">    <span class="number">761</span>, <span class="number">941</span>, <span class="number">1103</span>, <span class="number">607</span>, <span class="number">769</span>, <span class="number">947</span>, <span class="number">1109</span>, <span class="number">613</span>, <span class="number">773</span>, <span class="number">953</span>, <span class="number">1117</span>,</div><div class="line">    <span class="number">617</span>, <span class="number">787</span>, <span class="number">967</span>, <span class="number">1123</span>, <span class="number">619</span>, <span class="number">797</span>, <span class="number">971</span>, <span class="number">1129</span>, <span class="number">631</span>, <span class="number">809</span>, <span class="number">977</span>,</div><div class="line">    <span class="number">1151</span>, <span class="number">641</span>, <span class="number">811</span>, <span class="number">983</span>, <span class="number">1153</span>, <span class="number">643</span>, <span class="number">821</span>, <span class="number">991</span>, <span class="number">1163</span>, <span class="number">647</span>, <span class="number">823</span>,</div><div class="line">    <span class="number">997</span>, <span class="number">1171</span>, <span class="number">653</span>, <span class="number">827</span>, <span class="number">1009</span>, <span class="number">1181</span>, <span class="number">659</span>, <span class="number">829</span>, <span class="number">1013</span>, <span class="number">1187</span>, <span class="number">661</span>,</div><div class="line">    <span class="number">839</span>, <span class="number">1019</span>, <span class="number">1193</span>, <span class="number">673</span>, <span class="number">853</span>, <span class="number">1021</span>, <span class="number">1201</span>, <span class="number">677</span>, <span class="number">857</span>, <span class="number">1031</span>,</div><div class="line">    <span class="number">1213</span>, <span class="number">683</span>, <span class="number">859</span>, <span class="number">1033</span>, <span class="number">1217</span>, <span class="number">691</span>, <span class="number">863</span>, <span class="number">1039</span>, <span class="number">1223</span>, <span class="number">1229</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>)countOfPrimes;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">sizeof</span>(primes) / <span class="keyword">sizeof</span>(*primes));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)objectInPrimesAtIndex:(<span class="built_in">NSUInteger</span>)idx;</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(idx &lt; <span class="keyword">sizeof</span>(primes) / <span class="keyword">sizeof</span>(*primes));</div><div class="line">    <span class="keyword">return</span> @(primes[idx]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>我们将会运行以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Primes *primes = [[Primes alloc] init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"The last prime is %@"</span>, [primes.primes lastObject]);</div></pre></td></tr></table></figure></p>
<p>这将会调用一次 <code>-countOfPrimes</code>和一次传入参数 idx 作为最后一个索引的 <code>-objectInPrimesAtIndex:</code>。为了只取出最后一个值，它不需要先把所有的数封装成 NSNumber 然后把它们都导入 NSArray。</p>
<p>在一个复杂一点的例子中，通讯录编辑器示例 app 用同样的方法把 C++ std::vector 封装以来。它详细说明了应该怎么利用这个方法。</p>
<p>###可变的集合<br>我们也可以在可变集合（例如 <code>NSMutableArray</code>，<code>NSMutableSet</code>，和 <code>NSMutableOrderedSet</code>）中用集合代理。</p>
<p>访问这些可变的集合有一点点不同。调用者在这儿需要调用以下其中一个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">NSMutableSet</span> *)mutableSetValueForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure></p>
<p>一个窍门：我们可以让一个类用以下方法返回可变集合的代理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableArray</span> *)mutableContacts;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mutableArrayValueForKey:<span class="string">@"wrappedContacts"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在实现键 wrappedContacts 的一些方法。</p>
<p>我们需要实现上面的不变集合的两个方法，还有以下的几个：</p>
<table>
<thead>
<tr>
<th>NSMutableArray / NSMutableOrderedSet</th>
<th>NSMutableSet    </th>
</tr>
</thead>
<tbody>
<tr>
<td>至少实现一个插入方法和一个删除方法</td>
<td>至少实现一个插入方法和一个删除方法</td>
</tr>
<tr>
<td><code>-insertObject:in&lt;Key&gt;AtIndex:</code></td>
<td><code>-add&lt;Key&gt;Object:</code></td>
</tr>
<tr>
<td><code>-removeObjectFrom&lt;Key&gt;AtIndex:</code></td>
<td><code>-remove&lt;Key&gt;Object:</code></td>
</tr>
<tr>
<td><code>-insert&lt;Key&gt;:atIndexes:</code></td>
<td><code>-add&lt;Key&gt;:</code></td>
</tr>
<tr>
<td><code>-remove&lt;Key&gt;AtIndexes:</code></td>
<td><code>-remove&lt;Key&gt;:</code></td>
</tr>
<tr>
<td>可选（增强性能）以下方法二选一</td>
<td>可选（增强性能）</td>
</tr>
<tr>
<td><code>-replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code></td>
<td><code>-intersect&lt;Key&gt;:</code></td>
</tr>
<tr>
<td><code>-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code></td>
<td><code>-set&lt;Key&gt;:</code></td>
</tr>
</tbody>
</table>
<p>上面提到，这些可变集合代理对象和 KVO 结合起来也十分强大。KVO 机制能在这些集合改变的时候把详细的变化放进 change 字典中。</p>
<p>有批量更新（需要传入多个对象）的方法，也有只改变一个对象的方法。我们推荐选择相对于给定任务来说最容易实现的那个来写，虽然我们有一点点倾向于选择批量更新的那个。</p>
<p>在实现这些方法的时候，我们要对自动和手动的 KVO 之间的差别十分小心。Foundation 默认自动发出十分详尽的变化通知。如果我们要手动实现发送详细通知的话，我们得实现这些：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-willChange:valuesAtIndexes:forKey:</div><div class="line">-didChange:valuesAtIndexes:forKey:</div></pre></td></tr></table></figure></p>
<p>或者这些：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-willChangeValueForKey:withSetMutation:usingObjects:</div><div class="line">-didChangeValueForKey:withSetMutation:usingObjects:</div></pre></td></tr></table></figure></p>
<p>我们要保证先把自动通知关闭，否则每次改变 KVO 都会发出两次通知。</p>
<p>##常见的 KVO 错误<br>首先，KVO 兼容是 API的一部分。如果类的所有者不保证某个属性兼容 KVO，我们就不能保证 KVO 正常工作。苹果文档里有 KVO 兼容属性的文档。例如，NSProgress 类的大多数属性都是兼容 KVO 的。</p>
<p>当做出改变以后，有些人试着放空的 -willChange 和 -didChange 方法来强制 KVO 的触发。KVO 通知虽然会生效，但是这样做破坏了有依赖于 NSKeyValueObservingOld 选项的观察者。详细来说，这影响了 KVO 对观察键路径 (key path) 的原生支持。KVO 在观察键路径 (key path) 时依赖于 NSKeyValueObservingOld 属性。</p>
<p>我们也要指出有些集合是不能被观察的。KVO 旨在观察关系 (relationship) 而不是集合。我们不能观察 NSArray，我们只能观察一个对象的属性——而这个属性有可能是 NSArray。举例说，如果我们有一个 ContactList 对象，我们可以观察它的 contacts 属性。但是我们不能向要观察对象的 -addObserver:forKeyPath:… 传入一个 NSArray。</p>
<p>相似地，观察 self 不是永远都生效的。而且这不是一个好的设计。</p>
<p>##调试 KVO<br>你可以在 lldb 里查看一个被观察对象的所有观察信息。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) po [observedObject observationInfo]</div></pre></td></tr></table></figure></p>
<p>这会打印出有关谁观察谁之类的很多信息。</p>
<p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。</p>
<p>##键值验证 (KVV)<br>最后提示，KVV 也是 KVC API 的一部分。这是一个用来验证属性值的 API，只是它光靠自己很难提供逻辑和功能。</p>
<p>如果我们写能够验证值的 model 类的话，我们就应该实现 KVV 的 API 来保证一致性。用 KVV 验证 model 类的值是 Cocoa 的惯例。</p>
<p>让我们在一次强调一下：KVC 不会做任何的验证，也不会调用任何 KVV 的方法。那是你的控制器需要做的事情。通过 KVV 实现你自己的验证方法会保证它们的一致性。</p>
<p>以下是一个简单的例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)nameFieldEditingDidEnd:(<span class="built_in">UITextField</span> *)sender;</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *name = [sender text];</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.contact validateName:&amp;name error:&amp;error]) &#123;</div><div class="line">        <span class="keyword">self</span>.contact.name = name;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Present the error to the user</span></div><div class="line">    &#125;</div><div class="line">    sender.text = <span class="keyword">self</span>.contact.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它强大之处在于，当 model 类（Contact）验证 name 的时候，会有机会去处理名字。</p>
<p>如果我们想让名字不要有前后的空白字符，我们应该把这些逻辑放在 model 对象里面。Contact 类可以像这样实现 KVV：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validateName:(<span class="built_in">NSString</span> **)nameP error:(<span class="built_in">NSError</span> * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (*nameP == <span class="literal">nil</span>) &#123;</div><div class="line">        *nameP = <span class="string">@""</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        *nameP = [*nameP stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> whitespaceAndNewlineCharacterSet]];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通讯录示例 里的 <code>DetailViewController</code> 和 Contact 类详解了这个用法。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/10/31/2014-10-iOS-基础集合类/" rel="next" title="[iOS]基础集合类">
                <i class="fa fa-chevron-left"></i> [iOS]基础集合类
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/11/01/-LeetCode-Exercise-Day1/" rel="prev" title="[LeetCode]Exercise(Day1)">
                [LeetCode]Exercise(Day1) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2014/10/31/KVO和KVC读书笔记（一）/"
           data-title="KVO和KVC读书笔记（一）" data-url="http://www.njiang.cn/2014/10/31/KVO和KVC读书笔记（一）/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar/avatar.jpg"
               alt="姜楠" />
          <p class="site-author-name" itemprop="name">姜楠</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">117</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/njiang1987" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姜楠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"njiang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
