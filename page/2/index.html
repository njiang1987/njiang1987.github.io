<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="天空の城">
<meta property="og:url" content="http://www.njiang.cn/page/2/index.html">
<meta property="og:site_name" content="天空の城">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天空の城">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.njiang.cn/page/2/"/>





  <title> 天空の城 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-43682645-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">天空の城</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">愤怒的程序员，梦想着有一天也能飞！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2016/11/17/转-ReactNative-iOS源码解析（一）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/17/转-ReactNative-iOS源码解析（一）/" itemprop="url">
                  [转]ReactNative iOS源码解析（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-17T20:23:00+08:00">
              2016-11-17
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/17/转-ReactNative-iOS源码解析（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/17/转-ReactNative-iOS源码解析（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>本篇前两部分内容简单介绍一下ReactNative，后面的章节会把整个RN框架的iOS部分，进行代码层面的一一梳理</p>
<p>全文是不是有点太长了，我要不要分拆成几篇文章</p>
<p>函数栈代码流程图，由于采用层次缩进的形式，层次关系比较深的话，不是很利于手机阅读，</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/11/17/转-ReactNative-iOS源码解析（一）/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2016/11/17/转-有关web-API跨域访问的问题/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/17/转-有关web-API跨域访问的问题/" itemprop="url">
                  [转]跨域资源共享 CORS 详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-17T14:36:07+08:00">
              2016-11-17
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/17/转-有关web-API跨域访问的问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/17/转-有关web-API跨域访问的问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a><strong>1 简介</strong></h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/11/17/转-有关web-API跨域访问的问题/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2016/11/14/转-React-Native-从入门到原理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/14/转-React-Native-从入门到原理/" itemprop="url">
                  [转]React Native 从入门到原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-14T16:39:38+08:00">
              2016-11-14
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/14/转-React-Native-从入门到原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/14/转-React-Native-从入门到原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>React Native 是最近非常火的一个话题，介绍如何利用 React Native 进行开发的文章和书籍多如牛毛，但面向入门水平并介绍它工作原理的文章却寥寥无几。</p>
<p>本文分为两个部分：上半部分用通俗的语言解释了相关的名词，重点介绍 React Native 出现的背景和试图解决的问题。适合新手对 React Native 形成初步了解。(事实证明，女票能看懂这段）</p>
<p>下半部分则通过源码（0.27 版本）分析 React Native 的工作原理，适合深入学习理解 React Native 的运行机制。最后则是我个人对 React Native 的分析与前景判断。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/11/14/转-React-Native-从入门到原理/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2016/11/14/转-React-Native通信机制详解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/14/转-React-Native通信机制详解/" itemprop="url">
                  [转]React Native通信机制详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-14T15:39:08+08:00">
              2016-11-14
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/14/转-React-Native通信机制详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/14/转-React-Native通信机制详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://facebook.github.io/react-native/">React Native</a>是facebook刚开源的框架，可以用javascript直接开发原生APP，先不说这个框架后续是否能得到大众认可，单从源码来说，这个框架源码里有非常多的设计思想和实现方式值得学习，本篇先来看看它最基础的JavaScript-ObjectC通信机制(以下简称JS/OC)。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/11/14/转-React-Native通信机制详解/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2016/10/25/原创-搭建Mac平台的vnpy量化开发环境/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/25/原创-搭建Mac平台的vnpy量化开发环境/" itemprop="url">
                  [原创]搭建Mac平台的vnpy量化开发环境
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-25T21:17:04+08:00">
              2016-10-25
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/量化投资/" itemprop="url" rel="index">
                    <span itemprop="name">量化投资</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/25/原创-搭建Mac平台的vnpy量化开发环境/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/25/原创-搭建Mac平台的vnpy量化开发环境/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/meinv.jpg" rel="gallery_cixjz0myy008w5ntidtxtkcq2"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/meinv.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        
          <p>量化投资vpny在mac下的环境搭建…</p>
<ul>
<li>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/10/25/原创-搭建Mac平台的vnpy量化开发环境/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2015/07/15/Git-关于git上传文件过大报错的问题-remote-warning-Large-files-detected/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/15/Git-关于git上传文件过大报错的问题-remote-warning-Large-files-detected/" itemprop="url">
                  [Git]关于git上传文件过大报错的问题 remote: warning: Large files detected
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-15T11:34:16+08:00">
              2015-07-15
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/15/Git-关于git上传文件过大报错的问题-remote-warning-Large-files-detected/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/15/Git-关于git上传文件过大报错的问题-remote-warning-Large-files-detected/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天往git上传了个项目，没有注意有个500m的大家伙在里面，就一并commit+push了，然后噩梦就来了。<br>首先是报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">remote: warning: Large files detected.</div><div class="line"># remote: warning: File big_file is 55.00 MB; this is larger than GitHub&apos;s</div><div class="line">recommended maximum file size of 50 MB</div></pre></td></tr></table></figure>
<p>一看不就是文件过大报错了嘛，直接文件delete重新commit，没想到问题继续。。<br>然后又尝试重试新建一个小的同名文件继续commit，问题继续。。</p>
<p>后来找到github上的一个帮助页面 Working with large files，照着”Removing the local file added with the most recent unpushed commit”的步骤操作了一番，最终未遂。但我的问题应该是下面的关于“Removing the file added in an older commit”才能解决的（因为我已经提交并push了），可是教程里只写了通过git-filter-branch解决，但是命令不能用~</p>
<p>想到我的问题一定是这个大文件已经保存到了log中，因此无论我怎么删改，这个文件没有从log中剔除就总会报出相同的错误，最后又是在万能的StackOverflow上有人给出了解决方法，命令如下：</p>
<p>[plain] view plaincopy在CODE上查看代码片派生到我的代码片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git filter-branch -f --index-filter &quot;git rm -rf --cached --ignore-unmatch FOLDERNAME&quot; -- --all</div></pre></td></tr></table></figure>
<p>把你的文件或者文件夹位置替换掉那个FOLDERNAME就可以了。<br>转自：<a href="http://blog.csdn.net/memray/article/details/43154779" target="_blank" rel="external">http://blog.csdn.net/memray/article/details/43154779</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2015/07/13/iOS-Objective-C-Runtime中的并发内存分配/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/13/iOS-Objective-C-Runtime中的并发内存分配/" itemprop="url">
                  [iOS]Objective-C Runtime中的并发内存分配
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-13T15:29:52+08:00">
              2015-07-13
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/13/iOS-Objective-C-Runtime中的并发内存分配/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/13/iOS-Objective-C-Runtime中的并发内存分配/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文由翻译自mikeash的博客，原文：Concurrent Memory Deallocation in the Objective-C Runtime<br>译者：lynulzy（社区ID,博客） 校对：唧唧歪歪（博客）</p>
<p>Objective-C的Runtime机制是Mac和iOS程序中的核心，而objc_msgSend函数是Runtime的核心，进言之，这个函数的核心正是方法缓存。今天将代领大家探索苹果是如何以一种线程安全且不影响程序性能的方式来调整和分配方法缓存所用内存的，其所用的技术也许是在其他关于线程安全的资料中从未使用的。<br>消息转发的概念</p>
<p>Objc_msgSend方法的工作方式是为发送过来的方法查找恰当的方法实现，并且跳转到该实现中的方式工作。用官方的说法来讲，查找方法的过程是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">IMP lookUp(<span class="keyword">id</span> obj, SEL selector) &#123;</div><div class="line">    Class c = object_getClass(obj);</div><div class="line">    <span class="keyword">while</span>(c) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c-&gt;numMethods; i++) &#123;</div><div class="line">            Method m = c-&gt;methods[i];</div><div class="line">            <span class="keyword">if</span>(m.selector == selector) &#123;</div><div class="line">                <span class="keyword">return</span> m.imp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        c = c-&gt;superclass;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _objc_msgForward;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>【注】代码中的一些变量名已经替换，如果你对原始代码有兴趣可以去下载一份Objective-C runtime的<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="external">源码</a></p>
<p>##方法缓存</p>
<p>在Objective-C的程序中，消息发送随处可见，如果对每一条消息都执行完整的消息搜索，那将会使程序变得异常迟钝。</p>
<p>解决方法就是缓存，每一个类都拥有一个哈希表与之关联,这个哈希表将选择器映射到方法实现。使用哈希表的初衷正是为了最大限度的提高读取速度，同时 objc_msgSend 使用了极其细致且高效的汇编源码来快速执行哈希表的检索，这使得在缓存模式下的消息发送仅维持在一个个位数的纳秒量级上。当然，任何消息在第一次使用的时候很慢，以后将会非常快。</p>
<p>我们提到的缓存，是用来提高多次读取最近使用资源的速度的，它通常也是有大小限制的。例如，你可能会缓存从网络上加载的图片，这样连续2次读取图片就不会请求网络2次了。但是，你又不想使用太多内存，所以你可能会给缓存图片的数量设置一个最大值，当达到最大值，且又有新的图片进来时，就可以把最旧的图片删掉。</p>
<p>在大多数情况下这是一种很好的解决方案，但是在一些隐蔽的情况下可能会有较差的表现。举个例子，如果你把图片缓存个数设置为40个，但是应用却以41张一组这样的规模循环图片的话，你会忽然发现你的缓存策略失效了。</p>
<p>对于我们自己的应用，我们可以测试和调整缓存的大小以避免这种情况发生，但是Objective-C的Runtime机制并没有这种条件。因为方法缓存对于性能极其严苛，并且每个条目都相对较小。runtime并不会强制的限制缓存区的大小，相反，它会在需要的时候扩充缓存区以保存所有已经被发送的消息。</p>
<p>请注意，缓存有时候会刷新；有一些操作会造成缓存数据过期，如在处理过程中加载入更多的代码，或者改变一个类的方法列表，恰当的缓存区会被销毁并且允许再次填充的。</p>
<p>改变缓存大小、分配内存以及线程问题</p>
<p>在概念上，改变缓存的大小简单，就像这样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bucket_t *newCache = malloc(newSize);</div><div class="line">copyEntries(newCache, <span class="keyword">class</span>-&gt;cache);</div><div class="line">free(<span class="keyword">class</span>-&gt;cache);</div><div class="line"><span class="keyword">class</span>-&gt;cache = newCache;</div></pre></td></tr></table></figure>
<p>Objective-C runtime 实际上在这里采用了一些捷径，但是不会将旧的条目拷贝到新的缓存区！毕竟它仅仅是缓存而已，没有必要保存数据，这些条目将在消息发送的时候再次被填充，所以，真实情况是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">free(<span class="keyword">class</span>-&gt;cache);</div><div class="line"><span class="keyword">class</span>-&gt;cache = malloc(newSize);</div></pre></td></tr></table></figure>
<p>在单线程环境下，你需要做的仅有这些，那么这篇文章也本该很短。当然Objective - C runtime也必须要支持多线程，也就是说所有这些代码都必须是线程安全的。任何给出的类的缓存，都可以从多个线程中被同时访问，所以这些代码必须考虑周全，确保可以应付这种场景。</p>
<p>写到这里的代码是无法处理多线程的情况的。在<code>释放旧的缓存到分配新的缓存之前</code>这段时间内，其他线程也许会访问这些已经失效的缓存指针，这会造成它使用的数据是垃圾数据，或者由于指定的内存并未映像物理地址出而立刻崩溃。</p>
<p>我们该如何解决这种问题？典型的保存共享数据的一种方法是加锁，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lock(<span class="keyword">class</span>-&gt;lock);</div><div class="line">free(<span class="keyword">class</span>-&gt;cache);</div><div class="line"><span class="keyword">class</span>-&gt;cache = malloc(newSize);</div><div class="line">unlock(<span class="keyword">class</span>-&gt;lock);</div></pre></td></tr></table></figure>
<p>为此，包括读取在内的所有访问都会被这个锁控制。也就是说 <em>Objc_msgSend</em> 方法需要获得这个锁，查找缓存，然后放锁。每次进行加锁，解锁操作都会增加许多开销，考虑到缓存每次对自己的检索只需要几纳秒时间，这对性能的影响太大了。</p>
<p>我们也许会尝试通过一些其他方式关闭这个时间窗口（<em>释放旧缓存到分配新缓存这个时间窗</em>）。例如，对缓存先分配地址并赋值，然后再去释放旧的缓存如何？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bucket_t *oldCache = <span class="keyword">class</span>-&gt;cache;</div><div class="line"><span class="keyword">class</span>-&gt;cache = malloc(newSize);</div><div class="line">free(oldCache);</div></pre></td></tr></table></figure>
<p>这会有一些帮助，但是并不能解决这个问题。另外一个线程也许会检索旧的缓存指针，然后在他可以访问内容之前通过系统先行占取这块缓存。这块旧的缓存在其他的线程再次运行之前被销毁，之前的问题再次出现。</p>
<p>如果加一个像这样的延迟呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bucket_t *oldCache = <span class="keyword">class</span>-&gt;cache;</div><div class="line"><span class="keyword">class</span>-&gt;cache = malloc(newSize);</div><div class="line">after(<span class="number">5</span> <span class="comment">/* seconds */</span>, ^&#123;</div><div class="line">    free(oldCache);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这几乎是可行的。但还是有下面的情况，一个线程刚好被系统抢占了缓存，并且被抢占的时间足够长，这样延迟5秒的释放就会先触发。这使得崩溃的可能微乎其微,但也不能完全保证不会发生。</p>
<p>不采用一个随机的延迟时间，一直等待到时间窗完全腾出来会怎么样呢？我们对Objc_msgSend加一个计数器：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gInMsgSend++;</div><div class="line">lookUpCache(<span class="keyword">class</span>-&gt;cache);</div><div class="line">gInMsgSend--;</div></pre></td></tr></table></figure>
<p>一个恰当的线程安全版本需要用到计数器的原子性，合适的内存<code>阻隔</code>来确保依赖加载/存储显示正常。本文的目的不是讨论这些，想象它们已经存在就好了。</p>
<p>在计数器的帮助下，缓存的再分配像是这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bucket_t *oldCache = <span class="keyword">class</span>-&gt;cache;</div><div class="line"><span class="keyword">class</span>-&gt;cache = malloc(newSize);</div><div class="line"><span class="keyword">while</span>(gInMsgSend)</div><div class="line">    ; <span class="comment">// spin</span></div><div class="line">free(oldCache);</div></pre></td></tr></table></figure>
<p>注意到这里没有必要阻塞执行objc_msgSend方法就可以正常工作。一旦释放缓存的代码确定在它替换了缓存指针之后，objc_msgSend中没有东西了，这段代码就会继续向下执行，释放旧的缓存区。其他线程可能会在旧的缓存区指针释放的时候调用 Objc_msgSend 方法，但是这个相对较新的调用将不能再使用旧的指针，因此这种条件下是线程安全的。</p>
<p>不断的循环是低效率且不够优美的。释放缓存并没有那么紧急。释放内存是好的，如果要花些时间也没什么问题。与其低效的循环，不如让我们保存一份未释放缓存列表，每次当缓存释放的时候会将所有等待中的操作全部执行完毕，上代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">bucket_t *oldCache = <span class="keyword">class</span>-&gt;cache;</div><div class="line"><span class="keyword">class</span>-&gt;cache = malloc(newSize);</div><div class="line">append(gOldCachesList, oldCache);</div><div class="line"><span class="keyword">if</span>(!gInMsgSend) &#123;</div><div class="line">    <span class="keyword">for</span>(cache <span class="keyword">in</span> gOldCachesList) &#123;</div><div class="line">       free(cache);</div><div class="line">    &#125;</div><div class="line">    gOldCachesList.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当一个新的发送消息在处理的过程中，这个操作不会立刻释放旧的缓存，但这并不是问题。当再次访问它、访问之后的时候、或者将来的某个时间点会被释放。</p>
<p>这个版本已经相当接近Objective-C Runtime机制的实际运行原理了。`</p>
<p>##零耗费标志</p>
<p>这两个交互的部分存在这极大的不对称。Objc_msgSend这边, 可能每秒会运行百万次，并且的确是需要尽可能地快。最好的情况是单次调用的运行时间只需要几纳秒。另一方面，改变缓存区的大小是一个较少的操作，并且随着app的持续运行将会变得越来越少。一旦应用达到了一种稳态，不在加载新的代码，或者编辑消息列表，并且缓存变得足够大而且能满足所需的时候，缓存块大小的重新计算操作将不会再发生。但在此之前，这个操作在缓存区增大到它所需的大小时或许会发生个几百或者几千次，但是与Objc_msgSend相比而言是极其小的，并且性能敏感性也更低。</p>
<p>由于这种不对称性，在消息发送方应该放尽可能少的任务，即使这会使缓存释放部分会变慢一些。在objc_msgSend的百万级别CPU循环中每削减一个CPU运行循环累积下带来的优势与释放操作是一个以巨大优势的净赢。</p>
<p>即使全局计数器花费太大。在objc_msgSend方法中的这两个附加的内存访问操作将仍然带来很大的开销。它们需要保持原子性并且使用内存隔离会使情况更糟。</p>
<p>幸运的是，Objective-C runtime机制有一个技术是以牺牲缓存释放的速度来将objc_msgSend的开销降为0。</p>
<p>假设全局计数器的目的在于追踪任何在一个特定代码区块内的线程。这些线程已经有已有一些来监测当前它们是在哪段代码中执行，它就是程序计数器（program counter）。这是一个CPU内部的寄存器，其功能在于记录当前指令的内存地址。与全局计数器相比，我们可以检查每个线程的程序计数器来确认他是否在执行objc_msgSend</p>
<p>。如果所有线程都没有执行objc_msgSend方法，那么对它而言，释放缓存就是安全的，代码实现如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> ThreadsInMsgSend(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">for</span>(thread <span class="keyword">in</span> GetAllThreads()) &#123;</div><div class="line">        uintptr_t pc = thread.GetPC();</div><div class="line">        <span class="keyword">if</span>(pc &gt;= objc_msgSend_startAddress &amp;&amp; pc cache;</div><div class="line"><span class="keyword">class</span>-&gt;cache = malloc(newSize);</div><div class="line">append(gOldCachesList, oldCache);</div><div class="line"><span class="keyword">if</span>(!ThreadsInMsgSend()) &#123;</div><div class="line">    <span class="keyword">for</span>(cache <span class="keyword">in</span> gOldCachesList) &#123;</div><div class="line">        free(cache);</div><div class="line">    &#125;</div><div class="line">    gOldCachesList.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，objc_msgSend不必做任何其他的事情。它可以直接访问缓存区，而不用给读取加个标志，就像下面这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lookUpCache(<span class="keyword">class</span>-&gt;cache);</div></pre></td></tr></table></figure>
<p>由于缓存释放需要检查进程中的每个线程的状态，因此它是相对低效的。但是如果objc_msgSend只用考虑单线程的环境下，它的执行效率将会非常高。这值得做出权衡。这基本上就是苹果的Runtime机制如何工作的。</p>
<p>##实际的代码</p>
<p>到底苹果如何实现上述的技术可以在runtime的实现文件[objc-cache.mm]文件中的函数 _collection_in_critical 中找到。</p>
<p>关键的PC位置存储在全局变量中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT uintptr_t objc_entryPoints[];</div><div class="line">OBJC_EXPORT uintptr_t objc_exitPoints[];</div></pre></td></tr></table></figure>
<p>实际上objc_msgSend有多种实现（比如返回结构体版本的），并且内部的cache_getImp 函数也会直接访问缓存。这些都需要被检查，以确保释放缓存的安全性。</p>
<p>函数本身不需要参数，返回值是 <strong>int</strong>类型的，使用起来就像一个标志位一样，用来标识在一个关键函数中是否有多个线程：</p>
<p>为了专注于更好的代码，我将会略过这个函数中一些无聊的代码。如果你想看全部的代码，在<a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-cache.mm" target="_blank" rel="external">这里</a>可以找到。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> _collectiong_in_critical(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//获得线程信息的API位于mach层面。task_threads 获得了给定任务中所有线程的线程列表，并且这些代码使用它来获得其所在进程中的其他线程。</span></div><div class="line"></div><div class="line">    ret = task_threads(mach_task_self(), &amp;threads, &amp;number);</div><div class="line"></div><div class="line"><span class="comment">//它返回了一组包含了多个thread_t值的threads数组，并且可以获得数组元素的个数，然后它会遍历这些元素</span></div><div class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; number; count++)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//取得一个线程的PC的操作在另外一个独立的函数中，我们可以简单看下：</span></div><div class="line">        pc = _get_pc_for_thread (threads[count]);</div><div class="line"></div><div class="line">        <span class="comment">//然后遍历这些入口和出口，然后比较各个元素</span></div><div class="line">        <span class="keyword">for</span> (region = <span class="number">0</span>; objc_entryPoints[region] != <span class="number">0</span>; region++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> ((pc &gt;= objc_entryPoints[region]) &amp;&amp;</div><div class="line">                (pc &lt;= objc_exitPoints[region]))</div><div class="line">            &#123;</div><div class="line">                result = <span class="literal">TRUE</span>;</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//在循环结束后向调用者返回结果</span></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>_get_pc_for_thread这个函数如工作？这是相对简单代码，它通过调用thread_get_state方法来获得目标线程的寄存器状态。它位于一个独立的函数中的主要原因是寄存器状态的结构是特定于系统架构的，因为每个架构下有着不同的寄存器。这就意味着这个函数对于每种支持的架构需要一个独立的实现，尽管每种实现都几乎是一样的。这里有一个关于x86-64架构下的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> uintptr_t _get_pc_for_thread(thread_t thread)</div><div class="line">&#123;</div><div class="line">    x86_thread_state64_t            state;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = x86_THREAD_STATE64_COUNT;</div><div class="line">    kern_return_t okay = thread_get_state (thread, x86_THREAD_STATE64, (thread_state_t)&amp;state, &amp;count);</div><div class="line">    <span class="keyword">return</span> (okay == KERN_SUCCESS) ? state.__rip : PC_SENTINEL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到<code>rip</code>是PC在x86-64架构下的名字，其中R代表”register”,IP代表”instruction pointer”;</p>
<p>入口点和出口点他们本身是在一个汇编语言文件中定义的，这个文件中同时还包含了问题中的一些其他函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">.private_extern _objc_entryPoints</div><div class="line">_objc_entryPoints:</div><div class="line">    .quad   _cache_getImp</div><div class="line">    .quad   _objc_msgSend</div><div class="line">    .quad   _objc_msgSend_fpret</div><div class="line">    .quad   _objc_msgSend_fp2ret</div><div class="line">    .quad   _objc_msgSend_stret</div><div class="line">    .quad   _objc_msgSendSuper</div><div class="line">    .quad   _objc_msgSendSuper_stret</div><div class="line">    .quad   _objc_msgSendSuper2</div><div class="line">    .quad   _objc_msgSendSuper2_stret</div><div class="line">    .quad   0</div><div class="line">.private_extern _objc_exitPoints</div><div class="line">_objc_exitPoints:</div><div class="line">    .quad   LExit_cache_getImp</div><div class="line">    .quad   LExit_objc_msgSend</div><div class="line">    .quad   LExit_objc_msgSend_fpret</div><div class="line">    .quad   LExit_objc_msgSend_fp2ret</div><div class="line">    .quad   LExit_objc_msgSend_stret</div><div class="line">    .quad   LExit_objc_msgSendSuper</div><div class="line">    .quad   LExit_objc_msgSendSuper_stret</div><div class="line">    .quad   LExit_objc_msgSendSuper2</div><div class="line">    .quad   LExit_objc_msgSendSuper2_stret</div><div class="line">    .quad   0</div></pre></td></tr></table></figure>
<p>_collecting_in_critical 与我们上面假设的例子中的用法相似。它在释放残留的内存垃圾之前调用。runtime实际上有两种独立的模式：一种是留下垃圾知道下次再有其他线程进入临界函数。另一个是不断的循环直到清除干净，而且通常会同时释放这些垃圾内存。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Synchronize collection with objc_msgSend and other cache readers</span></div><div class="line"><span class="keyword">if</span> (!collectALot) &#123;</div><div class="line">    <span class="keyword">if</span> (_collecting_in_critical ()) &#123;</div><div class="line">        <span class="comment">// objc_msgSend (or other cache reader) is currently looking in</span></div><div class="line">        <span class="comment">// the cache and might still be using some garbage.</span></div><div class="line">        <span class="keyword">if</span> (PrintCaches) &#123;</div><div class="line">            _objc_inform (<span class="string">"CACHES: not collecting; "</span></div><div class="line">                          <span class="string">"objc_msgSend in progress"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// No excuses.</span></div><div class="line">    <span class="keyword">while</span> (_collecting_in_critical()) </div><div class="line">        ;</div><div class="line">&#125;</div><div class="line"><span class="comment">// free garbage here</span></div></pre></td></tr></table></figure>
<p>第一种留下垃圾的模式是用于普通的缓存区重新计算的。通常会释放垃圾的循环的模式用于runtime的清除所有类的所有缓存,这很显然会产生喝多垃圾。通过对代码的分析，这仅会在打印所有调试信息的调试设备这种情况下才会发生。它会清除缓存，正是于消息缓存会干涉日志输出。</p>
<p>##结论</p>
<p>性能和线程安全是一个矛盾体。不同的代码快访问共享数据要求更高的线程安全性这也是不平衡的。一个全局的标志或者计数器是一种利用这种特点的一种方法。在Objective-C的runtime机制中，苹果采用了比这种策略更深层次的方法，它通过使用每个线程的程序计数器（PC）隐式的表明了什么时候一个线程正在执行一种不安全的操作。这是一个特例，并且其他地方很难看到这种方法的用武之地，但它本身很奇妙。</p>
<p>转自: <a href="http://www.cocoachina.com/ios/20150706/12417.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150706/12417.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2015/07/10/-iOS-JSPatch实现原理详解：让JS调用-替换任意OC方法/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/10/-iOS-JSPatch实现原理详解：让JS调用-替换任意OC方法/" itemprop="url">
                  [iOS]JSPatch实现原理详解：让JS调用/替换任意OC方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-10T14:58:47+08:00">
              2015-07-10
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/10/-iOS-JSPatch实现原理详解：让JS调用-替换任意OC方法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/10/-iOS-JSPatch实现原理详解：让JS调用-替换任意OC方法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/meinv.jpg" rel="gallery_cixjz0myv008n5ntiju5zpgzn"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/meinv.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <p><a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">JSPatch</a>以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力，在实现 JSPatch 过程中遇到过很多困难也踩过很多坑，有些还是挺值得分享的。本篇文章从基础原理、方法调用和方法替换三块内容介绍整个 JSPatch 的实现原理，并把实现过程中的想法和碰到的坑也尽可能记录下来。</p>
<p>##基础原理</p>
<p>能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class <span class="keyword">class</span> = <span class="built_in">NSClassFromString</span>(<span class="string">"UIViewController"</span>);</div><div class="line"><span class="keyword">id</span> viewController = [[<span class="keyword">class</span> alloc] init];</div><div class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">"viewDidLoad"</span>);</div><div class="line">[viewController performSelector:selector];</div></pre></td></tr></table></figure>
<p>也可以替换某个类的方法为新的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> newViewDidLoad(<span class="keyword">id</span> slf, SEL sel) &#123;&#125;</div><div class="line">class_replaceMethod(<span class="keyword">class</span>, selector, newViewDidLoad, <span class="string">@""</span>);</div></pre></td></tr></table></figure>
<p>还可以新注册一个类，为类添加方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class cls = objc_allocateClassPair(superCls, <span class="string">"JPObject"</span>, <span class="number">0</span>);</div><div class="line">objc_registerClassPair(cls);</div><div class="line">class_addMethod(cls, selector, implement, typedesc);</div></pre></td></tr></table></figure>
<p>对于 Objective-C 对象模型和动态消息发送的原理已有很多文章阐述得很详细，例如<a href="http://blog.csdn.net/kesalin/article/details/6689226" target="_blank" rel="external">这篇</a>，这里就不详细阐述了。理论上你可以在运行时通过类名/方法名调用到任何OC方法，替换任何类的实现以及新增任意类。所以 JSPatch 的原理就是：JS传递字符串给OC，OC通过 Runtime 接口调用和替换OC方法。这是最基础的原理，实际实现过程还有很多怪要打，接下来看看具体是怎样实现的。</p>
<p>##方法调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'UIView'</span>)</div><div class="line"><span class="keyword">var</span> view = UIView.alloc().init()</div><div class="line">view.setBackgroundColor(<span class="built_in">require</span>(<span class="string">'UIColor'</span>).grayColor())</div><div class="line">view.setAlpha(<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<p>引入JSPatch后，可以通过以上JS代码创建了一个 UIView 实例，并设置背景颜色和透明度，涵盖了require引入类，JS调用接口，消息传递，对象持有和转换，参数转换这五个方面，接下来逐一看看具体实现。</p>
<p>###1.require</p>
<p>调用 <code>require(‘UIView’)</code>后，就可以直接使用 UIView 这个变量去调用相应的类方法了，require 做的事很简单，就是在JS全局作用域上创建一个同名变量，变量指向一个对象，对象属性<code>__isCls</code>表明这是一个 Class，<code>__clsName</code>保存类名，在调用方法时会用到这两个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _require = <span class="function"><span class="keyword">function</span>(<span class="params">clsName</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!global[clsName]) &#123;</div><div class="line">    global[clsName] = &#123;</div><div class="line">      <span class="attr">__isCls</span>: <span class="number">1</span>,</div><div class="line">      <span class="attr">__clsName</span>: clsName</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> global[clsName]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以调用<code>require(‘UIView’)</code>后，就在全局作用域生成了 UIView 这个变量，指向一个这样一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">__isCls</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">__clsName</span>: <span class="string">"UIView"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###2.JS接口</p>
<p>接下来看看<code>UIView.alloc()</code>是怎样调用的。</p>
<p>旧实现</p>
<p>对于这个调用的实现，一开始我的想法是，根据JS特性，若要让 UIView.alloc() 这句调用不出错，唯一的方法就是给 UIView 这个对象添加 alloc 方法，不然是不可能调用成功的，JS对于调用没定义的属性/变量，只会马上抛出异常，而不像OC/Lua/ruby那样会有转发机制。所以做了一个复杂的事，就是在require生成类对象时，把类名传入OC，OC通过 Runtime 方法找出这个类所有的方法返回给JS，JS类对象为每个方法名都生成一个函数，函数内容就是拿着方法名去OC调用相应方法。生成的 UIView 对象大致是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">    <span class="attr">__isCls</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">__clsName</span>: <span class="string">"UIView"</span>,</div><div class="line">    <span class="attr">alloc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;…&#125;,</div><div class="line">    <span class="attr">beginAnimations_context</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;…&#125;,</div><div class="line">    <span class="attr">setAnimationsEnabled</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;…&#125;,</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上不仅要遍历当前类的所有方法，还要循环找父类的方法直到顶层，整个继承链上的所有方法都要加到JS对象上，一个类就有几百个方法，这样把方法全部加到JS对象上，碰到了挺严重的问题，引入几个类就内存暴涨，无法使用。后来为了优化内存问题还在JS搞了继承关系，不把继承链上所有方法都添加到一个JS对象，避免像基类 NSObject 的几百个方法反复添加在每个JS对象上，每个方法只存在一份，JS对象复制了OC对象的继承关系，找方法时沿着继承链往上找，结果内存消耗是小了一些，但还是大到难以接受。</p>
<p>新实现</p>
<p>当时继续苦苦寻找解决方案，若按JS语法，这是唯一的方法，但若不按JS语法呢？突然脑洞开了下，CoffieScript/JSX都可以用JS实现一个解释器实现自己的语法，我也可以通过类似的方式做到，再进一步想到其实我想要的效果很简单，就是调用一个不存在方法时，能转发到一个指定函数去执行，就能解决一切问题了，这其实可以用简单的字符串替换，把JS脚本里的方法调用都替换掉。最后的解决方案是，在OC执行JS脚本前，通过正则把所有方法调用都改成调用 __c() 函数，再执行这个JS脚本，做到了类似OC/Lua/Ruby等的消息转发机制：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIView.alloc().init()</div><div class="line">-&gt;</div><div class="line">UIView.__c('alloc')().__c('init')()</div></pre></td></tr></table></figure>
<p>给JS对象基类 Object 的 prototype 加上 <strong>c 成员，这样所有对象都可以调用到 </strong>c，根据当前对象类型判断进行不同操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.__c = <span class="function"><span class="keyword">function</span>(<span class="params">methodName</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.__obj &amp;&amp; !<span class="keyword">this</span>.__clsName) <span class="keyword">return</span> <span class="keyword">this</span>[methodName].bind(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</div><div class="line">    <span class="keyword">return</span> _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>_methodFunc() 就是把相关信息传给OC，OC用 Runtime 接口调用相应方法，返回结果值，这个调用就结束了。</p>
<p>这样做不用去OC遍历对象方法，不用在JS对象保存这些方法，内存消耗直降99%，这一步是做这个项目最爽的时候，用一个非常简单的方法解决了严重的问题，替换之前又复杂效果又差的实现。</p>
<p>###3.消息传递</p>
<p>解决了JS接口问题，接下来看看JS和OC是怎样互传消息的。这里用到了 JavaScriptCore 的接口，OC端在启动JSPatch引擎时会创建一个 JSContext 实例，JSContext 是JS代码的执行环境，可以给 JSContext 添加方法，JS就可以直接调用这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">context[<span class="string">@"hello"</span>] = ^(<span class="built_in">NSString</span> *msg) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hello %@"</span>, msg);</div><div class="line">&#125;;</div><div class="line">[_context evaluateScript:<span class="string">@"hello('word')"</span>];     <span class="comment">//output hello word</span></div></pre></td></tr></table></figure>
<p>JS通过调用 JSContext 定义的方法把数据传给OC，OC通过返回值传会给JS。调用这种方法，它的参数/返回值 JavaScriptCore 都会自动转换，OC里的 NSArray, NSDictionary, NSString, NSNumber, NSBlock 会分别转为JS端的数组/对象/字符串/数字/函数类型。上述 _methodFunc() 方法就是这样把要调用的类名和方法名传递给OC的。</p>
<p>###4.对象持有/转换</p>
<p>UIView.alloc() 通过上述消息传递后会到OC执行 [UIView alloc]，并返回一个UIView实例对象给JS，这个OC实例对象在JS是怎样表示的呢？怎样可以在JS拿到这个实例对象后可以直接调用它的实例方法 (UIView.alloc().init())？</p>
<p>对于一个自定义id对象，JavaScriptCore 会把这个自定义对象的指针传给JS，这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象生命周期的管理，按我的理解如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</p>
<p>传回给JS的变量是这个OC对象的指针，如果不经过任何处理，是无法通过这个变量去调用实例方法的。所以在返回对象时，JSPatch 会对这个对象进行封装。</p>
<p>首先，告诉JS这是一个OC对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *toJSObj(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"__isObj"</span>: @(<span class="literal">YES</span>), <span class="string">@"cls"</span>: <span class="built_in">NSStringFromClass</span>([obj <span class="keyword">class</span>]), <span class="string">@"obj"</span>: obj&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用__isObj表示这是一个OC对象，对象指针也一起返回。接着在JS端会把这个对象转为一个 JSClass 实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> JSClass</div><div class="line"><span class="keyword">var</span> _getJSClass = <span class="function"><span class="keyword">function</span>(<span class="params">className</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!JSClass) &#123;</div><div class="line">    JSClass = <span class="function"><span class="keyword">function</span>(<span class="params">obj, className, isSuper</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.__obj = obj</div><div class="line">        <span class="keyword">this</span>.__isSuper = isSuper</div><div class="line">        <span class="keyword">this</span>.__clsName = className</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> JSClass</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">var</span> _toJSObj = <span class="function"><span class="keyword">function</span>(<span class="params">meta</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> JSClass = _getJSClass()</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JSClass(meta[<span class="string">"obj"</span>], meta[<span class="string">"cls"</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JS端如果发现返回是一个OC对象，会传入 _toJSObj()，生成一个 JSClass 实例，这个实例保存着OC对象指针，类名等。这个实例就是OC对象在 JSPatch 对应的JS对象，生命周期是一样的。</p>
<p>回到我们第二点说的 JS接口， 这个 JSClass 实例对象同样有 <strong>c 函数，调用这个对象的方法时，同样走到 </strong>c 函数， __c 函数会把JSClass实例对象里的OC对象指针以及要调用的方法名和参数回传给OC，这样OC就可以调用这个对象的实例方法了。</p>
<p>接着看看对象是怎样回传给OC的。上述例子中，view.setBackgroundColor(require(‘UIColor’).grayColor())，这里生成了一个 UIColor 实例对象，并作为参数回传给OC。根据上面说的，这个 UIColor 实例在JS中的表示是一个 JSClass 实例，所以不能直接回传给OC，这里的参数实际上会在 <strong>c 函数进行处理，会把对象的 .</strong>obj 原指针回传给OC。</p>
<p>最后一点，OC对象可能会存在于 NSDictionary / NSArray 等容器里，所以需要遍历容器挑出OC对象进行格式化，OC需要把对象都替换成JS认得的格式，JS要把对象转成 JSClass 实例，JS实例回传给OC时需要把实例转为OC对象指针。所以OC流出数据时都会经过 formatOCObj() 方法处理，JS从OC得到数据时都会经过 _formatOCToJS() 处理，JS传参数给OC时会经过 _formatJSToOC() 处理，图示：</p>
<p><img src="/uploads/2015/07/10/1436325144537320.jpg" alt=""></p>
<p>###5.类型转换</p>
<p>JS把要调用的类名/方法名/对象传给OC后，OC调用类/对象相应的方法是通过 NSInvocation 实现，要能顺利调用到方法并取得返回值，要做两件事：</p>
<p>1.取得要调用的OC方法各参数类型，把JS传来的对象转为要求的类型进行调用。</p>
<p>2.根据返回值类型取出返回值，包装为对象传回给JS。</p>
<p>例如开头例子的<code>view.setAlpha(0.5)</code>， JS传递给OC的是一个 NSNumber，OC需要通过要调用OC方法的 NSMethodSignature 得知这里参数要的是一个 float 类型值，于是把NSNumber转为float值再作为参数进行OC方法调用。这里主要处理了 int/float/bool 等数值类型，并对 CGRect/CGRange 等类型进行了特殊转换处理，剩下的就是实现细节了。</p>
<p>##方法替换</p>
<p>JSPatch 可以用 defineClass 接口任意替换一个类的方法，方法替换的实现过程也是颇为曲折，一开始是用 va_list 的方式获取参数，结果发现 arm64 下不可用，只能转而用另一种hack方式绕道实现。另外在给类新增方法、实现property、支持self/super关键字上也费了些功夫，下面逐个说明。</p>
<p>基础原理</p>
<p>OC上，每个类都是这样一个结构体：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">  <span class="keyword">struct</span> objc_class * isa;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name; </div><div class="line">  ….</div><div class="line">  <span class="keyword">struct</span> objc_method_list **methodLists; <span class="comment">/*方法链表*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中 methodList 方法链表里存储的是Method类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ method &#123;</div><div class="line">  SEL method_name;</div><div class="line">  <span class="keyword">char</span> *method_types;</div><div class="line">  IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Method 保存了一个方法的全部信息，包括SEL方法名，type各参数和返回值类型，IMP该方法具体实现的函数指针。</p>
<p>通过 Selector 调用方法时，会从 methodList 链表里找到对应Method进行调用，这个 methodList 上的的元素是可以动态替换的，可以把某个 Selector 对应的函数指针IMP替换成新的，也可以拿到已有的某个 Selector 对应的函数指针IMP，让另一个 Selector 跟它对应，Runtime 提供了一些接口做这些事，以替换 UIViewController 的 -viewDidLoad: 方法为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> viewDidLoadIMP (<span class="keyword">id</span> slf, SEL sel) &#123;</div><div class="line">   JSValue *jsFunction = …;</div><div class="line">   [jsFunction callWithArguments:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">  </div><div class="line">Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIViewController"</span>);</div><div class="line">SEL selector = <span class="keyword">@selector</span>(viewDidLoad);</div><div class="line">Method method = class_getInstanceMethod(cls, selector);</div><div class="line">  </div><div class="line"><span class="comment">//获得viewDidLoad方法的函数指针</span></div><div class="line">IMP imp = method_getImplementation(method)</div><div class="line">  </div><div class="line"><span class="comment">//获得viewDidLoad方法的参数类型</span></div><div class="line"><span class="keyword">char</span> *typeDescription = (<span class="keyword">char</span> *)method_getTypeEncoding(method);</div><div class="line">  </div><div class="line"><span class="comment">//新增一个ORIGViewDidLoad方法，指向原来的viewDidLoad实现</span></div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(ORIGViewDidLoad), imp, typeDescription);</div><div class="line">  </div><div class="line"><span class="comment">//把viewDidLoad IMP指向自定义新的实现</span></div><div class="line">class_replaceMethod(cls, selector, viewDidLoadIMP, typeDescription);</div></pre></td></tr></table></figure>
<p>这样就把 UIViewController 的 -viewDidLoad 方法给替换成我们自定义的方法，APP里调用 UIViewController 的 viewDidLoad 方法都会去到上述 viewDidLoadIMP 函数里，在这个新的IMP函数里调用JS传进来的方法，就实现了替换 -viewDidLoad 方法为JS代码里的实现，同时为 UIViewController 新增了个方法 -ORIGViewDidLoad 指向原来 viewDidLoad 的IMP，JS可以通过这个方法调用到原来的实现。</p>
<p>方法替换就这样很简单的实现了，但这么简单的前提是，这个方法没有参数。如果这个方法有参数，怎样把参数值传给我们新的IMP函数呢？例如 UIViewController 的 -viewDidAppear: 方法，调用者会传一个Bool值，我们需要在自己实现的IMP（上述的viewDidLoadIMP）上拿到这个值，怎样能拿到？如果只是针对一个方法写IMP，是可以直接拿到这个参数值的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> viewDidAppear (<span class="keyword">id</span> slf, SEL sel, <span class="built_in">BOOL</span> animated) &#123;</div><div class="line">   [function callWithArguments:@(animated)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但我们要的是实现一个通用的IMP，任意方法任意参数都可以通过这个IMP中转，拿到方法的所有参数回调JS的实现。</p>
<p>va_list实现(32位)</p>
<p>最初我是用可变参数va_list实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> commonIMP(<span class="keyword">id</span> slf, ...)</div><div class="line">  va_list args;</div><div class="line">  va_start(args, slf);</div><div class="line">  <span class="built_in">NSMutableArray</span> *list = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">  <span class="built_in">NSMethodSignature</span> *methodSignature = [cls instanceMethodSignatureForSelector:selector];</div><div class="line">  <span class="built_in">NSUInteger</span> numberOfArguments = methodSignature.numberOfArguments;</div><div class="line">  <span class="keyword">id</span> obj;</div><div class="line">  <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">2</span>; i &lt; numberOfArguments; i++) &#123;</div><div class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *argumentType = [methodSignature getArgumentTypeAtIndex:i];</div><div class="line">      <span class="keyword">switch</span>(argumentType[<span class="number">0</span>]) &#123;</div><div class="line">          <span class="keyword">case</span> <span class="string">'i'</span>:</div><div class="line">              obj = @(va_arg(args, <span class="keyword">int</span>));</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> <span class="string">'B'</span>:</div><div class="line">              obj = @(va_arg(args, <span class="built_in">BOOL</span>));</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> <span class="string">'f'</span>:</div><div class="line">          <span class="keyword">case</span> <span class="string">'d'</span>:</div><div class="line">              obj = @(va_arg(args, <span class="keyword">double</span>));</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          …… <span class="comment">//其他数值类型</span></div><div class="line">          <span class="keyword">default</span>: &#123;</div><div class="line">              obj = va_arg(args, <span class="keyword">id</span>);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      [list addObject:obj];</div><div class="line">  &#125;</div><div class="line">  va_end(args);</div><div class="line">  [function callWithArguments:list];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样无论方法参数是什么，有多少个，都可以通过 va_list 的一组方法一个个取出来，组成NSArray在调用JS方法时传回。很完美地解决了参数的问题，一直运行正常，直到我跑在arm64的机子上测试，一调用就crash。查了资料，才发现arm64下 va_list 的结构改变了，导致无法上述这样取参数。<br>详情请参考<a href="https://blog.nelhage.com/2010/10/amd64-and-va_arg" target="_blank" rel="external">这篇文章</a>。</p>
<p>###ForwardInvocation实现(64位)</p>
<p>后来找到另一种非常hack的方法解决参数获取的问题，利用了OC消息转发机制。</p>
<p>当调用一个 NSObject 对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的 -resolveInstanceMethod:, -forwardingTargetForSelector:, -methodSignatureForSelector:, -forwardInvocation: 等方法，<a href="http://bugly.qq.com/blog/?p=64" target="_blank" rel="external">这篇文章</a>说得比较清楚，其中最后 -forwardInvocation: 是会有一个 NSInvocation 对象，这个 NSInvocation 对象保存了这个方法调用的所有信息，包括 Selector 名，参数和返回值类型，最重要的是有所有参数值，可以从这个 NSInvocation 对象里拿到调用的所有参数值。我们可以想办法让每个需要被JS替换的方法调用最后都调到 -forwardInvocation:，就可以解决无法拿到参数值的问题了。</p>
<p>具体实现，以替换 UIViewController 的 -viewWillAppear: 方法为例：</p>
<ol>
<li>把UIViewController的 -viewWillAppear: 方法通过 class_replaceMethod() 接口指向一个不存在的IMP: class_getMethodImplementation(cls, @selector(__JPNONImplementSelector))，这样调用这个方法时就会走到 -forwardInvocation:。</li>
<li>为 UIViewController 添加 -ORIGviewWillAppear: 和 -_JPviewWillAppear: 两个方法，前者指向原来的IMP实现，后者是新的实现，稍后会在这个实现里回调JS函数。</li>
<li>改写 UIViewController 的 -forwardInvocation: 方法为自定义实现。一旦OC里调用 UIViewController 的 -viewWillAppear: 方法，经过上面的处理会把这个调用转发到 -forwardInvocation: ，这时已经组装好了一个 NSInvocation，包含了这个调用的参数。在这里把参数从 NSInvocation 反解出来，带着参数调用上述新增加的方法 -JPviewWillAppear: ，在这个新方法里取到参数传给JS，调用JS的实现函数。整个调用过程就结束了，整个过程图示如下：</li>
</ol>
<p><img src="/uploads/2015/07/10/1436325132941056.jpg" alt=""></p>
<p>最后一个问题，我们把 UIViewController 的 -forwardInvocation: 方法的实现给替换掉了，如果程序里真有用到这个方法对消息进行转发，原来的逻辑怎么办？首先我们在替换 -forwardInvocation: 方法前会新建一个方法 -ORIGforwardInvocation:，保存原来的实现IMP，在新的 -forwardInvocation: 实现里做了个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调 -ORIGforwardInvocation: 走原来的流程。</p>
<p>实现过程中还碰到一个坑，就是从 -forwardInvocation: 里的 NSInvocation 对象取参数值时，若参数值是id类型，我们会这样取:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> arg;</div><div class="line">[invocation getArgument:&amp;arg atIndex:i];</div></pre></td></tr></table></figure>
<p>但这样取某些时候会导致莫名其妙的crash，而且不是crash在这个地方，似乎这里的指针取错导致后续的内存错乱，crash在各种地方，这个bug查了我半天才定位到这里，至今不知为什么。后来以这样的方式解决了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *arg;</div><div class="line">[invocation getArgument:&amp;arg atIndex:i];</div><div class="line"><span class="keyword">id</span> a = (__bridge <span class="keyword">id</span>)arg;</div></pre></td></tr></table></figure>
<p>其他就是实现上的细节了，例如需要根据不同的返回值类型生成不同的IMP，要在各处处理参数转换等。</p>
<p>###新增方法</p>
<p>在 JSPatch 刚开源时，是不支持为一个类新增方法的，因为觉得能替换原生方法就够了，新的方法纯粹添加在JS对象上，只在JS端跑就行了。另外OC为类新增方法需要知道各个参数和返回值的类型，需要在JS定一种方式把这些类型传给OC才能完成新增方法，比较麻烦。后来挺多人比较关注这个问题，不能新增方法导致 action-target 模式无法用，我也开始想有没有更好的方法实现添加方法。一开始想到，反正新增的方法都是JS在用，不如新增的方法返回值和参数全统一成id类型，这样就不用传类型了，但还是需要知道参数个数，后来跟Lancy聊天时找到了解决方案，JS可以获得函数参数个数，直接封装一下把参数个数一并传给OC就行了。</p>
<p>现在 defineClass 定义的方法会经过JS包装，变成一个包含参数个数和方法实体的数组传给OC，OC会判断如果方法已存在，就执行替换的操作，若不存在，就调用 class_addMethod() 新增一个方法，通过传过来的参数个数和方法实体生成新的 Method，把 Method 的参数和返回值类型都设为id。</p>
<p>这里有个问题，若某个类实现了某protocol，protocol方法里有可选的方法，它的参数不全是id类型，例如 UITableViewDataSource 的一个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView sectionForSectionIndexTitle:(<span class="built_in">NSString</span> *)title atIndex:(<span class="built_in">NSInteger</span>)index;</div></pre></td></tr></table></figure>
<p>若原类没有实现这个方法，在JS里实现了，会走到新增方法的逻辑，每个参数类型都变成id，与这个 protocol 方法不匹配，产生错误。后续会处理 protocol 的问题，若新增的方法是 protocol 实现的方法，会取这个方法的 NSMethodSignature 获得正确的参数类型进行添加。</p>
<p>###Property实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">defineClass(<span class="string">'JPTableViewController : UITableViewController'</span>, &#123;</div><div class="line">  <span class="attr">dataSource</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = self.getProp(<span class="string">'data'</span>)</div><div class="line">    <span class="keyword">if</span> (data) <span class="keyword">return</span> data;</div><div class="line">    data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">    self.setProp_forKey(data, <span class="string">'data'</span>)</div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JSPatch 可以通过 -getProp:， -setProp:forKey: 这两个方法给对象添加成员变量。实现上用了运行时关联接口 objc_getAssociatedObject() 和 objc_setAssociatedObject() 模拟，相当于把一个对象跟当前对象 self 关联起来，以后可以通过当前对象 self 找到这个对象，跟成员的效果一样，只是一定得是id对象类型。</p>
<p>本来OC有 class_addIvar() 可以为类添加成员，但必须在类注册之前添加完，注册完成后无法添加，这意味着可以为在JS新增的类添加成员，但不能为OC上已存在的类添加，所以只能用上述方法模拟。</p>
<p>###self关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">defineClass(<span class="string">"JPViewController: UIViewController"</span>, &#123;</div><div class="line">  <span class="attr">viewDidLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> view = self.view()</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JSPatch支持直接在 defineClass 里的实例方法里直接使用 self 关键字，跟OC一样 self 是指当前对象，这个 self 关键字是怎样实现的呢？实际上这个self是个全局变量，在 defineClass 里对实例方法 方法进行了包装，在调用实例方法之前，会把全局变量 self 设为当前对象，调用完后设回空，就可以在执行实例方法的过程中使用 self 变量了。这是一个小小的trick。</p>
<p>###super关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">defineClass(<span class="string">"JPViewController: UIViewController"</span>, &#123;</div><div class="line">  <span class="attr">viewDidLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    self.super.viewDidLoad()</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OC里 super 是一个关键字，无法通过动态方法拿到 super，那么 JSPatch 的super是怎么实现的？实际上调用 super 的方法，OC做的事是调用父类的某个方法，并把当前对象当成 self 传入父类方法，我们只要模拟它这个过程就行了。</p>
<p>首先JS端需要告诉OC想调用的是当前对象的 super 方法，做法是调用 self.super时，会返回一个新的 JSClass 实例，这个实例同样保存了OC对象的引用，同时标识 __isSuper=1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">JSClass = <span class="function"><span class="keyword">function</span>(<span class="params">obj, className, isSuper</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.__obj = obj</div><div class="line">    <span class="keyword">this</span>.__isSuper = isSuper</div><div class="line">    <span class="keyword">this</span>.__clsName = className</div><div class="line">&#125;</div><div class="line">JSClass.prototype.__defineGetter__(<span class="string">'super'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.__super) &#123;</div><div class="line">    <span class="keyword">this</span>.__super = <span class="keyword">new</span> JSClass(<span class="keyword">this</span>.__obj, <span class="keyword">this</span>.__clsName, <span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.__super</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>调用方法时，__isSuper 会传给OC，告诉OC要调 super 的方法。OC做的事情是，如果是调用 super 方法，找到 superClass 这个方法的IMP实现，为当前类新增一个方法指向 super 的IMP实现，那么调用这个类的新方法就相当于调用 super 方法。把要调用的方法替换成这个新方法，就完成 super 方法的调用了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> callSelector(<span class="built_in">NSString</span> *className, <span class="built_in">NSString</span> *selectorName, <span class="built_in">NSArray</span> *arguments, <span class="keyword">id</span> instance, <span class="built_in">BOOL</span> isSuper) &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (isSuper) &#123;</div><div class="line">        <span class="built_in">NSString</span> *superSelectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"SUPER_%@"</span>, selectorName];</div><div class="line">        SEL superSelector = <span class="built_in">NSSelectorFromString</span>(superSelectorName);</div><div class="line">         </div><div class="line">        Class superCls = [cls superclass];</div><div class="line">        Method superMethod = class_getInstanceMethod(superCls, selector);</div><div class="line">        IMP superIMP = method_getImplementation(superMethod);</div><div class="line">         </div><div class="line">        class_addMethod(cls, superSelector, superIMP, method_getTypeEncoding(superMethod));</div><div class="line">        selector = superSelector;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##总结</p>
<p>整个 JSPatch 实现原理就大致描述完了，剩下的一些小点，例如GCD接口，block实现，方法名下划线处理等就不细说了，可以直接看代码。JSPatch 还在持续改进中，希望能成为iOS平台动态更新的最佳解决方案，欢迎大家一起建设这个项目，github地址： <a href="https://github.com/bang590/JSPatc" target="_blank" rel="external">https://github.com/bang590/JSPatc</a></p>
<p>版权声明：本文章在微信公众平台的发表权，已「独家代理」给指定公众帐号：iOS开发(iOSDevTips)。<br>转自：<a href="http://www.cocoachina.com/ios/20150710/12467.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150710/12467.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2015/04/29/-iOS-WatchKit简明教程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/29/-iOS-WatchKit简明教程/" itemprop="url">
                  [iOS]WatchKit简明教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-04-29T16:24:49+08:00">
              2015-04-29
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/29/-iOS-WatchKit简明教程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/29/-iOS-WatchKit简明教程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/meinv.jpg" rel="gallery_cixjz0myu008k5ntin2nktkx7"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/meinv.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <p>##开始<br>首先，需要下载源程序<a href="/uploads/2015/04/29/BitWatch-Starter-s2.zip">BitWatch-Starter-s2</a>。注意，这个必须要用XCode 6.3以及以上版本运行。</p>
<p>打开程序，编译运行，如下图所示：<br><img src="/uploads/2015/04/29/watch-bitcoinbillionaire-281x500.png" alt=""></p>
<p>定位到<code>File\New\Target...</code>，然后选择<code>iOS\Apple Watch\Watch App</code>模板。<br><img src="/uploads/2015/04/29/watch-target-700x413.png" alt=""></p>
<p>Watch程序会跟随主iOS App，而且会建立一个单独的目标程序，点击<code>Next</code>继续。<br>在下一个页面，Xcode会自动填写信息，并且你无法改动程序的名字。<br><img src="/uploads/2015/04/29/watch-targetoptions-700x407.png" alt=""></p>
<p>确保选择的语言室Swift，<code>Include Notification Scene</code>和<code>Include Glance Scene</code>都没有被选中。点击<code>Finish</code>，Xcode会生成一个目标工程。工程的目录如下图所示：<br><img src="/uploads/2015/04/29/watch-groups.png" alt=""></p>
<ol>
<li><code>Watch App</code>包含了storyboard和图片文件，没有代码，你可以将这个看做程序的View。</li>
<li><code>WatchKit Extension</code>包含了可执行的代码，它会控制上面程序中的View。</li>
</ol>
<p><img src="/uploads/2015/04/29/WatchKit_03.jpg" alt=""></p>
<blockquote>
<p>与iOS程序不同的是，iOS的程序包括了View，Control和controllers，WatchKit包含的是Inerfaces, Interfact Objects和Interface Controllers.</p>
</blockquote>
<p>##Watch Interface<br>当设计Watch App的时候，需要用到storyboard和interface Builder。打开<code>BitWatch Watch App</code>选中<code>Interface.storyboard</code>。<br><img src="/uploads/2015/04/29/watch-storyboard1.png" alt=""></p>
<p>你会看到一个空的Interface Controller。现在往里面添加一个Label和一个Button，如下图所示：<br><img src="/uploads/2015/04/29/watch-storyboard2.png" alt=""></p>
<p>##Actions和OUtlets<br>苹果已经负责把Watch和主App之间的无线交流链接起来了。接下来需要添加相应的接口，打开<code>InterfaceController.swift</code>，按住Control+Drag，将label拖拽到InterfaceController，并且命名为<code>priceLabel</code>，点击<code>Connect</code>。<br><img src="/uploads/2015/04/29/watch-outlet.png" alt=""></p>
<p>##添加WatchKit代码<br>这个初始的工程里面，有一个叫做BitWatchKit的framework，它包含了一些去网站下载比特币价格的代码。现在需要将这个framework添加到工程里面。</p>
<p>打开导航，选择<code>BitWatch WatchKit Extension</code>，选中<code>Gnenral</code>选项卡，然后翻到<code>Linked Framewoks and Libraries</code>。<br><img src="/uploads/2015/04/29/watch-extension-700x248.png" alt=""></p>
<p>点击<code>+</code>按钮，你可以看到能够添加到工程里的framework，选择<code>BitWatchKit.framework</code>，然后点击<code>Add</code>。<br><img src="/uploads/2015/04/29/watch-framework.png" alt=""></p>
<p>现在切换到<code>WatchKit Extension</code>下面的<code>InterfaceController.swift</code>。添加如下代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> BitWatchKit</div></pre></td></tr></table></figure></p>
<p>这段代码允许你访问framework里面的Tracker类。接下来再类的定义中添加如下代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> tracker = <span class="type">Tracker</span>()</div><div class="line"><span class="keyword">var</span> updating = <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">updatePrice</span><span class="params">(price: NSNumber)</span></span> &#123;</div><div class="line">  priceLabel.setText(<span class="type">Tracker</span>.priceFormatter.stringFromNumber(price))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">if</span> !updating &#123;</div><div class="line">    updating = <span class="literal">true</span></div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> originalPrice = tracker.cachedPrice()</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    tracker.requestPrice &#123; (price, error) -&gt; () <span class="keyword">in</span></div><div class="line">      <span class="comment">// 4</span></div><div class="line">      <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">self</span>.updatePrice(price!)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">self</span>.updating = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码所做的工作是：</p>
<ol>
<li>先检测下是否正在更新中。</li>
<li>临时保存当前的价格。</li>
<li><code>requestPrice()</code>是在<code>Tracker</code>里面定义的一个方法，是用来获取最新的比特币价格。</li>
<li>如果请求成功了，会返回到闭包函数里面更新UI。</li>
</ol>
<p>##Interface生命周期<br>用户第一次可以在<code>awakeWithContext(_:)</code>函数里面初始化控件，在此时，整个的interface会导入到程序中，outlets也会进行初始化。也就意味着，可以在这个时候，初始化程序所需要的数据。但此时，interface还没有准好显示在屏幕上。</p>
<p>此时你可以添加一部分代价很高的代码，比如在<code>awakeWithContext:</code>里面添加如下代码，<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">updatePrice(tracker.cachedPrice())</div></pre></td></tr></table></figure></p>
<p>接下来，在<code>willActive()</code>里面添加<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update()</div></pre></td></tr></table></figure></p>
<p><code>willActive()</code>与iOS里面的<code>viewWillAppear</code>相似，表示interface快要被激活并显示在watch上。在这个地方用来更新数据是比较好的，所以调用<code>update()</code>，它会发一个网络请求。最终，在<code>refreshTapped</code>中添加<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update()</div></pre></td></tr></table></figure></p>
<p>##测试你的App<br>为了测试你的程序，需要启用Watch作为<code>external display</code>。在菜单中选择<code>Hardware\External Displays</code>并选中Apple Watch。<br><img src="/uploads/2015/04/29/watch-simulator.png" alt=""></p>
<p>然后回到Xcode，选择<code>BitWatch Watch App</code>，然后选中<code>iPhone6</code>模拟器。<br><img src="/uploads/2015/04/29/watch-scheme.png" alt=""></p>
<p>运行程序，然后切换到模拟器，你可以看到比特币的信息已经现在在Watch的模拟器上了。<br><img src="/uploads/2015/04/29/watch-app1.png" alt=""></p>
<p>##更多Interface<br>接下来，我们再来添加2个功能：</p>
<ul>
<li>最近更新时间</li>
<li>一个向上/向下的图片，表示价格上升还是下降</li>
</ul>
<p>首先，需要将2个图片添加到工程里面，打开<code>BitWatch Watch App</code>组底下的<code>Images.xcassets</code>。初始的工程里面已经包含了2个图片文件：Down@2x.png 和 Up@2x.png。在Finder窗口中，将2个文件拖拽到里面，<br><img src="/uploads/2015/04/29/watch-assets-700x491.png" alt=""></p>
<blockquote>
<p>WatchKit的程序只需要@2x的图片。</p>
</blockquote>
<p>接下来打开<code>Interface.storyboard</code>，拖拽另外一个Label到storyboard，并将它放到更新的按钮上面。将它的text设置为<code>Last updated</code>。<br><img src="/uploads/2015/04/29/watch-storyboard5.png" alt=""></p>
<p>在iOS程序中，view的顺序是由z-order来决定的。但是针对watch interface，控件之间不会互相的覆盖，所以没有z-order的概念。<br><img src="/uploads/2015/04/29/watch-outline.png" alt=""></p>
<p>##Groups<br>针对Watch Interface，可以设置top/bottom来设置其上下位置，如果是边横排的布局，可以用到<code>groups</code>来设置。Groups更像一个容器，你可以把Interface放在里面。可以设置里面控件的布局是横着还是竖着。</p>
<p>在iPhone上面，图片如下图所示：<br><img src="/uploads/2015/04/29/watch-apparrows.png" alt=""></p>
<p>所以接下来要做的，就是将一个图片放置在Label旁边。拖拽一个group，然后放在price label和last updated label之间，在属性设置里面，将其设为<code>Horizontal</code>。<br><img src="/uploads/2015/04/29/watch-storyboard6.png" alt=""></p>
<p>接下来，拖拽一个图片放到group里面，然后拖拽一个新的label放到group里面，并将其放到image的右边。<br><img src="/uploads/2015/04/29/watch-storyboard7.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2015/04/27/-iOS-导入静态库工程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/27/-iOS-导入静态库工程/" itemprop="url">
                  [iOS]创建静态库文件简明教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-04-27T11:41:21+08:00">
              2015-04-27
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/27/-iOS-导入静态库工程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/27/-iOS-导入静态库工程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/heliu.jpg" rel="gallery_cixjz0myt008h5nti2ot36ol6"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/heliu.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <p>##开始<br>运行XCode，选择<code>File\New\Project</code>，当选在template的对话框的时候，选择<code>iOS\Framework &amp; Library\Cocoa Touch Static Library</code>，如下所示：<br><img src="/uploads/2015/04/27/2.png" alt=""></p>
<p>点击<code>Next</code>，再工程选项的对话框中，选择<code>ImageFilters</code>作为产品的名字。然后输入统一的公司标示还有确保<code>Use Automatic Reference Counting</code>是被选中状态，<code>Include Unit Tests</code>不是被选中状态，如下：<br><img src="/uploads/2015/04/27/3.png" alt=""></p>
<p>点击<code>Next</code>。最后，选择一个位置用来存储新的工程，然后点击<code>Create</code>。</p>
<p>##Image Filters<br>这个库是为iOS设计而且会用的UIKit，所以首先我们需要在头文件中引入UIKit。打开<code>ImageFilters.h</code> 然后添加以下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>接下来，在<code>@Interface ImageFilters:NSObject</code>的下面，粘贴以下声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIImage</span> *originalImage;</div><div class="line">- (<span class="keyword">id</span>)initWithImage:(<span class="built_in">UIImage</span> *)image;</div><div class="line">- (<span class="built_in">UIImage</span> *)grayScaleImage;</div><div class="line">- (<span class="built_in">UIImage</span> *)oldImageWithIntensity:(<span class="built_in">CGFloat</span>)level;</div></pre></td></tr></table></figure></p>
<p>这些头文件中的声明，定义了这个类的公共的接口。接下来是添加实现。打开<code>ImageFilters.m</code>，然后粘贴以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ImageFilters</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">CIContext</span>  *context;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">CIImage</span>    *beginImage;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithImage:(<span class="built_in">UIImage</span> *)image</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _originalImage  = image;</div><div class="line">        _context        = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</div><div class="line">        _beginImage     = [[<span class="built_in">CIImage</span> alloc] initWithImage:_originalImage];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">UIImage</span>*)imageWithCIImage:(<span class="built_in">CIImage</span> *)ciImage</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGImageRef</span> cgiImage = [<span class="keyword">self</span>.context createCGImage:ciImage fromRect:ciImage.extent];</div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:cgiImage];</div><div class="line">    <span class="built_in">CGImageRelease</span>(cgiImage);</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">UIImage</span> *)grayScaleImage</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( !<span class="keyword">self</span>.originalImage)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"> </div><div class="line">    <span class="built_in">CIImage</span> *grayScaleFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIColorControls"</span> keysAndValues:kCIInputImageKey, <span class="keyword">self</span>.beginImage, <span class="string">@"inputBrightness"</span>, [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.0</span>], <span class="string">@"inputContrast"</span>, [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.1</span>], <span class="string">@"inputSaturation"</span>, [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.0</span>], <span class="literal">nil</span>].outputImage;</div><div class="line"> </div><div class="line">    <span class="built_in">CIImage</span> *output = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIExposureAdjust"</span> keysAndValues:kCIInputImageKey, grayScaleFilter, <span class="string">@"inputEV"</span>, [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.7</span>], <span class="literal">nil</span>].outputImage;</div><div class="line"> </div><div class="line">    <span class="built_in">UIImage</span> *filteredImage = [<span class="keyword">self</span> imageWithCIImage:output];</div><div class="line">    <span class="keyword">return</span> filteredImage;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">UIImage</span> *)oldImageWithIntensity:(<span class="built_in">CGFloat</span>)intensity</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( !<span class="keyword">self</span>.originalImage )</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"> </div><div class="line">    <span class="built_in">CIFilter</span> *sepia = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CISepiaTone"</span>];</div><div class="line">    [sepia setValue:<span class="keyword">self</span>.beginImage forKey:kCIInputImageKey];</div><div class="line">    [sepia setValue:@(intensity) forKey:<span class="string">@"inputIntensity"</span>];</div><div class="line"> </div><div class="line">    <span class="built_in">CIFilter</span> *random = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIRandomGenerator"</span>];</div><div class="line"> </div><div class="line">    <span class="built_in">CIFilter</span> *lighten = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIColorControls"</span>];</div><div class="line">    [lighten setValue:random.outputImage forKey:kCIInputImageKey];</div><div class="line">    [lighten setValue:@(<span class="number">1</span> - intensity) forKey:<span class="string">@"inputBrightness"</span>];</div><div class="line">    [lighten setValue:@<span class="number">0.0</span> forKey:<span class="string">@"inputSaturation"</span>];</div><div class="line"> </div><div class="line">    <span class="built_in">CIImage</span> *croppedImage = [lighten.outputImage imageByCroppingToRect:[<span class="keyword">self</span>.beginImage extent]];</div><div class="line"> </div><div class="line">    <span class="built_in">CIFilter</span> *composite = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIHardLightBlendMode"</span>];</div><div class="line">    [composite setValue:sepia.outputImage forKey:kCIInputImageKey];</div><div class="line">    [composite setValue:croppedImage forKey:kCIInputBackgroundImageKey];</div><div class="line"> </div><div class="line">    <span class="built_in">CIFilter</span> *vignette = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIVignette"</span>];</div><div class="line">    [vignette setValue:composite.outputImage forKey:kCIInputImageKey];</div><div class="line">    [vignette setValue:@(intensity * <span class="number">2</span>) forKey:<span class="string">@"inputIntensity"</span>];</div><div class="line">    [vignette setValue:@(intensity * <span class="number">30</span>) forKey:<span class="string">@"inputRadius"</span>];</div><div class="line"> </div><div class="line">    <span class="built_in">UIImage</span> *filteredImage = [<span class="keyword">self</span> imageWithCIImage:vignette.outputImage];</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> filteredImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们就有了一个包含3个公共接口<code>ImageFilters</code>类：<br><code>initWithImage</code>:用来出事话滤镜类<br><code>grayScaleImage</code>:创建灰度的图片<br><code>oldImageWithIntensity</code>:用来创建旧照片的类</p>
<p>现在编译然后运行这个库，XCode会生成的并不是<code>.app</code>或者<code>.ipa</code>文件，而是生成了一个<code>.a</code>后缀名的静态库。你可以再<code>Products</code>的文件夹地下找到这个文件。你可以通过右击再Finder显示用来查看这个文件：</p>
<p><img src="/uploads/2015/04/27/4.png" alt=""></p>
<p>用XCode打开这个文件夹，你可以看到如下的结构：<br><img src="/uploads/2015/04/27/5.png" alt=""></p>
<p>这个静态库一共包含2个部分：<br><code>Header files</code>:在<code>Include</code>文件夹地下，你可以找到公有的头文件。<br><code>Binary Library</code>:静态库文件</p>
<p>如果需要用的时候，需要将这2部分都要导入到工程文件里面；你可以简单的将framework的头文和代码连结到工程里面。</p>
<p>默认情况下，这个库文件只编译支持当前的结构。如果你编译的模拟器的版本，这个库会包含支持i386结构的代码；如果编译的是真机的版本，库的代码只支持ARM的架构。如果你需要两个版本的库，接下来就需要做如下步骤</p>
<p>##通用的文件（Universal Binaries）<br>一个通用的库文件是一个特殊类型的二进制文件，包含了多个平台的代码。可以用<code>lipo</code>工具来生成通用的库文件。</p>
<p><code>lipo</code>是一个命令行的工具，它允许你针对通用的文件做些修改（创建通用的二进制文件，连结通用文件的内容或者更多）。</p>
<p>一个集合的工程，可以用来调用命令行的脚本，在菜单中选择<code>File/New/Target</code>，选择<code>iOS/Other</code>然后选择<code>Aggregate</code>,如下所示：<br><img src="/uploads/2015/04/27/6.png" alt=""></p>
<p>将这个目标工程命名为<code>UniversalLib</code>，确保选中的工程是<code>ImageFilters</code>，如下所示：<br><img src="/uploads/2015/04/27/7.png" alt=""></p>
<p>点击<code>ImageFilters</code>的工程，然后选择<code>UniversalLib</code>的目标工程，切换到<code>Build Phases</code>选项卡；这就是用来设置编译工程所用的脚本文件的地方。</p>
<p>点击<code>Add Build Phase</code>按钮，然后选择<code>Add Run Script</code>：<br><img src="/uploads/2015/04/27/8.png" alt=""></p>
<p>现在你可以设置一个脚本文件，展开<code>Run Script</code>模块，然后再Shell命令行里面粘贴一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># define output folder environment variable</div><div class="line">UNIVERSAL_OUTPUTFOLDER=$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-universal</div><div class="line"> </div><div class="line"># Step 1. Build Device and Simulator versions</div><div class="line">xcodebuild -target ImageFilters ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphoneos  BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot;</div><div class="line">xcodebuild -target ImageFilters -configuration $&#123;CONFIGURATION&#125; -sdk iphonesimulator -arch i386 BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot;</div><div class="line"> </div><div class="line"># make sure the output directory exists</div><div class="line">mkdir -p &quot;$&#123;UNIVERSAL_OUTPUTFOLDER&#125;&quot;</div><div class="line"> </div><div class="line"># Step 2. Create universal binary file using lipo</div><div class="line">lipo -create -output &quot;$&#123;UNIVERSAL_OUTPUTFOLDER&#125;/lib$&#123;PROJECT_NAME&#125;.a&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/lib$&#123;PROJECT_NAME&#125;.a&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/lib$&#123;PROJECT_NAME&#125;.a&quot;</div><div class="line"> </div><div class="line"># Last touch. copy the header files. Just for convenience</div><div class="line">cp -R &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/include&quot; &quot;$&#123;UNIVERSAL_OUTPUTFOLDER&#125;/&quot;</div></pre></td></tr></table></figure></p>
<p>以上脚本所做的工作如下：</p>
<ul>
<li><code>UNIVERSAL_OUTPUTFOLDER</code>表示导出库文件的文件夹位置“Debug-universal”</li>
<li><code>Step 1</code> 在第2行，你可以调用<code>xcodebuild</code>去编译ARM平台的二进制(<code>-sdk iphoneos</code>)</li>
<li>接下来一行再次调用<code>xcodebuild</code>，去编译用在模拟器上的库文件，这个关键参数就是<code>-sdk iphonesimulator -arch i386</code>。</li>
<li><code>Step 2</code> 现在你已经有了2个后缀名为<code>.a</code>的库文件，现在你只需要调用<code>lipo -create</code>去创建一个通用的库文件。</li>
<li>最后一行，用命令<code>cp</code>，将头文件复制到通用文件夹地下</li>
</ul>
<p>最后shell脚本窗口如下所示：<br><img src="/uploads/2015/04/27/9.png" alt=""></p>
<p>现在你可以编译通用的库文件了，选择目标工程<code>UniversalLib</code>,<br><img src="/uploads/2015/04/27/10.png" alt=""></p>
<p>点击<code>Play</code>按钮。如果想看结果，可以用<code>Show in Finder</code>，然后切换到Finder的列选项视窗，你会看到一个文件夹叫做<code>Debug-Universal</code>或者是<code>Release-Universal</code>。<br><img src="/uploads/2015/04/27/11.png" alt=""></p>
<p>以上就是创建通用静态库的所有步骤。如果想在你的工程中调用这个静态库文件，需要做如下步骤：</p>
<p>##程序中调用静态库<br>从库中调用<code>ImageFilters</code>和直接从源代码调用它，没有太大区别：你需要引入这个头文件，然后用它就可以了。现在关键问题是，XCode不知道这个头文件和二进制文件在什么地方。</p>
<p>这里有2个方法将库文件引入到工程里面：</p>
<ul>
<li><code>方法一</code>：添加头文件和二进制文件的引用(<code>.a</code>)</li>
<li><code>方法二</code>：将库工程添加到当前工程作为子工程</li>
</ul>
<p>###引用头文件和库的二进制文件<br>你可以从这里<a href="/uploads/2015/04/27/CoreImageFun.staticlib.zip">CoreImageFun</a>下载这个工程。等你压缩玩这个文件，你可以看到如下结构：<br><img src="/uploads/2015/04/27/12.png" alt=""></p>
<p>打开这个工程，然后编译运行这个程序，你会看到如下错误：<br><img src="/uploads/2015/04/27/13.png" alt=""></p>
<p>这个错误是因为程序不知道从哪里寻找头文件，为了解决这个问题，你需要在<code>Header Search Path</code>添加头文件所在的位置。</p>
<p>如下图所示，点击工程的根节点，然后选择<code>CoreImageFun</code>，然后选择<code>Build Settings</code>，然后定位到<code>Header Search Paths</code>。<br><img src="/uploads/2015/04/27/14.png" alt=""></p>
<p>双击<code>Header Search Paths</code>，再弹窗里面点击<code>+</code>按钮，然后填入如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$SOURCE_ROOT/include</div></pre></td></tr></table></figure></p>
<p>如下图所示：<br><img src="/uploads/2015/04/27/15.png" alt=""></p>
<p><code>$SOURCE_ROOT</code>是XCode的运行变量，这个指向工程的根目录。取消掉弹窗，你会看到如下的结果：<br><img src="/uploads/2015/04/27/16.png" alt=""></p>
<p>编译运行程序，你会看到如下链接错误：<br><img src="/uploads/2015/04/27/17.png" alt=""></p>
<p>这个错误的原因，是因为你没有告诉XCode去哪里查找这个库文件。按照如下的截图，回到<code>CoreImageFun</code>的<code>Build Settings</code>，选择<code>Build Phases</code>选项卡，然后展开<code>Link Binary With Libraries</code>，点击<code>+</code>按钮。<br><img src="/uploads/2015/04/27/18.png" alt=""></p>
<p>在弹出的窗口里面，选择<code>Add Other...</code>按钮，然后找到<code>libImageFilters.a</code>的库文件，<br><img src="/uploads/2015/04/27/19.png" alt=""></p>
<p>当所有的设置完成以后，设置的内容如下：<br><img src="/uploads/2015/04/27/20.png" alt=""></p>
<p>最后一步是添加链接的标签<code>-Objc</code>。链接器为了效率考虑，只会引入必要的代码，所以有时会屏蔽静态库文件。用这个标签，可以导入库中所有的类，关于更多细节，可以参考苹果的文档<a href="http://developer.apple.com/library/mac/#qa/qa1490/_index.html" target="_blank" rel="external">Technical Q&amp;A QA1490</a></p>
<p>点击<code>Build Settings</code>选项卡，定位到<code>Other linker Flags</code>，如下所示：<br><img src="/uploads/2015/04/27/21.png" alt=""></p>
<p>在弹出框中，点击<code>+</code>,输入<code>-Objc</code>,如下图所示：<br><img src="/uploads/2015/04/27/22.png" alt=""></p>
<p>最后你可以编译运行你的程序了。</p>
<p>###作为子工程<br>关于这个部分的教程，你可以在这里<a href="/uploads/2015/04/27/CoreImageFun.subproject.zip">CoreImageFun</a>下载工程。解压完以后，如下图所示：<br><img src="/uploads/2015/04/27/23.png" alt=""></p>
<p>在开始之前，你可以先编译运行一下这个工程，会报如下错误：<br><img src="/uploads/2015/04/27/24.png" alt=""></p>
<p>接下来需要将库的工程导入到当前工程，你需要将库工程拖拽到当前工程，如果库工程已经再XCode中打开，这一步就会失败。如下图所示：<br><img src="/uploads/2015/04/27/25.png" alt=""></p>
<p>完成以上操作，你就可以看到如下的结构：<br><img src="/uploads/2015/04/27/26.png" alt=""></p>
<p>接下来，就需要让XCode知道这个库工程，你需要添加工程依赖关系。这就意味着，在编译主程序之前，XCode需要先保证这个库是最新的。</p>
<p>点击工程的根节点，然后选择<code>CoreImageFun</code>，然后点击<code>Build Phases</code>，然后展开<code>Target Dependencies</code>，如下图所示：<br><img src="/uploads/2015/04/27/27.png" alt=""></p>
<p>点击<code>+</code>按钮，然后添加新的依赖关系，如下图所示，确保选中的<code>ImageFilters</code>，<br><img src="/uploads/2015/04/27/28.png" alt=""></p>
<p>添加完成以后，依赖关如下图所示：<br><img src="/uploads/2015/04/27/29.png" alt=""></p>
<p>最后一步，配置工程，让程序链接这个静态库，展开<code>Link Binary With Libraries</code>，然后点击<code>+</code>，如下图所示：<br><img src="/uploads/2015/04/27/30.png" alt=""></p>
<p>选择<code>libImageFilters.a</code>,然后点击<code>Add</code>：<br><img src="/uploads/2015/04/27/31.png" alt=""></p>
<p>添加完成之后，<code>Link Binary with Libraries</code>应该如下图所示：<br><img src="/uploads/2015/04/27/32.png" alt=""></p>
<p>跟第一种方法一样，需要添加链接标签<code>-ObjC</code>，点击<code>Build Settings</code>然后定位到<code>Other linker Flags</code>，如下图所示：<br><img src="/uploads/2015/04/27/33.png" alt=""></p>
<p>这就是怎样制作以及添加静态库文件。</p>
<p>原文地址：<a href="http://www.raywenderlich.com/41377/creating-a-static-library-in-ios-tutorial" target="_blank" rel="external">http://www.raywenderlich.com/41377/creating-a-static-library-in-ios-tutorial</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar/avatar.jpg"
               alt="姜楠" />
          <p class="site-author-name" itemprop="name">姜楠</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">115</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/njiang1987" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姜楠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"njiang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
