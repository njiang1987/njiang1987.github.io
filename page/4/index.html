<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="天空の城">
<meta property="og:url" content="http://www.njiang.cn/page/4/index.html">
<meta property="og:site_name" content="天空の城">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天空の城">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.njiang.cn/page/4/"/>





  <title> 天空の城 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-43682645-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">天空の城</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">愤怒的程序员，梦想着有一天也能飞！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/11/06/-LeetCode-Exercise-Day4/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/06/-LeetCode-Exercise-Day4/" itemprop="url">
                  [LeetCode]Exercise(Day4)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-11-06T23:37:13+08:00">
              2014-11-06
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/06/-LeetCode-Exercise-Day4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/06/-LeetCode-Exercise-Day4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/maomi.jpg" rel="gallery_cixjz0myd007k5ntip3y86qk9"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/maomi.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <p>##Word Ladder</p>
<p>###问题描述<br>You are given a string, S, and a list of words, L, that are all Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:</p>
<p>Only one letter can be changed at a time<br>Each intermediate word must exist in the dictionary<br>For example,</p>
<p>Given:<br>start = <code>&quot;hit&quot;</code><br>end = <code>&quot;cog&quot;</code><br>dict = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code><br>As one shortest transformation is <code>&quot;hit&quot;</code> -&gt; <code>&quot;hot&quot;</code> -&gt; <code>&quot;dot&quot;</code> -&gt; <code>&quot;dog&quot;</code> -&gt; <code>&quot;cog&quot;</code>,<br>return its length <code>5</code>.</p>
<p>Note:</p>
<ol>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ol>
<p>###解决方法<br>可以先将L中得元素，按照只改变一个字母的原则，简历一颗树，这样问题就简化为，广度优先遍历这棵树，然后找到root到leaf得最短长度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> end, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)</span> </span>&#123;</div><div class="line">       <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; current, next;</div><div class="line">       <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</div><div class="line"></div><div class="line">       <span class="keyword">auto</span> isEqualToEndString = [&amp;](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)&#123;<span class="keyword">return</span> s == end;&#125;;</div><div class="line">       <span class="keyword">auto</span> extendString = [&amp;](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)&#123;</div><div class="line">           <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</div><div class="line"></div><div class="line">           <span class="keyword">const</span> <span class="keyword">size_t</span> length = s.length();</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">               <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(s)</span></span>;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</div><div class="line">                   <span class="keyword">if</span> (c == str[i]) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                   swap(c, str[i]);</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> ((dict.count(str) || (str == end)) &gt; <span class="number">0</span> &amp;&amp; visited.count(str) == <span class="number">0</span>) &#123;</div><div class="line">                       visited.insert(str);</div><div class="line">                       result.push_back(str);</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   swap(c, str[i]);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;;</div><div class="line">       <span class="keyword">bool</span> found = <span class="literal">false</span>;</div><div class="line">       <span class="keyword">int</span> level = <span class="number">0</span>;</div><div class="line">       current.push(start);</div><div class="line">       <span class="keyword">while</span> (!current.empty() &amp;&amp; !found) &#123;</div><div class="line">           ++level;</div><div class="line">           <span class="keyword">while</span> (!current.empty() &amp;&amp; !found) &#123;</div><div class="line">               <span class="keyword">const</span> <span class="built_in">string</span> str = current.front();</div><div class="line">               current.pop();</div><div class="line"></div><div class="line">               <span class="keyword">const</span> <span class="keyword">auto</span>&amp; extend = extendString(str);</div><div class="line">               <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; state : extend)&#123;</div><div class="line">                   next.push(state);</div><div class="line">                   <span class="keyword">if</span> (isEqualToEndString(state)) &#123;</div><div class="line">                       found = <span class="literal">true</span>;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           swap(current, next);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (found) &#123;</div><div class="line">           <span class="keyword">return</span> level + <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>##Substring with Concatenation of All Words</p>
<p>###问题描述<br>You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.</p>
<p>For example, given:<br>S: <code>&quot;barfoothefoobarman&quot;</code><br>L: <code>[&quot;foo&quot;, &quot;bar&quot;]</code></p>
<p>You should return the indices: [0,9].(order does not matter).</p>
<p>###解决方法<br>由于我写的代码在另一台机器上，以下是戴方勤的代码，思想就是在<code>S</code>中逐个查找，如果是在<code>L</code>中得单词，就进入j的循环，查看后面catLength长度的字符串是不是都符合题目中得要求，在L中能找到。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict) &#123;</div><div class="line">         <span class="keyword">size_t</span> wordLength = dict.front().length();</div><div class="line">         <span class="keyword">size_t</span> catLength = wordLength * dict.size();</div><div class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">         <span class="keyword">if</span> (s.length() &lt; catLength) <span class="keyword">return</span> result;</div><div class="line">         <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordCount;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; word : dict) ++wordCount[word];</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span> i = begin(s); i &lt;= prev(end(s), catLength); ++i) &#123;</div><div class="line">             <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; unused(wordCount);</div><div class="line">             <span class="keyword">for</span> (<span class="keyword">auto</span> j = i; j != next(i, catLength); j += wordLength) &#123;</div><div class="line">                 <span class="keyword">auto</span> pos = unused.find(<span class="built_in">string</span>(j, next(j, wordLength)));</div><div class="line">                 <span class="keyword">if</span> (pos == unused.end() || pos-&gt;second == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">                 <span class="keyword">if</span> (--pos-&gt;second == <span class="number">0</span>) unused.erase(pos);</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (unused.size() == <span class="number">0</span>) result.push_back(distance(begin(s), i));</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> result;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>##Path Sum II</p>
<p>###问题描述<br>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      5</div><div class="line">     / \</div><div class="line">    4   8</div><div class="line">   /   / \</div><div class="line">  11  13  4</div><div class="line"> /  \    / \</div><div class="line">7    2  5   1</div></pre></td></tr></table></figure>
<p>return<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">   [5,4,11,2],</div><div class="line">   [5,8,4,5]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>###解决方法<br>这个题目，拿过来首先想到递归遍历，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; pathSum(TreeNode *root, <span class="keyword">int</span> sum) &#123;</div><div class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">       <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> result;</div><div class="line">       </div><div class="line">       <span class="keyword">int</span> val = root-&gt;val;</div><div class="line">       </div><div class="line">       <span class="keyword">if</span> ((val == sum) &amp;&amp; (root-&gt;left == <span class="literal">NULL</span>) &amp;&amp; (root-&gt;right == <span class="literal">NULL</span>)) &#123;</div><div class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;val&#125;;</div><div class="line">           result.push_back(t);</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; leftPath = pathSum(root-&gt;left, sum - val);</div><div class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rightPath = pathSum(root-&gt;right, sum - val);</div><div class="line">       </div><div class="line">       </div><div class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> iter = leftPath.begin(); iter != leftPath.end(); iter++) &#123;</div><div class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = *iter;</div><div class="line">           tmp.insert(tmp.begin(), val);</div><div class="line">           result.push_back(tmp);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> iter = rightPath.begin(); iter != rightPath.end(); iter++) &#123;</div><div class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = *iter;</div><div class="line">           tmp.insert(tmp.begin(), val);</div><div class="line">           result.push_back(tmp);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>##Binary Tree Preorder Traversal</p>
<p>###问题描述<br>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>return <code>[1,2,3]</code>.</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<p>###解决方法<br>戴的解法是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</div><div class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">         <span class="keyword">const</span> TreeNode *p;</div><div class="line">         <span class="built_in">stack</span>&lt;<span class="keyword">const</span> TreeNode *&gt; s;</div><div class="line">         p = root;</div><div class="line">         <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) s.push(p);</div><div class="line">         <span class="keyword">while</span> (!s.empty()) &#123;</div><div class="line">             p = s.top();</div><div class="line">             s.pop();</div><div class="line">             result.push_back(p-&gt;val);</div><div class="line">             <span class="keyword">if</span> (p-&gt;right != <span class="literal">nullptr</span>) s.push(p-&gt;right);</div><div class="line">             <span class="keyword">if</span> (p-&gt;left != <span class="literal">nullptr</span>) s.push(p-&gt;left);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> result;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>我的解法，有点复杂，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root)</div><div class="line">   &#123;</div><div class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">       <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</div><div class="line">       </div><div class="line">       <span class="built_in">stack</span>&lt;TreeNode*&gt; lpStack;</div><div class="line">       <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">bool</span>&gt; visited;</div><div class="line">       TreeNode* pNode = root;</div><div class="line">       </div><div class="line">       <span class="keyword">while</span> (pNode != <span class="literal">NULL</span>) &#123;</div><div class="line">           </div><div class="line">           <span class="keyword">if</span> (!visited[pNode]) &#123;</div><div class="line">               lpStack.push(pNode);</div><div class="line">               visited[pNode] = <span class="literal">true</span>;</div><div class="line">               result.push_back(pNode-&gt;val);</div><div class="line">           &#125;</div><div class="line">           </div><div class="line">           <span class="keyword">if</span> (pNode-&gt;left &amp;&amp; !visited[pNode-&gt;left]) &#123;</div><div class="line">               pNode = pNode-&gt;left;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;right &amp;&amp; !visited[pNode-&gt;right])&#123;</div><div class="line">               pNode = pNode-&gt;right;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">else</span>&#123;</div><div class="line">               <span class="keyword">if</span> (lpStack.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                   pNode = lpStack.top();</div><div class="line">                   lpStack.pop();</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span>&#123;</div><div class="line">                   pNode = <span class="literal">NULL</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>##Unique Paths</p>
<p>###问题描述<br>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?<br><img src="/uploads/2014/11/08/robot_maze.png" alt=""><br>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p>Note: m and n will be at most 100.</p>
<p>###解决方法<br>利用动态规划，a[i][j] = a[i-1][j] + a[i][j-1],最后就可以得出a[m-1][n-1]的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></div><div class="line">   &#123;</div><div class="line">       <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (m == <span class="number">1</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">       </div><div class="line">       <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</div><div class="line">       a[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">               <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line">               </div><div class="line">               <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</div><div class="line">                   a[i*n + j] = a[(i - <span class="number">1</span>)*n + j];</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</div><div class="line">                   a[i*n + j] = a[j - <span class="number">1</span>];</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span>&#123;</div><div class="line">                   a[i*n + j] = a[(i<span class="number">-1</span>)*n + j] + a[i*n + j - <span class="number">1</span>];</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> a[(m<span class="number">-1</span>)*n + n<span class="number">-1</span>];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>##Subsets</p>
<p>###问题描述<br>Given a set of distinct integers, S, return all possible subsets.</p>
<p>Note:<br>Elements in a subset must be in non-descending order.<br>The solution set must not contain duplicate subsets.<br>For example,<br>If S = [1,2,3], a solution is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>###解决方法<br>先对队列排序，完了用递归，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;S) &#123;</div><div class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">       <span class="keyword">if</span> (S.size() == <span class="number">0</span>) &#123;</div><div class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; empty;</div><div class="line">           result.push_back(empty);</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       sort(S.begin(), S.end());</div><div class="line">       </div><div class="line">       <span class="keyword">int</span> val = S.front();</div><div class="line">       S.erase(S.begin());</div><div class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; prevs = subsets(S);</div><div class="line">       result = prevs;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> iter = prevs.begin(); iter != prevs.end(); iter++) &#123;</div><div class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = *iter;</div><div class="line">           tmp.insert(tmp.begin(), val);</div><div class="line">           result.push_back(tmp);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/11/05/-LeetCode-Exercise-Day3/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/05/-LeetCode-Exercise-Day3/" itemprop="url">
                  [LeetCode]Exercise(Day3)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-11-05T22:59:35+08:00">
              2014-11-05
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/05/-LeetCode-Exercise-Day3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/05/-LeetCode-Exercise-Day3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Permutation Sequence</p>
<p>###问题描述<br>The set [1,2,3,⋯,n] contains a total of n! unique permutations.<br>By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3):<br>  “123”<br>  “132”<br>  “213”<br>  “231”<br>  “312”<br>  “321”<br>Given n and k, return the kth permutation sequence.<br> Note: Given n will be between 1 and 9 inclusive.</p>
<p>###解决方法<br>这个可以利用上一个问题里面的方法，暴力破解，逐个查找，直到第K个。<br>从别人的了解到还有康托编码的方法解决这个问题，<br>利用康托编码的思路,假设有n个不重复的元素,第k个排列是a1,a2,a3,…,an,那么a1 是 哪一个位置呢?<br>我们把 a1 去掉,那么剩下的排列为 a2, a3, …, an, 共计 n − 1 个元素,n − 1 个元素共有 (n − 1)! 个排列,于是就可以知道 a1 = k/(n − 1)!。<br>同理,a2,a3,…,an 的值推导如下:</p>
<p><img src="/uploads/2014/11/05/1.png" alt="" title="Title"></p>
<p>使用 next_permutation()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LeetCode, Permutation Sequence // 使用 next_permutation(),TLE class Solution &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">          <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(n, <span class="string">'0'</span>)</span></span>;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">              s[i] += i+<span class="number">1</span>;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; ++i)</div><div class="line">              next_permutation(s.begin(), s.end());</div><div class="line">          <span class="keyword">return</span> s;</div><div class="line">	&#125;</div><div class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> BidiIt&gt;</div><div class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">(BidiIt first, BidiIt last)</span> </span>&#123;</div><div class="line">	<span class="comment">// 代码见上一题 Next Permutation</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>康托编码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Sequence&gt;</div><div class="line">   <span class="function">Sequence <span class="title">kth_permutation</span><span class="params">(<span class="keyword">const</span> Sequence&amp; seq, <span class="keyword">int</span> k)</span></span></div><div class="line">   &#123;</div><div class="line">       <span class="keyword">const</span> <span class="keyword">int</span> n = (<span class="keyword">int</span>)seq.size();</div><div class="line">       <span class="function">Sequence <span class="title">S</span><span class="params">(seq)</span></span>;</div><div class="line">       Sequence result;</div><div class="line">       <span class="keyword">int</span> base = factorial(n<span class="number">-1</span>);</div><div class="line">       --k;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; k %= base, base /= i, i--) &#123;</div><div class="line">           <span class="keyword">auto</span> a = next(S.begin(), k / base);</div><div class="line">           result.push_back(*a);</div><div class="line">           S.erase(a);</div><div class="line">       &#125;</div><div class="line">       result.push_back(S[<span class="number">0</span>]);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>###扩展阅读<br>康托编码<br><br>{1,2,3,4,…,n}表示1,2,3,…,n的排列如 {1,2,3} 按从小到大排列一共6个。123 132 213 231 312 321 。<br>代表的数字 1 2 3 4 5 6 也就是把10进制数与一个排列对应起来。<br>他们间的对应关系可由康托展开来找到。<br>如我想知道321是{1,2,3}中第几个小的数可以这样考虑 ：</p>
<p>第一位是3，当第一位的数小于3时，那排列数小于321 如 123、 213 ，小于3的数有1、2 。所以有2<em>2!个。再看小于第二位2的：小于2的数只有一个就是1 ，所以有1</em>1!=1 所以小于321的{1,2,3}排列数有2<em>2!+1</em>1!=5个。所以321是第6个小的数。 2<em>2!+1</em>1!+0*0!就是康托展开。</p>
<p>再举个例子：1324是{1,2,3,4}排列数中第几个大的数：第一位是1小于1的数没有，是0个 0<em>3! 第二位是3小于3的数有1和2，但1已经在第一位了，所以只有一个数2 1</em>2! 。第三位是2小于2的数是1，但1在第一位，所以有0个数 0<em>1! ，所以比1324小的排列有0</em>3!+1<em>2!+0</em>1!=2个，1324是第三个小数。</p>
<p>##Trapping Rain Water</p>
<p>###问题描述<br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="/uploads/2014/11/05/2.png" alt=""></p>
<p>###解决方法<br>应该从没一个数字去考虑，比如上面序列第2个0的位置，也就是第3个数字，可以查找它两边最高的，然后取两者之间的最小值，减去自己的高度，这个差值就是当前位置的储水量，即<code>min(max_left, max_right) - height</code>。问题来了，怎么找到它的左右两边的最大值，遍历一遍，可以找到。以下参考网上的解决方法。</p>
<ol>
<li>从左往右扫描一遍,对于每个柱子,求取左边最大值;</li>
<li>从右往左扫描一遍,对于每个柱子,求最大右值;</li>
<li>再扫描一遍,把每个柱子的面积并累加。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line">   &#123;</div><div class="line">       <span class="keyword">int</span>* max_left = <span class="keyword">new</span> <span class="keyword">int</span>(n);</div><div class="line">       <span class="keyword">int</span>* max_right = <span class="keyword">new</span> <span class="keyword">int</span>(n);</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">           max_left[i] = max(max_left[i<span class="number">-1</span>], A[i]);</div><div class="line">           max_right[n - i - <span class="number">1</span>] = max(max_right[n - i], A[n - i - <span class="number">1</span>]);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">           <span class="keyword">int</span> heigh = min(max_left[i], max_right[i]) - i;</div><div class="line">           <span class="keyword">if</span> (heigh &gt; <span class="number">0</span>) &#123;</div><div class="line">               result = heigh;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">delete</span> [] max_left;</div><div class="line">       <span class="keyword">delete</span> [] max_right;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>还有一种解决方法，就是用栈来保存峰值信息。小于的话，直接压栈，只要比top的大或相等，就出栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line">   &#123;</div><div class="line">       <span class="built_in">stack</span>&lt;Pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; lpStack;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> water = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">           <span class="keyword">int</span> height = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">while</span> (!lpStack.empty()) &#123;</div><div class="line">               <span class="keyword">int</span> bar = lpStack.top().first();</div><div class="line">               <span class="keyword">int</span> pos = lpStack.top().second();</div><div class="line"></div><div class="line">               water += (min(bar, A[i]) - height) * (i - pos - <span class="number">1</span>);</div><div class="line">               height = bar;</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (bar &gt; A[i]) &#123;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span>&#123;</div><div class="line">                   lpStack.pop();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           lpStack.push(Pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(A[i], i));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> water;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>##Rotate Image</p>
<p>###问题描述<br>You are given an n × n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).<br>Follow up: Could you do this in-place?</p>
<p>###解决方法<br>首先想到,纯模拟,从外到内一圈一圈的转,但这个方法太慢。<br>  如下图,首先沿着副对角线翻转一次,然后沿着水平中线翻转一次。<br><img src="/uploads/2014/11/05/3.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></div><div class="line">   &#123;</div><div class="line">       <span class="keyword">const</span> <span class="keyword">int</span> n = (<span class="keyword">int</span>)matrix.size();</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</div><div class="line">               swap(matrix[i][j], matrix[n - j - <span class="number">1</span>][n - i - <span class="number">1</span>]);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">               swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/11/04/-iOS-底层并发-API-读书笔记/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/04/-iOS-底层并发-API-读书笔记/" itemprop="url">
                  [iOS]底层并发 API-读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-11-04T19:18:59+08:00">
              2014-11-04
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/04/-iOS-底层并发-API-读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/04/-iOS-底层并发-API-读书笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##GCD和NSOperationQueue<br>GCD是基于C的耿底层的API，它可以</p>
<p>##dispatch_once<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIColor</span> *)boringColor;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">UIColor</span> *color;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.380</span>f green:<span class="number">0.376</span>f blue:<span class="number">0.376</span>f alpha:<span class="number">1.000</span>f];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>onceToken 被声明为 static ，或者有全局作用域</li>
</ol>
<p>##dispatch_after<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)foo</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</div><div class="line">    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">    dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">        [<span class="keyword">self</span> bar];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##Queue<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.isolation.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</div><div class="line">        <span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</div><div class="line"></div><div class="line">        label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.work.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</div><div class="line">        <span class="keyword">self</span>.workQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>默认情况下，队列是串行的。</li>
<li>GCD 通过创建所谓的线程池来大致匹配 CPU 内核数量。</li>
<li>不应该在GCD队列中以阻塞的方式来做这些操作，比如从文件或者网络中读写数据</li>
</ol>
<p>###目标队列<br><code>(lldb) thread list</code> 命令将会在控制台打印出所有队列的名字</p>
<p>###优先级<br>DISPATCH_QUEUE_PRIORITY_BACKGROUND，理解了 throttled I/O 和 background status as per setpriority(2) 的意义</p>
<p>##隔离</p>
<p>###单一资源的多读单写<br>创建队列<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure></p>
<p>读写操作<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSUInteger</span>)count forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">    key = [key <span class="keyword">copy</span>];</div><div class="line">    dispatch_barrier_async(<span class="keyword">self</span>.isolationQueue, ^()&#123;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">            [<span class="keyword">self</span>.counts removeObjectForKey:key];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">self</span>.counts[key] = @(count);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSUInteger</span>)countForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSUInteger</span> count;</div><div class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.isolationQueue, ^()&#123;</div><div class="line">        <span class="built_in">NSNumber</span> *n = <span class="keyword">self</span>.counts[key];</div><div class="line">        count = [n unsignedIntegerValue];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>当使用并发队列时，要确保所有的 barrier 调用都是 async 的.</li>
</ol>
<p>###锁竞争</p>
<ol>
<li>所有对 dispatch_async，dispatch_sync 等等的调用都需要完成某种形式的锁——以确保仅有一个线程或者特定的线程运行指定的代码</li>
<li><p>性能下降的原因：</p>
<p> 第一个是独占临界区资源太久的开销，以至于别的线程都因为进入临界区的操作而阻塞。第二个是太频繁出入临界区的开销</p>
</li>
</ol>
<p>###全都使用异步分发<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queueA; <span class="comment">// assume we have this</span></div><div class="line"><span class="built_in">dispatch_sync</span>(queueA, ^()&#123;</div><div class="line">    <span class="built_in">dispatch_sync</span>(queueA, ^()&#123;</div><div class="line">        foo();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>进入第2个dispatch_sync会发生死锁。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queueA; <span class="comment">// assume we have this</span></div><div class="line"><span class="built_in">dispatch_async</span>(queueA, ^()&#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(queueA, ^()&#123;</div><div class="line">        foo();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>##如何写出好的异步API<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)processImage:(<span class="built_in">UIImage</span> *)image completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> success))handler;</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.isolationQueue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">        <span class="comment">// do actual processing here</span></div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.resultQueue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">            handler(<span class="literal">YES</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##迭代执行diapatch_apply<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_apply(height, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^(size_t y) &#123;</div><div class="line">    <span class="keyword">for</span> (size_t x = <span class="number">0</span>; x &lt; width; x += <span class="number">2</span>) &#123;</div><div class="line">        <span class="comment">// Do something with x and y here</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>##组<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">dispatch_group_async(group, queue, ^()&#123;</div><div class="line">    <span class="comment">// Do something that takes a while</span></div><div class="line">    [<span class="keyword">self</span> doSomeFoo];</div><div class="line">    dispatch_group_async(group, dispatch_get_main_queue(), ^()&#123;</div><div class="line">        <span class="keyword">self</span>.foo = <span class="number">42</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^()&#123;</div><div class="line">    <span class="comment">// Do something else that takes a while</span></div><div class="line">    [<span class="keyword">self</span> doSomeBar];</div><div class="line">    dispatch_group_async(group, dispatch_get_main_queue(), ^()&#123;</div><div class="line">        <span class="keyword">self</span>.bar = <span class="number">1</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// This block will run once everything above is done:</span></div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^()&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"foo: %d"</span>, <span class="keyword">self</span>.foo);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"bar: %d"</span>, <span class="keyword">self</span>.bar);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>##对现有API使用dispatch_group_t</p>
<p>确保自己使用 groups 的代码是成对出现的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> performBlock:block];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dispatch_group_enter(group);</div><div class="line">        [<span class="keyword">self</span> performBlock:^()&#123;</div><div class="line">            block();</div><div class="line">            dispatch_group_leave(group);</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以用<code>dispatch_group_notify</code>来运行一个block</p>
<p>类似的对于NSURLConnection，也可以做同样的事情<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group </div><div class="line">        sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request </div><div class="line">        queue:(<span class="built_in">NSOperationQueue</span> *)queue </div><div class="line">        completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> sendAsynchronousRequest:request </div><div class="line">                                queue:queue </div><div class="line">                    completionHandler:handler];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dispatch_group_enter(group);</div><div class="line">        [<span class="keyword">self</span> sendAsynchronousRequest:request </div><div class="line">                                queue:queue </div><div class="line">                    completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error)&#123;</div><div class="line">            handler(response, data, error);</div><div class="line">            dispatch_group_leave(group);</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><code>dispatch_group_enter()</code> 必须要在 <code>dispatch_group_leave()</code>之前运行。</li>
<li><code>dispatch_group_enter()</code> 和 <code>dispatch_group_leave()</code> 一直是成对出现的（就算有错误产生时）。</li>
</ol>
<p>##事件源</p>
<p>###监视进程<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSRunningApplication</span> *mail = [<span class="built_in">NSRunningApplication</span> </div><div class="line">  runningApplicationsWithBundleIdentifier:<span class="string">@"com.apple.mail"</span>];</div><div class="line"><span class="keyword">if</span> (mail == <span class="literal">nil</span>) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pid_t <span class="keyword">const</span> pid = mail.processIdentifier;</div><div class="line"><span class="keyword">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, </div><div class="line">  DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^()&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Mail quit."</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure></p>
<p>在所有的事件源被传递到你的事件处理器之前，必须调用 dispatch_resume()</p>
<p>###监视文件<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *directoryURL; <span class="comment">// assume this is set to a directory</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);</div><div class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">char</span> buffer[<span class="number">80</span>];</div><div class="line">    strerror_r(errno, buffer, <span class="keyword">sizeof</span>(buffer));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Unable to open \"%@\": %s (%d)"</span>, [directoryURL path], buffer, errno);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd, </div><div class="line">  DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> data = dispatch_source_get_data(source);</div><div class="line">    <span class="keyword">if</span> (data &amp; DISPATCH_VNODE_WRITE) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"The directory changed."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (data &amp; DISPATCH_VNODE_DELETE) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"The directory has been deleted."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">dispatch_source_set_cancel_handler(source, ^()&#123;</div><div class="line">    close(fd);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">self</span>.source = source;</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure></p>
<p>##定时器<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, </div><div class="line">  <span class="number">0</span>, <span class="number">0</span>, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Time flies."</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_time_t start</div><div class="line">dispatch_source_set_timer(source, DISPATCH_TIME_NOW, <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>, </div><div class="line">  <span class="number">100</span>ull * <span class="built_in">NSEC_PER_MSEC</span>);</div><div class="line"><span class="keyword">self</span>.source = source;</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure></p>
<p>##GCD和缓冲区<br>GCD的缓冲区<code>dispatch_data_t</code>，类似于Objective-C的NSData。<br>这个缓冲区要么基于栈，要么基于内存区域。<code>dispatch_data_t</code>是基于零碎的内存区域。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_data_t a; <span class="comment">// Assume this hold some valid data</span></div><div class="line">dispatch_data_t b; <span class="comment">// Assume this hold some valid data</span></div><div class="line">dispatch_data_t c = dispatch_data_create_concat(a, b);</div></pre></td></tr></table></figure></p>
<p>以上只是retain了a和b。一下代码用来遍历c持有的内存区域：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_data_apply(c, ^(dispatch_data_t region, size_t offset, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, size_t size) &#123;</div><div class="line">    fprintf(stderr, <span class="string">"region with offset %zu, size %zu\n"</span>, offset, size);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><code>dispatch_data_create_subrange</code> 来创建一个不做任何拷贝操作的子区域</p>
<p>##读和写<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, </div><div class="line">  <span class="built_in">dispatch_queue_t</span> queue, <span class="keyword">void</span> (^cleanup_handler)(<span class="keyword">int</span> error));</div></pre></td></tr></table></figure></p>
<ol>
<li>有两种从根本上不同类型的通道：流和随机存取</li>
<li><code>dispatch_io_create_with_path</code>, GCD会延迟打开这个文件以限制相同时间内同时打开的文件数量</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/11/02/-LeetCode-Exercise-Day2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/02/-LeetCode-Exercise-Day2/" itemprop="url">
                  [LeetCode]Exercise(Day2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-11-02T10:20:43+08:00">
              2014-11-02
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/02/-LeetCode-Exercise-Day2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/02/-LeetCode-Exercise-Day2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/meinv.jpg" rel="gallery_cixjz0my7007a5ntihgo5mw3w"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/meinv.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <p>##Two Sum</p>
<p>###问题描述<br>Given an array of integers, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p>###解决方法<br>我们可以用一个hashmap来保存之前已经遍历的值，然后在便利到某个值的时候，可以先找与它匹配的值是否已经加到hashmap里面；如果有，返回此值，否则继续，知道遍历完整个数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> target)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    </div><div class="line">    <span class="keyword">size_t</span> size = num.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">int</span> key = num[i];</div><div class="line">        <span class="keyword">if</span> (mapping[key] == <span class="number">0</span>) &#123;</div><div class="line">            mapping[key] = i+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// find the next one</span></div><div class="line">        <span class="keyword">int</span> other = target - key;</div><div class="line">        <span class="keyword">if</span> (mapping[other] != <span class="number">0</span>) &#123;</div><div class="line">            result.push_back(mapping[other]);</div><div class="line">            result.push_back(i+<span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##3Sum</p>
<p>###问题描述<br>Given an array S of n integers, are there elements a,b,c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note:<br>• Elements in a triplet (a, b, c) must be in non-descending order. (ie, a ≤ b ≤ c) • Thesolutionsetmustnotcontainduplicatetriplets.<br>For example, given array S = {-1 0 1 2 -1 -4}.<br>A solution set is:<br>  (-1, 0, 1)<br>  (-1, -1, 2)</p>
<p>###解决方法<br>有2个方法可以解决，时间复杂度都是O(n^2);<br>方法1：利用2个函数的和的那个函数，先拿出一个值来，再确定另外2个值，<br>方法2：先排序再从外向内的查找第3个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 1 partition</span></div><div class="line">    <span class="keyword">int</span> key = num[left];</div><div class="line">    <span class="keyword">int</span> l = left;</div><div class="line">    <span class="keyword">int</span> h = right;</div><div class="line">    <span class="keyword">while</span>(l &lt; h)&#123;</div><div class="line">        <span class="keyword">while</span>(h &gt; l &amp;&amp; num[h] &gt;= key) h--;</div><div class="line">        num[l] = num[h];</div><div class="line">        <span class="keyword">while</span>(l &lt; h &amp;&amp; num[l] &lt;= key) l++;</div><div class="line">        num[h] = num[l];</div><div class="line">    &#125;</div><div class="line">    num[l] = key;</div><div class="line">    </div><div class="line">    <span class="comment">// quick left and right</span></div><div class="line">    quickSort(num, left, l - <span class="number">1</span>);</div><div class="line">    quickSort(num, l + <span class="number">1</span>, right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// -1, 0, 1, 2, -1, -4</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 1. quick sort</span></div><div class="line">    quickSort(num, <span class="number">0</span>, num.size() - <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 2. find the right value</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> h = (<span class="keyword">int</span>)num.size() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(h - l &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">int</span> key1 = num[l];</div><div class="line">        <span class="keyword">int</span> key2 = num[h];</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> key3 = target - key1 - key2;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt; h; i++)&#123;</div><div class="line">            <span class="keyword">if</span> (num[i] == key3) &#123;</div><div class="line">                index = i;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(index != <span class="number">-1</span>)&#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</div><div class="line">            t.push_back(key1);</div><div class="line">            t.push_back(key3);</div><div class="line">            t.push_back(key2);</div><div class="line">            result.push_back(t);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (key3 &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;l++;&#125; <span class="keyword">while</span> (num[l] == key1);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key3 &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">do</span> &#123;h--;&#125; <span class="keyword">while</span> (num[h] == key2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    sort(result.begin(), result.end());</div><div class="line">    result.erase(unique(result.begin(), result.end()), result.end());</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###扩展阅读<br>STL Unique函数的作用是去除相邻重复元素</p>
<p>##Remove Element</p>
<p>###问题描述<br>Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>###解决方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> elem)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (A[i] != elem) &#123;</div><div class="line">            A[++index] = A[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##Next Permutation</p>
<p>###问题描述<br>Implement next permutation, which rearranges numbers into the lexicographically next greater permu- tation of numbers.<br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascend- ing order).<br>The replacement must be in-place, do not allocate extra memory.<br>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>  1,2,3 → 1,3,2<br>  3,2,1 → 1,2,3<br>  1,1,5 → 1,5,1</p>
<p>###解决方法<br>之前碰到过类似的题目，先从后面往前查找，第一个减小的数字，比如[1, 2, 3]，查找的时候因为3&gt;2，所以就停下，进行替换，替换的时候需要找到2后面：大于2且最小的值；置换2和此数字之后，再降后面的数组进行排序（因为我们之前判定过了是递增的，从后往前方向，所以这边直接reverse就可以）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Iter&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation2</span><span class="params">(_Iter first, _Iter last)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> rfirst = reverse_iterator&lt;_Iter&gt;(last);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> rlast = reverse_iterator&lt;_Iter&gt;(first);</div><div class="line">    </div><div class="line">    <span class="keyword">auto</span> pivot = next(rfirst);</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (pivot != rlast &amp;&amp; *pivot &gt; *(prev(pivot)))</div><div class="line">        pivot++;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (pivot == rlast) &#123;</div><div class="line">        reverse(first, last);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">auto</span> change = find_if(rfirst, pivot, bind1st(less&lt;<span class="keyword">int</span>&gt;(), *pivot));</div><div class="line">    swap(*change, *pivot);</div><div class="line">    reverse(rfirst, pivot);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此程序是参考的其他人用STL编写的，其中用到了大量的STL操作，后续再做介绍。我自己实现了一个较难理解的程序，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 1 partition</span></div><div class="line">    <span class="keyword">int</span> key = num[left];</div><div class="line">    <span class="keyword">int</span> l = left;</div><div class="line">    <span class="keyword">int</span> h = right;</div><div class="line">    <span class="keyword">while</span>(l &lt; h)&#123;</div><div class="line">        <span class="keyword">while</span>(h &gt; l &amp;&amp; num[h] &gt;= key) h--;</div><div class="line">        num[l] = num[h];</div><div class="line">        <span class="keyword">while</span>(l &lt; h &amp;&amp; num[l] &lt;= key) l++;</div><div class="line">        num[h] = num[l];</div><div class="line">    &#125;</div><div class="line">    num[l] = key;</div><div class="line">    </div><div class="line">    <span class="comment">// quick left and right</span></div><div class="line">    quickSort(num, left, l - <span class="number">1</span>);</div><div class="line">    quickSort(num, l + <span class="number">1</span>, right);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//1. find the first lower num</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> lCount = (<span class="keyword">int</span>)num.size();</div><div class="line">    <span class="keyword">int</span> lChangeIndex = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lCount - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">if</span> (num[i<span class="number">-1</span>] &lt; num[i]) &#123;</div><div class="line">            lChangeIndex = i<span class="number">-1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// if the vec is like 3, 2, 1, reverse it automatically</span></div><div class="line">    <span class="keyword">if</span> (lChangeIndex == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> h = lCount - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</div><div class="line">            <span class="keyword">int</span> t = num[l];</div><div class="line">            num[l] = num[h];</div><div class="line">            num[h] = t;</div><div class="line">            l++; h--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">int</span> lNextNum = INT_MAX;</div><div class="line">        <span class="keyword">int</span> lNextIndex = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lChangeIndex + <span class="number">1</span>; i &lt; lCount; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(num[i] &gt; num[lChangeIndex] &amp;&amp; num[i] &lt; lNextNum)&#123;</div><div class="line">                lNextNum = num[i];</div><div class="line">                lNextIndex = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> t = num[lChangeIndex];</div><div class="line">        num[lChangeIndex] = num[lNextIndex];</div><div class="line">        num[lNextIndex] = t;</div><div class="line">        quickSort(num, lChangeIndex + <span class="number">1</span>, lCount - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###扩展阅读</p>
<p>####reverse_iterator<br>对于left_null&gt;1-&gt;2-&gt;3-&gt;4-&gt;right_null,这样一个有4个元素(1,2,3,4)的链表.<br>    1-&gt;2-&gt;3-&gt;4-&gt;尾<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;iteraotr c1=intList.begin()      <span class="comment">// *c1=1;</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;iteraotr c2=intList.end()         <span class="comment">// *c2=right_null;</span></div></pre></td></tr></table></figure></p>
<pre><code>尾&lt;-1&lt;-2&lt;-3&lt;-4
</code></pre><p><code>iterator++</code>,则对于上边正向链表从左向右遍历<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*(--c2)=<span class="number">4</span>;</div><div class="line"><span class="keyword">for</span>(c1=.begin(),c1!=.end();c1++)</div><div class="line">       <span class="built_in">cout</span>&lt;&lt;..<span class="number">.1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;reverse_iteraotr c1=intList.rbegin()      <span class="comment">// *c1=4;   rbegin:相当于reverse_begin即反着看的头</span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;reverse_iteraotr c1=intList.rend()         <span class="comment">// *c1=left_null; rend相当于reverse_end即反着看的尾</span></div></pre></td></tr></table></figure></p>
<p><code>reverse_iterator++</code>,则对于上边正向链表从右向左遍历.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*(--c2)=<span class="number">1</span>;</div><div class="line"><span class="keyword">for</span>(c2=.rbegin();r2!=.rend();c2++)</div></pre></td></tr></table></figure></p>
<p>相当于:4 3 2 1</p>
<p>####bind1st和bind2nd函数<br><code>bind1st</code>和<code>bind2nd</code>函数用于将一个二元算子（binary functor，bf）转换成一元算子（unary functor，uf）。为了达到这个目的，它们需要两个参数：要转换的bf和一个值（v）。</p>
<p>值（v）是一个固定的参数。换言之，uf(x)等价于：</p>
<p>bf( x, v) – 当使用bind2nd时<br>bf( v, x) – 当使用bind1st时<br>bind1st和bind2nd函数在处理谓词时非常有用。它们使得二元谓词能够转换成一元谓词；这常用于将一个范围内的所有值与一个特定的值比较：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">int</span>&gt; a;</div><div class="line"><span class="comment">// ……填充a</span></div><div class="line"><span class="comment">// 移除所有小于30的元素</span></div><div class="line">a.erase( <span class="built_in">std</span>::remove_if( a.begin(), a.end(),</div><div class="line">    <span class="built_in">std</span>::bind2nd( <span class="built_in">std</span>::less&lt; <span class="keyword">int</span>&gt;(), <span class="number">30</span>)), a.end());</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/11/02/-Boost-在XCode安装Boost/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/02/-Boost-在XCode安装Boost/" itemprop="url">
                  [Boost]在XCode安装Boost
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-11-02T08:57:50+08:00">
              2014-11-02
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/02/-Boost-在XCode安装Boost/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/02/-Boost-在XCode安装Boost/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/maomi.jpg" rel="gallery_cixjz0my600775nti60vj2f33"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/maomi.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <p>##下载Boost库<br>最新的版本可以在<a href="http://www.boost.org/" target="_blank" rel="external">http://www.boost.org/</a>找到，这里我下载的1.56.0版本，<a href="http://jaist.dl.sourceforge.net/project/boost/boost/1.56.0/boost_1_56_0.tar.gz" target="_blank" rel="external">Download</a></p>
<p>##编译Boost.Build<br>修改sh的文件属性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x bootstrap.sh</div></pre></td></tr></table></figure></p>
<p>执行bootstrap.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bootstrap.sh</div></pre></td></tr></table></figure></p>
<p>##编译Boost库<br>执行b2可执行程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//用Clang编译boost file sytem</div><div class="line">./b2 toolset=clang cxxflags=<span class="string">"-arch x86_64"</span> linkflags=<span class="string">"-arch x86_64"</span> --with-filesystem</div></pre></td></tr></table></figure></p>
<p>最后生成的文件保存在./stage/lib目录</p>
<p>默认编译出来的是Release版本，编译debug版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./b2 toolset=clang cxxflags=<span class="string">"-arch x86_64"</span> linkflags=<span class="string">"-arch x86_64"</span> --with-filesystem variant=debug --stagedir=./stage/x64/debug</div></pre></td></tr></table></figure></p>
<p>##设置XCode<br>在 XCode 中，打开项目后 Build settings：<br>在中  Users Headers Search Paths 中添加，例如：/Users/Shared/boost_1_46_1</p>
<p>在Library Search Paths 中添加 /Users/Shared/include</p>
<p>##重新编译<br>重新编译就可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/11/01/-LeetCode-Exercise-Day1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/01/-LeetCode-Exercise-Day1/" itemprop="url">
                  [LeetCode]Exercise(Day1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-11-01T15:34:59+08:00">
              2014-11-01
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/01/-LeetCode-Exercise-Day1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/01/-LeetCode-Exercise-Day1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Remove Duplicates from Sorted Array</p>
<p>###问题描述<br>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.<br>Do not allocate extra space for another array, you must do this in place with constant memory.<br>For example, Given input array A = [1,1,2],<br>Your function should return length = 2, and A is now [1,2].</p>
<p>###解决方案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (A[index] != A[i]) &#123;</div><div class="line">            A[++index] = A[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> index+<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###扩展阅读<br>在编代码的时候看到了一种实现是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LeetCode, Remove Duplicates from Sorted Array </span></div><div class="line"><span class="comment">// 使用 STL,时间复杂度 O(n),空间复杂度 O(1) class Solution &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> removeDuplicates(A, A + n, A) - A;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InIt, <span class="keyword">typename</span> OutIt&gt;</div><div class="line">      <span class="function">OutIt <span class="title">removeDuplicates</span><span class="params">(InIt first, InIt last, OutIt output)</span> </span>&#123;</div><div class="line">          <span class="keyword">while</span> (first != last) &#123;</div><div class="line">              *output++ = *first;</div><div class="line">              first = upper_bound(first, last, *first);</div><div class="line">            &#125;</div><div class="line">          <span class="keyword">return</span> output;</div><div class="line">      &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在XCode上面编译会报错”Use of undeclared identifier ‘upder_bound’”，顺便查了下<code>upper_bound</code>的用法；<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iterator lower_bound( const key_type &amp;key ): //返回一个迭代器，指向键值&gt;= key的第一个元素。</div><div class="line">iterator upper_bound( const key_type &amp;key )://返回一个迭代器，指向键值&gt; key的第一个元素。</div></pre></td></tr></table></figure></p>
<p>以下是测试用例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;mapStudent;</div><div class="line">mapStudent[<span class="number">1</span>]=<span class="string">"student_one"</span>;</div><div class="line">mapStudent[<span class="number">3</span>]=<span class="string">"student_three"</span>;</div><div class="line">mapStudent[<span class="number">5</span>]=<span class="string">"student_five"</span>;</div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</div><div class="line">iter=mapStudent.lower_bound(<span class="number">2</span>);</div><div class="line">&#123;</div><div class="line">    <span class="comment">//返回的是下界3的迭代器</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">iter=mapStudent.lower_bound(<span class="number">3</span>);</div><div class="line">&#123;</div><div class="line">    <span class="comment">//返回的是下界3的迭代器</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">iter=mapStudent.upper_bound(<span class="number">2</span>);</div><div class="line">&#123;</div><div class="line">    <span class="comment">//返回的是上界3的迭代器</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">iter=mapStudent.upper_bound(<span class="number">3</span>);</div><div class="line">&#123;</div><div class="line">    <span class="comment">//返回的是上界5的迭代器</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">student_three</div><div class="line">student_three</div><div class="line">student_three</div><div class="line">student_five</div></pre></td></tr></table></figure></p>
<p>##Remove Duplicates from Sorted Array II</p>
<p>###问题描述<br>Follow up for ”Remove Duplicates”: What if duplicates are allowed at most twice? For example, Given sorted array A = [1,1,1,2,2,3],<br>Your function should return length = 5, and A is now [1,1,2,2,3]</p>
<p>###解决方案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LeetCode, Remove Duplicates from Sorted Array II // 时间复杂度 O(n),空间复杂度 O(1)</span></div><div class="line"><span class="comment">// @author hex108 (https://github.com/hex108) class Solution &#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</div><div class="line">          <span class="keyword">int</span> index = <span class="number">2</span>;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</div><div class="line">              <span class="keyword">if</span> (A[i] != A[index - <span class="number">2</span>])</div><div class="line">                  A[index++] = A[i];</div><div class="line">&#125;</div><div class="line">          <span class="keyword">return</span> index;</div><div class="line">      &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>期间自己写了一个解决方法，太冗长，不好理解，贴出代码，已被以后反省。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> repeatCount = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (A[index] == A[i]) &#123;</div><div class="line">        repeatCount++;</div><div class="line">        <span class="keyword">if</span> (repeatCount &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            A[++index] = A[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        repeatCount = <span class="number">0</span>;</div><div class="line">        A[++index] = A[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> index+<span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>##Search in Rotated Sorted Array</p>
<p>###问题描述<br>Suppose a sorted array is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array.</p>
<p>###解决方法<br>解决方法就是努力找到有顺序的一边，然后根据所要查找的数字进行二分查找。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> high = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</div><div class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (target == A[mid]) &#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (A[low] &lt; A[mid])&#123;</div><div class="line">                <span class="keyword">if</span> (A[low] &lt;= target &amp;&amp; target &lt; A[mid]) &#123;</div><div class="line">                    high = mid - <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    low = mid + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span> (target &gt; A[mid] &amp;&amp; target &lt;= A[high])                 &#123;</div><div class="line">                    low = mid + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    high = mid - <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>之前写得另外一段程序，也列出来，以后进行比对，效率和理解性上不及上一个程序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</div><div class="line">        <span class="keyword">if</span> (A[low] &gt;= A[high]) &#123;</div><div class="line">            <span class="keyword">if</span> (target &gt; A[high] &amp;&amp; target &lt; A[low]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (target == A[mid]) &#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; A[mid])&#123;</div><div class="line">                <span class="keyword">if</span> (target &gt;= A[low]) &#123;</div><div class="line">                    high = mid - <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    low = mid + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; A[mid])&#123;</div><div class="line">                low = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (target == A[mid]) &#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; A[mid])&#123;</div><div class="line">                high = mid - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                low = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##Longest Consecutive Sequence</p>
<p>###问题描述<br>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.<br>For example, Given [100, 4, 200, 1, 3, 2], The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.<br>Your algorithm should run in O(n) complexity.</p>
<p>###解决方法<br>看到时间复杂度要求O(n)，第一直觉就是要用数据结构来保存相应信息来索引，开始没想出来，后来看了提示，用HashMap来保存相应信息，当时想到的是算hash值以后，在存hash值的时候，再遍历以存储的数值，计算出最大的连续序列。开始方向错掉了，后来看了提示，取到某值，先看齐前面一个值是否存在，然后再更新后面的值，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 100, 4, 200, 1, 3, 2</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (num.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">size_t</span> count = num.size();</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; lRecords;</div><div class="line">        </div><div class="line">        <span class="comment">// update the map</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="keyword">int</span> key = num[i];</div><div class="line">            <span class="keyword">int</span> pre = key - <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> length = lRecords[pre];</div><div class="line">            lRecords[key] = ++length;</div><div class="line">            </div><div class="line">            <span class="comment">// update next</span></div><div class="line">            <span class="keyword">int</span> next = key + <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (lRecords[next] != <span class="number">0</span>) &#123;</div><div class="line">                lRecords[next] = ++length;</div><div class="line">                next++;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (length &gt; result) &#123;</div><div class="line">                result = length;</div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>因为这篇里面运用到了Boost的unordered_map,索性就百度了下unorderred_map和map的区别：</p>
<p>###扩展阅读<br><code>boost::unordered_map</code>， 它与 <code>stl::map</code>的区别就是，<code>stl::map</code>是按照operator&lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&lt; 定义的大小排序。</p>
<p>而<code>boost::unordered_map</code>是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对<code>unordered_map</code>进行遍历，结果是无序的。</p>
<p>用法的区别就是，stl::map 的key需要定义operator&lt; 。 而<code>boost::unordered_map</code>需要定义<code>hash_value</code>函数并且重载<code>operator==</code>。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator&lt; 或者<code>hash_value()</code>了。 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/31/KVO和KVC读书笔记（一）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/31/KVO和KVC读书笔记（一）/" itemprop="url">
                  KVO和KVC读书笔记（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-31T21:53:19+08:00">
              2014-10-31
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/31/KVO和KVC读书笔记（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/31/KVO和KVC读书笔记（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="/uploads/header/meinv.jpg" rel="gallery_cixjz0my400735nti8pywhpip"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="/uploads/header/meinv.jpg" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <p>转自：<a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">http://objccn.io/issue-7-3/</a></p>
<p>Key-value coding (KVC) 和 key-value observing (KVO) 是两种能让我们驾驭 Objective-C 动态特性并简化代码的机制。在这篇文章里，我们将接触一些如何利用这些特性的例子。</p>
<p>##观察 model 对象的变化<br>在 Cocoa 的模型-视图-控制器 (Model-view-controller)架构里，控制器负责让视图和模型同步。这一共有两步：当 model 对象改变的时候，视图应该随之改变以反映模型的变化；当用户和控制器交互的时候，模型也应该做出相应的改变。</p>
<p>KVO 能帮助我们让视图和模型保持同步。控制器可以观察视图依赖的属性变化。</p>
<p>让我们看一个例子：我们的模型类 LabColor 代表一种 Lab色彩空间里的颜色。和 RGB 不同，这种色彩空间有三个元素 L, a, b。我们要做一个用来改变这些值的滑块和一个显示颜色的方块区域。</p>
<p>我们的模型类有以下三个用来代表颜色的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> lComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> aComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> bComponent;</div></pre></td></tr></table></figure>
<p>##依赖的属性<br>我们需要从这个类创建一个 UIColor 对象来显示出颜色。我们添加三个额外的属性，分别对应 R, G, B：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> redComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> greenComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> blueComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *color;</div></pre></td></tr></table></figure>
<p>有了这些以后，我们就可以创建这个类的接口了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LabColor</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> lComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> aComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> bComponent;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> redComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> greenComponent;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> blueComponent;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *color;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><a href="http://www.baidu.com" target="_blank" rel="external">维基百科</a>提供了转换 RGB 到 Lab 色彩空间的算法。写成方法之后如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">double</span>)greenComponent;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> D65TristimulusValues[<span class="number">1</span>] * inverseF(<span class="number">1.</span>/<span class="number">116.</span> * (<span class="keyword">self</span>.lComponent + <span class="number">16</span>) + <span class="number">1.</span>/<span class="number">500.</span> * <span class="keyword">self</span>.aComponent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[...]</div><div class="line"></div><div class="line">- (<span class="built_in">UIColor</span> *)color</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">UIColor</span> colorWithRed:<span class="keyword">self</span>.redComponent * <span class="number">0.01</span> green:<span class="keyword">self</span>.greenComponent * <span class="number">0.01</span> blue:<span class="keyword">self</span>.blueComponent * <span class="number">0.01</span> alpha:<span class="number">1.</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些代码没什么令人激动的地方。有趣的是<code>greenComponent</code> 属性依赖于<code>lComponent</code>和<code>aComponent</code>。不论何时设置 <code>lComponent</code>的值，我们需要让 RGB 三个 component 中与其相关的成员以及 color 属性都要得到通知以保持一致。这一点这在 KVO 中很重要。</p>
<p>Foundation 框架提供的表示属性依赖的机制如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>更详细的如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffecting&lt;键名&gt;</div></pre></td></tr></table></figure></p>
<p>在我们的例子中如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingRedComponent</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"lComponent"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingGreenComponent</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lComponent"</span>, <span class="string">@"aComponent"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingBlueComponent</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lComponent"</span>, <span class="string">@"bComponent"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingColor</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"redComponent"</span>, <span class="string">@"greenComponent"</span>, <span class="string">@"blueComponent"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们完整的表达了属性之间的依赖关系。请注意，我们可以把这些属性链接起来。打个比方，如果我们写一个子类去 override <code>redComponent</code> 方法，这些依赖关系仍然能正常工作。</p>
<blockquote>
<p>[Nan]:这个是系统回调函数，在这边提供依赖的关系，SDK会建立依赖关系链；比如color-&gt;redComponent-&gt;lComponent,当lComponent改变时，最终会影响到color。</p>
</blockquote>
<p>##观察变化<br>现在让我们目光转向控制器。<code>NSViewController</code>的子类拥有 LabColor model 对象作为其属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) LabColor *labColor;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们把视图控制器注册为观察者来接收 KVO 的通知，这可以用以下 NSObject 的方法来实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>这会让以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>在当 keyPath 的值改变的时候在观察者 anObserver 上面被调用。这个 API 看起来有一点吓人。更糟糕的是，我们还得记得调用以下的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div></pre></td></tr></table></figure>
<p>来移除观察者，否则我们我们的 app 会因为某些奇怪的原因崩溃。</p>
<p>对于大多数的应用来说，KVO 可以通过辅助类用一种更简单优雅的方式实现。我们在视图控制器添加以下的观察记号（Observation token）属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> colorObserveToken;</div></pre></td></tr></table></figure>
<p>当 labColor 在视图控制器中被设置时，我们只要 override labColor 的 setter 方法就行了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setLabColor:(LabColor *)labColor</div><div class="line">&#123;</div><div class="line">    _labColor = labColor;</div><div class="line">    <span class="keyword">self</span>.colorObserveToken = [KeyValueObserver observeObject:labColor                                               keyPath:<span class="string">@"color"</span>                                            target:<span class="keyword">self</span>                                          selector:<span class="keyword">@selector</span>(colorDidChange:)                                        options:<span class="built_in">NSKeyValueObservingOptionInitial</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)colorDidChange:(<span class="built_in">NSDictionary</span> *)change;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.colorView.backgroundColor = <span class="keyword">self</span>.labColor.color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>KeyValueObserver 辅助类 封装了<code>-addObserver:forKeyPath:options:context:，-observeValueForKeyPath:ofObject:change:context:和-removeObserverForKeyPath:</code>的调用，让视图控制器远离杂乱的代码。</p>
<blockquote>
<p>[Nan]:以后可以尝试应用此方法，当需要addObserver/removeObserver的时候，可以定义一个类，专门来控制添加删除的操作。</p>
</blockquote>
<p>##整合到一起<br>视图控制器需要对 L，a，b 的滑块控制做出反应：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)updateLComponent:(<span class="built_in">UISlider</span> *)sender;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.labColor.lComponent = sender.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)updateAComponent:(<span class="built_in">UISlider</span> *)sender;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.labColor.aComponent = sender.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)updateBComponent:(<span class="built_in">UISlider</span> *)sender;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.labColor.bComponent = sender.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所有的代码都在我们的 GitHub <a href="https://github.com/objcio/issue-7-lab-color-space-explorer" target="_blank" rel="external">示例代码</a> 中找到。</p>
<p>##手动通知 vs 自动通知<br>我们刚才所做的事情有点神奇，但是实际上发生的事情是，当 LabColor 实例的 -setLComponent: 等方法被调用的时候以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>和：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>会在运行 <code>-setLComponent:</code> 中的代码之前以及之后被自动调用。如果我们写了 -setLComponent: 或者我们选择使用自动 synthesize 的 lComponent 的 accessor 到时候就会发生这样的事情。</p>
<p>有些情况下当我们需要 override -setLComponent: 并且我们要控制是否发送键值改变的通知的时候，我们要做以下的事情：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//此方法关闭了lComponent得自动通知功能</span></div><div class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForLComponent;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setLComponent:(<span class="keyword">double</span>)lComponent;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_lComponent == lComponent) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"lComponent"</span>];</div><div class="line">    _lComponent = lComponent;</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"lComponent"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们关闭了 <code>-willChangeValueForKey:</code>和 <code>-didChangeValueForKey:</code> 的自动调用，然后我们手动调用他们。我们只应该在关闭了自动调用的时候我们才需要在 setter 方法里手动调用 <code>-willChangeValueForKey:</code>和 <code>-didChangeValueForKey:</code>。大多数情况下，这样优化不会给我们带来太多好处。</p>
<p>如果我们在 accessor 方法之外改变实例对象（如 _lComponent ），我们要特别小心地和刚才一样封装 -willChangeValueForKey: 和 -didChangeValueForKey:。不过在多数情况下，我们只用 accessor 方法的话就可以了，这样代码会简洁很多。</p>
<blockquote>
<p>[Nan]:如果在添加observer的时候用参数<code>NSKeyValueObservingOptionPrior</code>的话，再加上手动发送消息，就会受到2此相同的信息。</p>
</blockquote>
<p>##KVO 和 context<br>有时我们会有理由不想用 KeyValueObserver 辅助类。创建另一个对象会有额外的性能开销。如果我们观察很多个键的话，这个开销可能会变得明显。</p>
<p>如果我们在实现一个类的时候把它自己注册为观察者的话：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>一个非常重要的点是我们要传入一个这个类唯一的 <code>context</code>。我们推荐把以下代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> PrivateKVOContext;</div></pre></td></tr></table></figure>
<p>写在这个类 .m 文件的顶端，然后我们像这样调用 API 并传入 <code>PrivateKVOContext</code> 的指针：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[otherObject addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"someKey"</span> options:someOptions context:&amp;PrivateKVOContext];</div></pre></td></tr></table></figure>
<p>然后我们这样写 <code>-observeValueForKeyPath:...</code> 的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (context == &amp;PrivateKVOContext) &#123;</div><div class="line">        <span class="comment">// 这里写相关的观察代码</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将确保我们写的子类都是正确的。如此一来，子类和父类都能安全的观察同样的键值而不会冲突。否则我们将会碰到难以 debug 的奇怪行为。</p>
<p>##进阶 KVO<br>我们常常需要当一个值改变的时候更新 UI，但是我们也要在第一次运行代码的时候更新一次 UI。我们可以用 KVO 并添加<code>NSKeyValueObservingOptionInitial</code>的选项 来一箭双雕地做好这样的事情。这将会让 KVO 通知在调用 <code>-addObserver:forKeyPath:...</code>到时候也被触发。</p>
<p>###之前和之后<br>当我们注册 KVO 通知的时候，我们可以添加 <code>NSKeyValueObservingOptionPrior</code> 选项，这能使我们在键值改变之前被通知。这和<code>-willChangeValueForKey:</code>被触发的时间相对应。</p>
<p>如果我们注册通知的时候附加了 <code>NSKeyValueObservingOptionPrior</code> 选项，我们将会收到两个通知：一个在值变更前，另一个在变更之后。变更前的通知将会在 change 字典中有不同的键。我们可以像以下这样区分通知是在改变之前还是之后被触发的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNotificationIsPriorKey</span>] boolValue]) &#123;</div><div class="line">    <span class="comment">// 改变之前</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 改变之后</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###值<br>如果我们需要改变前后的值，我们可以在 KVO 选项中加入 <code>NSKeyValueObservingOptionNew</code>和/或 <code>NSKeyValueObservingOptionOld</code>。</p>
<p>更简单的办法是用 <code>NSKeyValueObservingOptionPrior</code> 选项，随后我们就可以用以下方式提取出改变前后的值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> oldValue = change[<span class="built_in">NSKeyValueChangeOldKey</span>];</div><div class="line"><span class="keyword">id</span> newValue = change[<span class="built_in">NSKeyValueChangeNewKey</span>];</div></pre></td></tr></table></figure>
<p>通常来说 KVO 会在<code>-willChangeValueForKey:</code> 和 <code>-didChangeValueForKey:</code> 被调用的时候存储相应键的值。</p>
<p>##索引<br>KVO 对一些集合类也有很强的支持，以下方法会返回集合对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-mutableArrayValueForKey:</div><div class="line">-mutableSetValueForKey:</div><div class="line">-mutableOrderedSetValueForKey:</div></pre></td></tr></table></figure></p>
<p>我们将会详细解释这是怎么工作的。如果你使用这些方法，change 字典里会包含键值变化的类型（添加、删除和替换）。对于有序的集合，change 字典会包含受影响的 index。</p>
<p>集合代理对象和变化的通知在用于更新UI的时候非常有效，尤其是处理大集合的时候。但是它们需要花费你一些心思。</p>
<p>##KVO 和线程<br>一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。没有队列或者 Run-loop 的处理。手动或者自动调用 -didChange… 会触发 KVO 通知。</p>
<p>所以，当我们试图从其他线程改变属性值的时候我们应当十分小心，除非能确定所有的观察者都用线程安全的方法处理 KVO 通知。通常来说，我们不推荐把 KVO 和多线程混起来。如果我们要用多个队列和线程，我们不应该在它们互相之间用 KVO。</p>
<p>KVO 是同步运行的这个特性非常强大，只要我们在单一线程上面运行（比如主队列 main queue），KVO 会保证下列两种情况的发生：</p>
<p>首先，如果我们调用一个支持 KVO 的 setter 方法，如下所示：</p>
<p>self.exchangeRate = 2.345;<br>KVO 能保证所有 exchangeRate 的观察者在 setter 方法返回前被通知到。</p>
<p>其次，如果某个键被观察的时候附上了 NSKeyValueObservingOptionPrior 选项，直到 -observe… 被调用之前， exchangeRate 的 accessor 方法都会返回同样的值。</p>
<p>KVC<br>最简单的 KVC 能让我们通过以下的形式访问属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div></pre></td></tr></table></figure></p>
<p>取值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *n = [object valueForKey:<span class="string">@"name"</span>]</div></pre></td></tr></table></figure></p>
<p>设定：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:<span class="string">@"Daniel"</span> forKey:<span class="string">@"name"</span>]</div></pre></td></tr></table></figure></p>
<p>值得注意的是这个不仅可以访问作为对象属性，而且也能访问一些标量（例如 int 和 CGFloat）和 struct（例如 CGRect）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> height;</div></pre></td></tr></table></figure></p>
<p>我们可以这样设置它：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:@(<span class="number">20</span>) forKey:<span class="string">@"height"</span>]</div></pre></td></tr></table></figure></p>
<p>KVC 允许我们用属性的字符串名称来访问属性，字符串在这儿叫做键。有些情况下，这会使我们非常灵活地简化代码。我们下一节介绍例子简化列表 UI。</p>
<p>KVC 还有更多可以谈的。集合（NSArray，NSSet 等）结合 KVC 可以拥有一些强大的集合操作。还有，对象可以支持用 KVC 通过代理对象访问非常规的属性。</p>
<p>##简化列表 UI<br>假设我们有这样一个对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Contact</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickname;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *email;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *city;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>还有一个 detail 视图控制器，含有四个对应的 UITextField 属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DetailViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *nameField;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *nicknameField;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *emailField;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *cityField;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们可以简化更新 UI 的逻辑。首先我们需要两个方法：一个返回 model 里我们用到的所有键的方法，一个把键映射到对应的文本框的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)contactStringKeys;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>, <span class="string">@"nickname"</span>, <span class="string">@"email"</span>, <span class="string">@"city"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UITextField</span> *)textFieldForModelKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> valueForKey:[key stringByAppendingString:<span class="string">@"Field"</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了这个，我们可以从 model 里更新文本框，如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updateTextFields;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> <span class="keyword">self</span>.contactStringKeys) &#123;</div><div class="line">        [<span class="keyword">self</span> textFieldForModelKey:key].text = [<span class="keyword">self</span>.contact valueForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也可以用一个 action 方法让四个文本框都能实时更新 model：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)fieldEditingDidEnd:(<span class="built_in">UITextField</span> *)sender</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> <span class="keyword">self</span>.contactStringKeys) &#123;</div><div class="line">        <span class="built_in">UITextField</span> *field = [<span class="keyword">self</span> textFieldForModelKey:key];</div><div class="line">        <span class="keyword">if</span> (field == sender) &#123;</div><div class="line">            [<span class="keyword">self</span>.contact setValue:sender.text forKey:key];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：我们之后会添加验证输入的部分，在键值验证里会提到。</p>
<p>最后，我们需要确认文本框在需要的时候被更新：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</div><div class="line">    [<span class="keyword">self</span> updateTextFields];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setContact:(Contact *)contact</div><div class="line">&#123;</div><div class="line">    _contact = contact;</div><div class="line">    [<span class="keyword">self</span> updateTextFields];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了这个，我们的 detail 视图控制器 就能正常工作了。</p>
<p>整个项目可以在 <a href="https://github.com/objcio/issue-7-contact-editor" target="_blank" rel="external">GitHub</a> 上找到。它也用了我们后面提到的键值验证。</p>
<p>###键路径（Key Path）<br>KVC 同样允许我们通过关系来访问对象。假设 person 对象有属性 address，address 有属性 city，我们可以这样通过 person 来访问 city：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person valueForKeyPath:<span class="string">@"address.city"</span>]</div></pre></td></tr></table></figure></p>
<p>值得注意的是这里我们调用 <code>-valueForKeyPath:</code> 而不是 <code>-valueForKey:</code>。</p>
<p>##Key-Value Coding Without @property<br>不需要 @property 的 KVC<br>我们可以实现一个支持 KVC 而不用 @property 和 @synthesize 或是自动 synthesize 的属性。最直接的方式是添加 -<key> 和 -set<key>: 方法。例如我们想要 name ，我们这样做：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)name;</div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</div></pre></td></tr></table></figure></key></key></p>
<p>这完全等于 @property 的实现方式。</p>
<p>但是当标量和 struct 的值被传入 nil 的时候尤其需要注意。假设我们要 height 属性支持 KVC 我们写了以下的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)height;</div><div class="line">- (<span class="keyword">void</span>)setHeight:(<span class="built_in">CGFloat</span>)height;</div></pre></td></tr></table></figure></p>
<p>然后我们这样调用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:<span class="literal">nil</span> forKey:<span class="string">@"height"</span>]</div></pre></td></tr></table></figure></p>
<p>这会抛出一个 exception。要正确的处理 nil，我们要像这样 override <code>-setNilValueForKey:</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"height"</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> setValue:@<span class="number">0</span> forKey:key];</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        [<span class="keyword">super</span> setNilValueForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以通过 override 这些方法来让一个类支持 KVC：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure></p>
<p>这也许看起来很怪，但这可以让一个类动态的支持一些键的访问。但是这两个方法会在性能上拖后腿。</p>
<p>附注：Foundation 框架支持直接访问实例变量。请小心的使用这个特性。你可以去查看 +accessInstanceVariablesDirectly 的文档。这个值默认是 YES 的时候，Foundation 会按照 _<key>, _is<key>, <key> 和 is<key> 的顺序查找实例变量。</key></key></key></key></p>
<p>###集合的操作<br>一个常常被忽视的 KVC 特性是它对集合操作的支持。举个例子，我们可以这样来获得一个数组中最大的值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *a = @[@<span class="number">4</span>, @<span class="number">84</span>, @<span class="number">2</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"max = %@"</span>, [a valueForKeyPath:<span class="string">@"@max.self"</span>]);</div></pre></td></tr></table></figure></p>
<p>或者说，我们有一个 Transaction 对象的数组，对象有属性 amount 的话，我们可以这样获得最大的 amount：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *a = @[transaction1, transaction2, transaction3];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"max = %@"</span>, [a valueForKeyPath:<span class="string">@"@max.amount"</span>]);</div></pre></td></tr></table></figure></p>
<p>当我们调用<code>[a valueForKeyPath:@&quot;@max.amount&quot;]</code> 的时候，它会在数组 a 的每个元素中调用 <code>-valueForKey:@&quot;amount&quot;</code>然后返回最大的那个。</p>
<p>KVC 的苹果官方文档有一个章节 Collection Operators 详细的讲述了类似的用法。</p>
<p>通过集合代理对象来实现 KVC<br>虽然我们可以像对待一般的对象一样用 KVC 深入集合内部（NSArray 和 NSSet 等），但是通过集合代理对象， KVC 也让我们实现一个兼容 KVC 的集合。这是一个颇为高端的技巧。</p>
<p>当我们在对象上调用 -valueForKey: 的时候，它可以返回 NSArray，NSSet 或是 NSOrderedSet 的集合代理对象。这个类没有实现通常的 -<key> 方法，但是它实现了代理对象所需要使用的很多方法。</key></p>
<p>如果我们希望一个类支持通过代理对象的 contacts 键返回一个 NSArray，我们可以这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)countOfContacts;</div><div class="line">- (<span class="keyword">id</span>)objectInContactsAtIndex:(<span class="built_in">NSUInteger</span>)idx;</div></pre></td></tr></table></figure></p>
<p>这样做的话，当我们调用 [object valueForKey:@”contacts”] 的时候，它会返回一个由这两个方法来代理所有调用方法的 NSArray 对象。这个数组支持所有正常的对 NSArray 的调用。换句话说，调用者并不知道返回的是一个真正的 NSArray， 还是一个代理的数组。</p>
<p>对于 NSSet 和 NSOrderedSet，如果要做同样的事情，我们需要实现的方法是：</p>
<table>
<thead>
<tr>
<th>NSArray</th>
<th>NSSet</th>
<th>NSOrderedSet   </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-countOf&lt;Key&gt;</code></td>
<td><code>-countOf&lt;Key&gt;</code></td>
<td><code>-countOf&lt;Key&gt;</code></td>
</tr>
<tr>
<td>-</td>
<td><code>-enumeratorOf&lt;Key&gt;</code></td>
<td><code>-indexIn&lt;Key&gt;OfObject:</code></td>
</tr>
<tr>
<td> -</td>
<td><code>-memberOf&lt;Key&gt;:</code></td>
<td>-</td>
</tr>
<tr>
<td>以下两者二选一</td>
<td>-</td>
<td>以下两者二选一</td>
</tr>
<tr>
<td><code>-objectIn&lt;Key&gt;AtIndex:</code></td>
<td>-</td>
<td><code>-objectIn&lt;Key&gt;AtIndex:</code></td>
</tr>
<tr>
<td><code>-&lt;key&gt;AtIndexes:</code></td>
<td>-</td>
<td><code>-&lt;key&gt;AtIndexes:</code>     </td>
</tr>
<tr>
<td>可选（增强性能）</td>
<td>-</td>
<td>可选（增强性能）</td>
</tr>
<tr>
<td><code>-get&lt;Key&gt;:range:</code></td>
<td>-</td>
<td><code>-get&lt;Key&gt;:range:</code></td>
</tr>
</tbody>
</table>
<p>可选 的一些方法可以增强代理对象的性能。</p>
<p>虽然只有特殊情况下我们用这些代理对象才会有意义，但是在这些情况下代理对象非常的有用。想象一下我们有一个很大的数据结构，调用者不需要（一次性）访问所有的对象。</p>
<p>举一个（也许比较做作的）例子说，我们想写一个包含有很长一串质数的类。如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Primes</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *primes;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Primes</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> int32_t <span class="keyword">const</span> primes[] = &#123;</div><div class="line">    <span class="number">2</span>, <span class="number">101</span>, <span class="number">233</span>, <span class="number">383</span>, <span class="number">3</span>, <span class="number">103</span>, <span class="number">239</span>, <span class="number">389</span>, <span class="number">5</span>, <span class="number">107</span>, <span class="number">241</span>, <span class="number">397</span>, <span class="number">7</span>, <span class="number">109</span>,</div><div class="line">    <span class="number">251</span>, <span class="number">401</span>, <span class="number">11</span>, <span class="number">113</span>, <span class="number">257</span>, <span class="number">409</span>, <span class="number">13</span>, <span class="number">127</span>, <span class="number">263</span>, <span class="number">419</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">269</span>,</div><div class="line">    <span class="number">421</span>, <span class="number">19</span>, <span class="number">137</span>, <span class="number">271</span>, <span class="number">431</span>, <span class="number">23</span>, <span class="number">139</span>, <span class="number">277</span>, <span class="number">433</span>, <span class="number">29</span>, <span class="number">149</span>, <span class="number">281</span>, <span class="number">439</span>,</div><div class="line">    <span class="number">31</span>, <span class="number">151</span>, <span class="number">283</span>, <span class="number">443</span>, <span class="number">37</span>, <span class="number">157</span>, <span class="number">293</span>, <span class="number">449</span>, <span class="number">41</span>, <span class="number">163</span>, <span class="number">307</span>, <span class="number">457</span>, <span class="number">43</span>,</div><div class="line">    <span class="number">167</span>, <span class="number">311</span>, <span class="number">461</span>, <span class="number">47</span>, <span class="number">173</span>, <span class="number">313</span>, <span class="number">463</span>, <span class="number">53</span>, <span class="number">179</span>, <span class="number">317</span>, <span class="number">467</span>, <span class="number">59</span>, <span class="number">181</span>,</div><div class="line">    <span class="number">331</span>, <span class="number">479</span>, <span class="number">61</span>, <span class="number">191</span>, <span class="number">337</span>, <span class="number">487</span>, <span class="number">67</span>, <span class="number">193</span>, <span class="number">347</span>, <span class="number">491</span>, <span class="number">71</span>, <span class="number">197</span>, <span class="number">349</span>,</div><div class="line">    <span class="number">499</span>, <span class="number">73</span>, <span class="number">199</span>, <span class="number">353</span>, <span class="number">503</span>, <span class="number">79</span>, <span class="number">211</span>, <span class="number">359</span>, <span class="number">509</span>, <span class="number">83</span>, <span class="number">223</span>, <span class="number">367</span>, <span class="number">521</span>,</div><div class="line">    <span class="number">89</span>, <span class="number">227</span>, <span class="number">373</span>, <span class="number">523</span>, <span class="number">97</span>, <span class="number">229</span>, <span class="number">379</span>, <span class="number">541</span>, <span class="number">547</span>, <span class="number">701</span>, <span class="number">877</span>, <span class="number">1049</span>,</div><div class="line">    <span class="number">557</span>, <span class="number">709</span>, <span class="number">881</span>, <span class="number">1051</span>, <span class="number">563</span>, <span class="number">719</span>, <span class="number">883</span>, <span class="number">1061</span>, <span class="number">569</span>, <span class="number">727</span>, <span class="number">887</span>,</div><div class="line">    <span class="number">1063</span>, <span class="number">571</span>, <span class="number">733</span>, <span class="number">907</span>, <span class="number">1069</span>, <span class="number">577</span>, <span class="number">739</span>, <span class="number">911</span>, <span class="number">1087</span>, <span class="number">587</span>, <span class="number">743</span>,</div><div class="line">    <span class="number">919</span>, <span class="number">1091</span>, <span class="number">593</span>, <span class="number">751</span>, <span class="number">929</span>, <span class="number">1093</span>, <span class="number">599</span>, <span class="number">757</span>, <span class="number">937</span>, <span class="number">1097</span>, <span class="number">601</span>,</div><div class="line">    <span class="number">761</span>, <span class="number">941</span>, <span class="number">1103</span>, <span class="number">607</span>, <span class="number">769</span>, <span class="number">947</span>, <span class="number">1109</span>, <span class="number">613</span>, <span class="number">773</span>, <span class="number">953</span>, <span class="number">1117</span>,</div><div class="line">    <span class="number">617</span>, <span class="number">787</span>, <span class="number">967</span>, <span class="number">1123</span>, <span class="number">619</span>, <span class="number">797</span>, <span class="number">971</span>, <span class="number">1129</span>, <span class="number">631</span>, <span class="number">809</span>, <span class="number">977</span>,</div><div class="line">    <span class="number">1151</span>, <span class="number">641</span>, <span class="number">811</span>, <span class="number">983</span>, <span class="number">1153</span>, <span class="number">643</span>, <span class="number">821</span>, <span class="number">991</span>, <span class="number">1163</span>, <span class="number">647</span>, <span class="number">823</span>,</div><div class="line">    <span class="number">997</span>, <span class="number">1171</span>, <span class="number">653</span>, <span class="number">827</span>, <span class="number">1009</span>, <span class="number">1181</span>, <span class="number">659</span>, <span class="number">829</span>, <span class="number">1013</span>, <span class="number">1187</span>, <span class="number">661</span>,</div><div class="line">    <span class="number">839</span>, <span class="number">1019</span>, <span class="number">1193</span>, <span class="number">673</span>, <span class="number">853</span>, <span class="number">1021</span>, <span class="number">1201</span>, <span class="number">677</span>, <span class="number">857</span>, <span class="number">1031</span>,</div><div class="line">    <span class="number">1213</span>, <span class="number">683</span>, <span class="number">859</span>, <span class="number">1033</span>, <span class="number">1217</span>, <span class="number">691</span>, <span class="number">863</span>, <span class="number">1039</span>, <span class="number">1223</span>, <span class="number">1229</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>)countOfPrimes;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">sizeof</span>(primes) / <span class="keyword">sizeof</span>(*primes));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)objectInPrimesAtIndex:(<span class="built_in">NSUInteger</span>)idx;</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(idx &lt; <span class="keyword">sizeof</span>(primes) / <span class="keyword">sizeof</span>(*primes));</div><div class="line">    <span class="keyword">return</span> @(primes[idx]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>我们将会运行以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Primes *primes = [[Primes alloc] init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"The last prime is %@"</span>, [primes.primes lastObject]);</div></pre></td></tr></table></figure></p>
<p>这将会调用一次 <code>-countOfPrimes</code>和一次传入参数 idx 作为最后一个索引的 <code>-objectInPrimesAtIndex:</code>。为了只取出最后一个值，它不需要先把所有的数封装成 NSNumber 然后把它们都导入 NSArray。</p>
<p>在一个复杂一点的例子中，通讯录编辑器示例 app 用同样的方法把 C++ std::vector 封装以来。它详细说明了应该怎么利用这个方法。</p>
<p>###可变的集合<br>我们也可以在可变集合（例如 <code>NSMutableArray</code>，<code>NSMutableSet</code>，和 <code>NSMutableOrderedSet</code>）中用集合代理。</p>
<p>访问这些可变的集合有一点点不同。调用者在这儿需要调用以下其中一个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">NSMutableSet</span> *)mutableSetValueForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure></p>
<p>一个窍门：我们可以让一个类用以下方法返回可变集合的代理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableArray</span> *)mutableContacts;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mutableArrayValueForKey:<span class="string">@"wrappedContacts"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在实现键 wrappedContacts 的一些方法。</p>
<p>我们需要实现上面的不变集合的两个方法，还有以下的几个：</p>
<table>
<thead>
<tr>
<th>NSMutableArray / NSMutableOrderedSet</th>
<th>NSMutableSet    </th>
</tr>
</thead>
<tbody>
<tr>
<td>至少实现一个插入方法和一个删除方法</td>
<td>至少实现一个插入方法和一个删除方法</td>
</tr>
<tr>
<td><code>-insertObject:in&lt;Key&gt;AtIndex:</code></td>
<td><code>-add&lt;Key&gt;Object:</code></td>
</tr>
<tr>
<td><code>-removeObjectFrom&lt;Key&gt;AtIndex:</code></td>
<td><code>-remove&lt;Key&gt;Object:</code></td>
</tr>
<tr>
<td><code>-insert&lt;Key&gt;:atIndexes:</code></td>
<td><code>-add&lt;Key&gt;:</code></td>
</tr>
<tr>
<td><code>-remove&lt;Key&gt;AtIndexes:</code></td>
<td><code>-remove&lt;Key&gt;:</code></td>
</tr>
<tr>
<td>可选（增强性能）以下方法二选一</td>
<td>可选（增强性能）</td>
</tr>
<tr>
<td><code>-replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code></td>
<td><code>-intersect&lt;Key&gt;:</code></td>
</tr>
<tr>
<td><code>-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code></td>
<td><code>-set&lt;Key&gt;:</code></td>
</tr>
</tbody>
</table>
<p>上面提到，这些可变集合代理对象和 KVO 结合起来也十分强大。KVO 机制能在这些集合改变的时候把详细的变化放进 change 字典中。</p>
<p>有批量更新（需要传入多个对象）的方法，也有只改变一个对象的方法。我们推荐选择相对于给定任务来说最容易实现的那个来写，虽然我们有一点点倾向于选择批量更新的那个。</p>
<p>在实现这些方法的时候，我们要对自动和手动的 KVO 之间的差别十分小心。Foundation 默认自动发出十分详尽的变化通知。如果我们要手动实现发送详细通知的话，我们得实现这些：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-willChange:valuesAtIndexes:forKey:</div><div class="line">-didChange:valuesAtIndexes:forKey:</div></pre></td></tr></table></figure></p>
<p>或者这些：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-willChangeValueForKey:withSetMutation:usingObjects:</div><div class="line">-didChangeValueForKey:withSetMutation:usingObjects:</div></pre></td></tr></table></figure></p>
<p>我们要保证先把自动通知关闭，否则每次改变 KVO 都会发出两次通知。</p>
<p>##常见的 KVO 错误<br>首先，KVO 兼容是 API的一部分。如果类的所有者不保证某个属性兼容 KVO，我们就不能保证 KVO 正常工作。苹果文档里有 KVO 兼容属性的文档。例如，NSProgress 类的大多数属性都是兼容 KVO 的。</p>
<p>当做出改变以后，有些人试着放空的 -willChange 和 -didChange 方法来强制 KVO 的触发。KVO 通知虽然会生效，但是这样做破坏了有依赖于 NSKeyValueObservingOld 选项的观察者。详细来说，这影响了 KVO 对观察键路径 (key path) 的原生支持。KVO 在观察键路径 (key path) 时依赖于 NSKeyValueObservingOld 属性。</p>
<p>我们也要指出有些集合是不能被观察的。KVO 旨在观察关系 (relationship) 而不是集合。我们不能观察 NSArray，我们只能观察一个对象的属性——而这个属性有可能是 NSArray。举例说，如果我们有一个 ContactList 对象，我们可以观察它的 contacts 属性。但是我们不能向要观察对象的 -addObserver:forKeyPath:… 传入一个 NSArray。</p>
<p>相似地，观察 self 不是永远都生效的。而且这不是一个好的设计。</p>
<p>##调试 KVO<br>你可以在 lldb 里查看一个被观察对象的所有观察信息。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) po [observedObject observationInfo]</div></pre></td></tr></table></figure></p>
<p>这会打印出有关谁观察谁之类的很多信息。</p>
<p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。</p>
<p>##键值验证 (KVV)<br>最后提示，KVV 也是 KVC API 的一部分。这是一个用来验证属性值的 API，只是它光靠自己很难提供逻辑和功能。</p>
<p>如果我们写能够验证值的 model 类的话，我们就应该实现 KVV 的 API 来保证一致性。用 KVV 验证 model 类的值是 Cocoa 的惯例。</p>
<p>让我们在一次强调一下：KVC 不会做任何的验证，也不会调用任何 KVV 的方法。那是你的控制器需要做的事情。通过 KVV 实现你自己的验证方法会保证它们的一致性。</p>
<p>以下是一个简单的例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)nameFieldEditingDidEnd:(<span class="built_in">UITextField</span> *)sender;</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *name = [sender text];</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.contact validateName:&amp;name error:&amp;error]) &#123;</div><div class="line">        <span class="keyword">self</span>.contact.name = name;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Present the error to the user</span></div><div class="line">    &#125;</div><div class="line">    sender.text = <span class="keyword">self</span>.contact.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它强大之处在于，当 model 类（Contact）验证 name 的时候，会有机会去处理名字。</p>
<p>如果我们想让名字不要有前后的空白字符，我们应该把这些逻辑放在 model 对象里面。Contact 类可以像这样实现 KVV：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validateName:(<span class="built_in">NSString</span> **)nameP error:(<span class="built_in">NSError</span> * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (*nameP == <span class="literal">nil</span>) &#123;</div><div class="line">        *nameP = <span class="string">@""</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        *nameP = [*nameP stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> whitespaceAndNewlineCharacterSet]];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通讯录示例 里的 <code>DetailViewController</code> 和 Contact 类详解了这个用法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/31/2014-10-iOS-基础集合类/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/31/2014-10-iOS-基础集合类/" itemprop="url">
                  [iOS]基础集合类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-31T15:37:24+08:00">
              2014-10-31
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/31/2014-10-iOS-基础集合类/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/31/2014-10-iOS-基础集合类/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSArray, NSSet, NSOrderedSet 和 NSDictionary<br>基础集合类是每一个 Mac/iOS 应用的基本组成部分。在本文中，我们将对”老类” (NSArray, NSSet)和”新类” (NSMapTable, NSHashTable, NSPointerArray) 进行一个深入的研究，探索每一个的效率细节，并讨论其使用场景。</p>
<p>作者提示：本文包含一些参照结果，但它们并不意味着绝对精确，也没有进行均差分析及多次的测试。这些结果的目的是给出运行时统计，来帮助我们认识到通常来说用什么会更快。所有的测试基于 iPhone 5s，使用 Xcode 5.1b1 和 iOS 7.1b1 的 64 位程序。编译选项设置为 -Ofast 的发布构建。Vectorize loops 和 unroll loops (默认设置) 均设置为关闭。</p>
<p>大 O 符号，算法复杂度计量<br>首先，我们需要一些理论知识。效率通常用大 O 符号描述。它定义了一个函数的极限特征，通常被用于描绘其算法效率。O 定义了函数增长率的上限。不同量级的差异非常巨大，可以看看通常使用的 O 符号的量级以及它们所对应需要的操作数的关系。</p>
<p>例如，如果用算法复杂度为 O(n^2)的算法对一个有 50 个元素的数组排序，需要 2,500 步的操作。而且，还有内部的系统开销和方法调用 — 所以是 250 0个操作的时间常量。 O(1)是理想的复杂度，代表着恒定的时间。好的排序算法通常需要 O(n*log n) 的时间。</p>
<p>可变性<br>大多数的集合类存在两个版本:可变和不可变(默认)。这和其他大多数的框架有非常大的不同，一开始会让人觉得有一点奇怪。然而其他的框架现在也应用了这一特性：就在几个月前，.NET公布了作为官方扩展的不可变集合。</p>
<p>最大的好处是什么？线程安全。不可变的集合完全是线程安全的，可以同时在多个线程中迭代，避免各种转变时出现异常的风险。你的 API 绝不应该暴露一个可变的集合。</p>
<p>当然从不可变到可变然后再回来是会有一定代价的 — 对象必须被拷贝两次，所有集合内的对象将被 retain/release。有时在内部使用一个可变的集合，而在访问时返回一个不可变的对象副本会更高效。</p>
<p>与其他框架不同的是，苹果没有提供一个线程安全的可变集合，NSCache 是例外，但它真的算不上是集合类，因为它不是一个通用的容器。大多数时候，你不会需要在集合层级的同步特性。想象一段代码，作用是检查字典中一个 key 是否存在，并根据检查结果决定设置一个新的 key 或者返回某些值 — 你通常需要把多个操作归类，这时线程安全的可变集合并不能对你有所帮助。</p>
<p>其实也有一些同步的，线程安全的可以使用的可变集合案例，它们往往只需要用几行代码，通过子类和组合的方法建立，比如这个 NSDictionary 或这个 NSArray。</p>
<p>需要注意的是，一些较新的集合类，如 NSHashTable，NSMapTable 和 NSPointerArray 默认就是可变的，它们并没有对应的不可变的类。它们用于类的内部使用，你基本应该不会能找到需要它们的不可变版本的应用场景。</p>
<p>NSArray<br>NSArray 作为一个存储对象的有序集合，可能是被使用最多的集合类。这也是为什么它有自己的比原来的 [NSArray arrayWithObjects:…, nil] 简短得多的快速语法糖符号 @[…]。 NSArray 实现了 objectAtIndexedSubscript:，因为我们可以使用类 C 的语法 array[0] 来代替原来的 [array objectAtIndex:0]。</p>
<p>性能特征<br>关于 NSArray 的内容比你想象的要多的多。基于存储对象的多少，它使用各种内部的变体。最有趣的部分是苹果对于个别的对象访问并不保证 O(1) 的访问时间 — 正如你在 CFArray.h CoreFoundation 头文件中的关于算法复杂度的注解中可以读到的:</p>
<p>对于 array 中值的访问时间，不管是在现在还是将来，我们保证在任何一种实现下最坏情况是 O(lg N)。但是通常来说它会是 O(1) (常数时间)。线性搜索操作很可能在最坏情况下的复杂度为 O(N<em>lg N)，但通常来说上限会更小一些。插入和删除操作耗时通常和数组中的值的数量成线性关系。但在某些实现的最坏情况下会是 O(N</em>lg N) 。在数组中，没有对于性能上特别有优势的数据位置，也就是说，为了更快地访问到元素而将其设为在较低的 index 上，或者在较高的 index 上进行插入和删除，或者类似的一些做法，是没有必要的。</p>
<p>在测量的时候，NSArray 产生了一些有趣的额外的性能特征。在数组的开头和结尾插入/删除元素通常是一个 O(1)操作，而随机的插入/删除通常是 O(N) 的。</p>
<p>有用的方法<br>NSArray 的大多数方法使用 isEqual: 来检查对象间的关系(例如 containsObject: 中)。有一个特别的方法 indexOfObjectIdenticalTo: 用来检查指针相等，如果你确保在同一个集合中搜索，那么这个方法可以很大的提升搜索速度。 在 iOS 7 中，我们最终得到了与 lastObject 对应的公开的 firstObject 方法，对于空数组，这两个方法都会返回 nil — 而常规的访问方法会抛出一个 NSRangeException 异常。</p>
<p>关于构造（可变）数组有一个漂亮的细节可以节省代码量。如果你通过一个可能为 nil 的数组创建一个可变数组，通常会这么写:</p>
<p>NSMutableArray *mutableObjects = [array mutableCopy];<br>if (!mutableObjects) {<br>    mutableObjects = [NSMutableArray array];<br>}<br>或者通过更简洁的三元运算符:</p>
<p>NSMutableArray *mutableObjects = [array mutableCopy] ?: [NSMutableArray array];<br>更好的解决方案是使用arrayWithArray:，即使原数组为nil，该方法也会返回一个数组对象:</p>
<p>NSMutableArray *mutableObjects = [NSMutableArray arrayWithArray:array];<br>这两个操作在效率上几乎相等。使用 copy 会快一点点，不过话说回来，这不太可能是你应用的瓶颈所在。提醒：不要使用 [@[] mutableCopy]。经典的[NSMutableArray array]可读性更好。</p>
<p>逆序一个数组非常简单：array.reverseObjectEnumerator.allObjects。我们使用系统提供的 reverseObjectEnumerator，每一个 NSEnumerator 都实现了 allObjects，该方法返回一个新数组。虽然没有原生的 randomObjectEnumerator 方法，你可以写一个自定义的打乱数组顺序的枚举器或者使用一些出色的开源代码。</p>
<p>数组排序<br>有很多各种各样的方法来对一个数组排序。如果数组存储的是字符串对象，sortedArrayUsingSelector:是第一选择:</p>
<p>NSArray <em>array = @[@”John Appleseed”, @”Tim Cook”, @”Hair Force One”, @”Michael Jurewitz”];<br>NSArray </em>sortedArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];<br>下面的代码对存储数字的内容同样很好，因为 NSNumber 实现了 compare::</p>
<p>NSArray <em>numbers = @[@9, @5, @11, @3, @1];<br>NSArray </em>sortedNumbers = [numbers sortedArrayUsingSelector:@selector(compare:)];<br>如果想更可控，可以使用基于函数指针的排序方法:</p>
<ul>
<li>(NSData *)sortedArrayHint;</li>
<li>(NSArray <em>)sortedArrayUsingFunction:(NSInteger (</em>)(id, id, void *))comparator<pre><code>context:(void *)context;
</code></pre></li>
<li>(NSArray <em>)sortedArrayUsingFunction:(NSInteger (</em>)(id, id, void *))comparator<pre><code>context:(void *)context hint:(NSData *)hint;
</code></pre>苹果增加了一个方法来加速使用 sortedArrayHint 的排序。</li>
</ul>
<p>hinted sort 方式在你有一个已排序的大数组 (N 个元素) 并且只改变其中一小部分（P 个添加和删除，这里 P远小于 N）时，会非常有效。你可以重用原来的排序结果，然后在 N 个老项目和 P 个新项目进行一个概念上的归并排序。为了得到合适的 hint，你应该在原来的数组排序后使用 sortedArrayHint 来在你需要的时候(比如在数组改变后想重新排序时)保证持有它。</p>
<p>因为block的引入，也出现了一些基于block的排序方法:</p>
<ul>
<li>(NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;</li>
<li>(NSArray *)sortedArrayWithOptions:(NSSortOptions)opts<pre><code>usingComparator:(NSComparator)cmptr;
</code></pre>性能上来说，不同的方法间并没有太多的不同。有趣的是，基于 selector 的方式是最快的。你可以在 GitHub 上找到测试用的源代码:</li>
</ul>
<p>Sorting 1000000 elements. selector: 4947.90[ms] function: 5618.93[ms] block: 5082.98[ms].</p>
<p>二分查找<br>NSArray 从 iOS 4 / Snow Leopard 开始内置了二分查找</p>
<p>typedef NS_OPTIONS(NSUInteger, NSBinarySearchingOptions) {<br>    NSBinarySearchingFirstEqual     = (1UL &lt;&lt; 8),<br>    NSBinarySearchingLastEqual      = (1UL &lt;&lt; 9),<br>    NSBinarySearchingInsertionIndex = (1UL &lt;&lt; 10),<br>};</p>
<ul>
<li>(NSUInteger)indexOfObject:(id)obj<pre><code>  inSortedRange:(NSRange)r
        options:(NSBinarySearchingOptions)opts
usingComparator:(NSComparator)cmp;
</code></pre>为什么要使用这个方法？类似 containsObject: 和 indexOfObject: 这样的方法从 0 索引开始搜索每个对象直到找到目标 — 这样不需要数组被排序，但是却是 O(n)的效率特性。如果使用二分查找的话，需要数组事先被排序，但在查找时只需要 O(log n) 的时间。因此，对于 一百万条记录，二分查找法最多只需要 21 次比较，而传统的线性查找则平均需要 500,000 次的比较。</li>
</ul>
<p>这是个简单的衡量二分查找有多快的数据:</p>
<p>Time to search for 1000 entries within 1000000 objects. Linear: 54130.38[ms]. Binary: 7.62[ms]<br>作为比较，查找 NSOrderedSet 中的指定索引花费 0.23 毫秒 — 就算和二分查找相比也又快了 30 多倍。</p>
<p>记住排序的开销也是昂贵的。苹果使用复杂度为 O(n*log n) 的归并排序，所以如果你执行一次 indexOfObject: 的话，就没有必要使用二分查找了。</p>
<p>通过指定 NSBinarySearchingInsertionIndex，你可以获得正确的插入索引，以确保在插入元素后仍然可以保证数组的顺序。</p>
<p>枚举和总览<br>作为测试，我们来看一个普通的使用场景。从一个数组中过滤出一些元素组成另一个数组。这些测试都包括了枚举的方法以及使用 API 进行过滤的方式：</p>
<p>// 第一种方式，使用 <code>indexesOfObjectsWithOptions:passingTest:</code>.<br>NSIndexSet <em>indexes = [randomArray indexesOfObjectsWithOptions:NSEnumerationConcurrent<br>                                               passingTest:^BOOL(id obj, NSUInteger idx, BOOL </em>stop) {<br>    return testObj(obj);<br>}];<br>NSArray *filteredArray = [randomArray objectsAtIndexes:indexes];</p>
<p>// 使用 predicate 过滤，包括 block 的方式和文本 predicate 的方式<br>NSArray <em>filteredArray2 = [randomArray filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id obj, NSDictionary </em>bindings) {<br>    return testObj(obj);<br>}]];</p>
<p>// 基于 block 的枚举<br>NSMutableArray <em>mutableArray = [NSMutableArray array];<br>[randomArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL </em>stop) {<br>    if (testObj(obj)) {<br>        [mutableArray addObject:obj];<br>    }<br>}];</p>
<p>// 传统的枚举<br>NSMutableArray *mutableArray = [NSMutableArray array];<br>for (id obj in randomArray) {<br>    if (testObj(obj)) {<br>        [mutableArray addObject:obj];<br>    }<br>}</p>
<p>// 使用 NSEnumerator，传统学院派<br>NSMutableArray <em>mutableArray = [NSMutableArray array];<br>NSEnumerator </em>enumerator = [randomArray objectEnumerator];<br>id obj = nil;<br>while ((obj = [enumerator nextObject]) != nil) {<br>    if (testObj(obj)) {<br>        [mutableArray addObject:obj];<br>    }<br>}</p>
<p>// 通过下标使用 objectAtIndex：<br>NSMutableArray *mutableArray = [NSMutableArray array];<br>for (NSUInteger idx = 0; idx &lt; randomArray.count; idx++) {<br>    id obj = randomArray[idx];<br>    if (testObj(obj)) {<br>        [mutableArray addObject:obj];<br>    }<br>}<br>枚举方法 / 时间 [ms]    10.000.000 elements    10.000 elements<br>indexesOfObjects:, concurrent    1844.73    2.25<br>NSFastEnumeration (for in)    3223.45    3.21<br>indexesOfObjects:    4221.23    3.36<br>enumerateObjectsUsingBlock:    5459.43    5.43<br>objectAtIndex:    5282.67    5.53<br>NSEnumerator    5566.92    5.75<br>filteredArrayUsingPredicate:    6466.95    6.31<br>为了更好的理解这里的效率测量，我们首先看一下数组是如何迭代的。</p>
<p>indexesOfObjectsWithOptions:passingTest: 必须每次都执行一次 block 因此比传统的使用 NSFastEnumeration 技术的基于 for 循环的枚举要稍微低效一些。但是如果开启了并发枚举，那么前者的速度则会大大的超过后者几乎 2 倍。iPhone 5s 是双核的，所以这说得通。这里并没有体现出来的是 NSEnumerationConcurrent 只对大量的对象有意义，如果你的集合中的对象数量很少，用哪个方法就真的无关紧要。甚至 NSEnumerationConcurrent 上额外的线程管理实际上会使结果变得更慢。</p>
<p>最大的输家是 filteredArrayUsingPredicate:。NSPredicate 需要在这里提及是因为，人们可以写出非常复杂的表达式，尤其是用不基于 block 的变体。使用 Core Data 的用户应该会很熟悉。</p>
<p>为了比较的完整，我们也加入了 NSEnumerator 作为比较 — 虽然没有任何理由再使用它了。然而它竟出人意料的快(至少还是比基于 NSPredicate 的过滤要快)，它的运行时消耗无疑比快速枚举更多 — 现在它只用于向后兼容。甚至没有优化过的 objectAtIndex: 都要更快些。</p>
<p>NSFastEnumeration<br>在OSX 10.5和iOS的最初版本中，苹果增加了 NSFastEnumeration。在此之前，只有每次返回一个元素的 NSEnumeration ，每次迭代都有运行时开销。而快速枚举，苹果通过 countByEnumeratingWithState:objects:count: 返回一个数据块。该数据块被解析成 id 类型的 C 数组。这就是更快的速度的原因；迭代一个 C 数组要快得多，而且可以被编译器更深一步的优化。手动的实现快速枚举是十分难办的，所以苹果的 FastEnumerationSample 是一个不错的开始，还有一篇 Mike Ash 的文章也很不错。</p>
<p>应该用arrayWithCapacity:吗?<br>初始化NSArray的时候，可以选择指定数组的预期大小。在检测的时候，结果是在效率上没有差别 — 至少在统计误差范围内的测量的时间几乎相等。有消息透漏说实际上苹果根本没有使用这个参数。然而使用 arrayWithCapacity: 仍然好处，它可以作为一种隐性的文档来帮助你理解代码:</p>
<p>Adding 10.000.000 elements to NSArray. no count 1067.35[ms] with count: 1083.13[ms].</p>
<p>子类化注意事项<br>很少有理由去子类化基础集合类。大多数时候，使用 CoreFoundation 级别的类并且自定义回调函数定制自定义行为是更好的解决方案。 创建一个大小写不敏感的字典，一种方法是子类化 NSDictionary 并且自定义访问方法，使其将字符串始终变为小写(或大写)，并对排序也做类似的修改。更快更好的解决方案是提供一组不同的 CFDictionaryKeyCallBacks 集，你可以提供自定义的 hash 和 isEqual: 回调。你可以在这里找到一个例子。这种方法的优美之处应该归功于 toll-free 桥接)，它仍然是一个简单的字典，因此可以被任何使用 NSDictionary 作为参数的API接受。</p>
<p>子类作用的一个例子是有序字典的用例。.NET 提供了一个 SortedDictionary，Java 有 TreeMap，C++ 有 std::map。虽然你可以使用 C++ 的 STL 容器，但却无法使它自动的 retain/release ，这会让使用起来笨拙得多。因为 NSDictionary 是一个类簇，所以子类化跟人们想象的相比非常不同。这已经超过了本文的讨论范畴，这里有一个真实的有序字典的例子。</p>
<p>NSDictionary<br>一个字典存储任意的对象键值对。 由于历史原因，初始化方法 [NSDictionary dictionaryWithObjectsAndKeys:object, key, nil] 使用了相反的值到键的顺序，而新的快捷语法则从 key 开始，@{key : value, …}。</p>
<p>NSDictionary 中的键是被拷贝的并且需要是不变的。如果在一个键在被用于在字典中放入一个值后被改变的话，那么这个值就会变得无法获取了。一个有趣的细节是，在 NSDictionary 中键是被 copy 的，但是在使用一个 toll-free 桥接的 CFDictionary 时却只会被 retain。CoreFoundation 类没有通用的拷贝对象的方法，因此这时拷贝是不可能的(*)。这只适用于你使用 CFDictionarySetValue() 的时候。如果你是通过 setObject:forKey 来使用一个 toll-free 桥接的 CFDictionary 的话，苹果会为其增加额外处理逻辑，使得键被拷贝。但是反过来这个结论则不成立 — 使用已经转换为 CFDictionary 的 NSDictionary 对象，并用对其使用 CFDictionarySetValue() 方法，还是会导致调用回 setObject:forKey 并对键进行拷贝。</p>
<p>(*)其实有一个现成的键的回调函数 kCFCopyStringDictionaryKeyCallBacks 可以拷贝字符串，因为对于 ObjC对象来说， CFStringCreateCopy() 会调用 [NSObject copy]，我们可以巧妙使用这个回调来创建一个能进行键拷贝的 CFDictionary。</p>
<p>性能特征<br>苹果在定义字典的计算复杂度时显得相当低调。唯一的信息可以在 CFDictionary 的头文件中找到:</p>
<p>对于字典中值的访问时间，不管是在现在还是将来，我们保证在任何一种实现下最坏情况是 O(N)。但通常来说它会是 O(1) (常数时间)。插入和删除操作一般来说也会是常数时间，但是在某些实现中最坏情况将为 O(N*N)。通过键来访问值将比直接访问值要快（如果你有这样的操作要做的话）。对于同样数目的值，字典需要花费比数组多得多的内存空间。</p>
<p>跟数组相似的，字典根据尺寸的不同使用不同的实现，并在其中无缝切换。</p>
<p>枚举和总览<br>过滤字典有几个不同的方法:</p>
<p>// 使用 keysOfEntriesWithOptions:passingTest:，可并行<br>NSSet <em>matchingKeys = [randomDict keysOfEntriesWithOptions:NSEnumerationConcurrent<br>                                               passingTest:^BOOL(id key, id obj, BOOL </em>stop)<br>{<br>    return testObj(obj);<br>}];<br>NSArray <em>keys = matchingKeys.allObjects;<br>NSArray </em>values = [randomDict objectsForKeys:keys notFoundMarker:NSNull.null];<br>__unused NSDictionary *filteredDictionary = [NSDictionary dictionaryWithObjects:values<br>                                                                        forKeys:keys];</p>
<p>// 基于 block 的枚举<br>NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];<br>[randomDict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL </em>stop) {<br>    if (testObj(obj)) {<br>        mutableDictionary[key] = obj;<br>    }<br>}];</p>
<p>// NSFastEnumeration<br>NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];<br>for (id key in randomDict) {<br>    id obj = randomDict[key];<br>    if (testObj(obj)) {<br>        mutableDictionary[key] = obj;<br>    }<br>}</p>
<p> // NSEnumeration<br> NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];<br> NSEnumerator </em>enumerator = [randomDict keyEnumerator];<br> id key = nil;<br> while ((key = [enumerator nextObject]) != nil) {<br>       id obj = randomDict[key];<br>       if (testObj(obj)) {<br>           mutableDictionary[key] = obj;<br>       }<br> }</p>
<p>// 基于 C 数组，通过 getObjects:andKeys: 枚举<br>NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];<br>id <strong>unsafe_unretained objects[numberOfEntries];<br>id </strong>unsafe_unretained keys[numberOfEntries];<br>[randomDict getObjects:objects andKeys:keys];<br>for (int i = 0; i &lt; numberOfEntries; i++) {<br>    id obj = objects[i];<br>    id key = keys[i];<br>    if (testObj(obj)) {<br>       mutableDictionary[key] = obj;<br>    }<br> }<br>过滤/枚举方法    Time [ms], 50.000 elements    1.000.000 elements<br>keysOfEntriesWithOptions:, concurrent    16.65    425.24<br>getObjects:andKeys:    30.33    798.49</em><br>keysOfEntriesWithOptions:    30.59    856.93<br>enumerateKeysAndObjectsUsingBlock:    36.33    882.93<br>NSFastEnumeration    41.20    1043.42<br>NSEnumeration    42.21    1113.08<br>(*)使用 getObjects:andKeys: 时需要注意。在上面的代码例子中，我们使用了可变长度数组这一 C99 特性(通常，数组的数量需要是一个固定值)。这将在栈上分配内存，虽然更方便一点，但却有其限制。上面的代码在元素数量很多的时候会崩溃掉，所以我们使用基于 malloc/calloc 的分配 (和 free) 以确保安全。</p>
<p>为什么这次 NSFastEnumeration 这么慢？迭代字典通常需要键和值两者，快速枚举只能枚举键，我们必须每次都自己获取值。使用基于 block 的 enumerateKeysAndObjectsUsingBlock: 更高效，因为两者都可以更高效的被提前获取。</p>
<p>这次测试的胜利者又是通过 keysOfEntriesWithOptions:passingTest: 和 objectsForKeys:notFoundMarker: 的并发迭代。代码稍微多了一点，但是可以用 category 进行漂亮的封装。</p>
<p>应该用 dictionaryWithCapacity: 吗?<br>到现在你应该已经知道该如何测试了，简单的回答是不，count 参数没有改变任何事情:</p>
<p>Adding 10000000 elements to NSDictionary. no count 10786.60[ms] with count: 10798.40[ms].</p>
<p>排序<br>关于字典排序没有太多可说的。你只能将键数组排序为一个新对象，因此你可以使用任何正规的 NSArray 的排序方法:</p>
<ul>
<li>(NSArray *)keysSortedByValueUsingSelector:(SEL)comparator;</li>
<li>(NSArray *)keysSortedByValueUsingComparator:(NSComparator)cmptr;</li>
<li>(NSArray *)keysSortedByValueWithOptions:(NSSortOptions)opts<pre><code>usingComparator:(NSComparator)cmptr;
</code></pre>共享键<br>从 iOS 6 和 OS X 10.8 开始，新建的字典可以使用一个预先生成好的键集，使用 sharedKeySetForKeys: 从一个数组中创建键集，然后用 dictionaryWithSharedKeySet: 创建字典。共享键集会复用对象，以节省内存。根据 Foundation Release Notes，sharedKeySetForKeys: 中会计算一个最小完美哈希，这个哈希值可以取代字典查找过程中探索循环的需要，因此使键的访问更快。</li>
</ul>
<p>虽然在我们有限的测试中没有法线苹果在 NSJSONSerialization 中使用这个特性，但毫无疑问，在处理 JSON 的解析工作时这个特性可以发挥得淋漓尽致。(使用共享键集创建的字典是 NSSharedKeyDictionary 的子类；通常的字典是 <strong>NSDictionaryI / </strong>NSDictionaryM，I / M 表明可变性；可变和不可变的的字典在 toll-free 桥接后对应的都是 _NSCFDictionary 类。)</p>
<p>有趣的细节：共享键字典始终是可变的，即使对它们执行了”copy”命令后也是。这个行为文档中并没有说明，但很容易被测试:</p>
<p>id sharedKeySet = [NSDictionary sharedKeySetForKeys:@[@1, @2, @3]]; // 返回 NSSharedKeySet<br>NSMutableDictionary <em>test = [NSMutableDictionary dictionaryWithSharedKeySet:sharedKeySet];<br>test[@4] = @”First element (not in the shared key set, but will work as well)”;<br>NSDictionary </em>immutable = [test copy];<br>NSParameterAssert(immutable.count == 1);<br>((NSMutableDictionary *)immutable)[@5] = @”Adding objects to an immutable collection should throw an exception.”;<br>NSParameterAssert(immutable.count == 2);<br>NSSet<br>NSSet 和它的可变变体 NSMutableSet 是无序对象集合。检查一个对象是否存在通常是一个 O(1) 的操作，使得比 NSArray 快很多。NSSet 只在被使用的哈希方法平衡的情况下能高效的工作；如果所有的对象都在同一个哈希筐内，NSSet 在查找对象是否存在时并不比 NSArray 快多少。</p>
<p>NSSet 还有变体 NSCountedSet，以及非 toll-free 计数变体 CFBag / CFMutableBag。</p>
<p>NSSet 会 retain 它其中的对象，但是根据 set 的规定，对象应该是不可变的。添加一个对象到 set 中随后改变它会导致一些奇怪的问题并破坏 set 的状态。</p>
<p>NSSet 的方法比 NSArray 少的多。没有排序方法，但有一些方便的枚举方法。重要的方法有 allObjects，将对象转化为 NSArray，anyObject 则返回任意的对象，如果 set 为空，则返回 nil。</p>
<p>Set 操作<br>NSMutableSet 有几个很强大的方法，例如 intersectSet:，minusSet: 和 unionSet:。</p>
<p>img</p>
<p>应该用setWithCapacity:吗?<br>我们再一次测试当创建 set 时给定容量大小是否会有显著的速度差异:</p>
<p>Adding 1.000.000 elements to NSSet. no count 2928.49[ms] with count: 2947.52[ms].</p>
<p>在统计误差范围内，结果没有显著差异。有一份证据表明至少在上一个 runtime 版本中，有很多的性能上的影响。</p>
<p>NSSet 性能特征<br>苹果在 CFSet 头文件中没有提供任何关于算法复杂度的注释。</p>
<p>类 / 时间 [ms]    1.000.000 elements<br>NSMutableSet, adding    2504.38<br>NSMutableArray, adding    1413.38<br>NSMutableSet, random access    4.40<br>NSMutableArray, random access    7.95<br>这个检测非常符合我们的预期：NSSet 在每一个被添加的对象上执行 hash 和 isEqual: 方法并管理一系列哈希值，所以在添加元素时耗费了更多的时间。set的随机访问比较难以测试，因为这里执行的都是 anyObject。</p>
<p>这里没有必要包含 containsObject: 的测试，set 要快几个数量级，毕竟这是它的特点。</p>
<p>NSOrderedSet<br>NSOrderedSet 在 iOS 5 和 Mac OS X 10.7 中第一次被引入，除了 Core Data，几乎没有直接使用它的 API。看上去它综合了 NSArray 和 NSSet 两者的好处，对象查找，对象唯一性，和快速随机访问。</p>
<p>NSOrderedSet 有着优秀的 API 方法，使得它可以很便利的与其他 set 或者有序 set 对象合作。合并，交集，差集，就像 NSSet 支持的那样。它有 NSArray 中除了比较陈旧的基于函数的排序方法和二分查找以外的大多数排序方法。毕竟 containsObject: 非常快，所以没有必要再用二分查找了。</p>
<p>NSOrderedSet 的 array 和 set 方法分别返回一个 NSArray 和 NSSet，这些对象表面上是不可变的对象，但实际上在 NSOrderedSet 更新的时候，它们也会更新自己。如果你在不同线程上使用这些对象并发生了诡异异常的时候，知道这一点是非常有好处的。本质上，这些类使用的是 <strong>NSOrderedSetSetProxy 和 </strong>NSOrderedSetArrayProxy。</p>
<p>附注：如果你想知道为什么 NSOrderedSet 不是 NSSet 的子类，NSHipster 上有一篇非常好的文章解释了可变/不可变类簇的缺点。</p>
<p>NSOrderedSet 性能特征<br>如果你看到这份测试，你就会知道 NSOrderedSet 代价高昂了，毕竟天下没有免费的午餐:</p>
<p>类 / 时间 [ms]    1.000.000 elements<br>NSMutableOrderedSet, adding    3190.52<br>NSMutableSet, adding    2511.96<br>NSMutableArray, adding    1423.26<br>NSMutableOrderedSet, random access    10.74<br>NSMutableSet, random access    4.47<br>NSMutableArray, random access    8.08<br>这个测试在每一个集合类中添加自定义字符串，随后随机访问它们。</p>
<p>NSOrderedSet 比 NSSet 和 NSArray 占用更多的内存，因为它需要同时维护哈希值和索引。</p>
<p>NSHashTable<br>NSHashTable 效仿了 NSSet，但在对象/内存处理时更加的灵活。可以通过自定义 CFSet 的回调获得 NSHashTable 的一些特性，哈希表可以保持对对象的弱引用并在对象被销毁之后正确的将其移除，有时候如果手动在 NSSet 中添加的话，想做到这个是挺恶心的一件事。它是默认可变的 — 并且这个类没有相应的不可变版本。</p>
<p>NSHashTable 有 ObjC 和原始的 C API，C API 可以用来存储任意对象。苹果在 10.5 Leopard 系统中引入了这个类，但是 iOS 的话直到最近的 iOS 6 中才被加入。足够有趣的是它们只移植了 ObjC API；更多强大的 C API 没有包括在 iOS 中。</p>
<p>NSHashTable 可以通过 initWithPointerFunctions:capacity: 进行大量的设置 — 我们只选取使用预先定义的 hashTableWithOptions: 这一最普遍的使用场景。其中最有用的选项有利用 weakObjectsHashTable 来使用其自身的构造函数。</p>
<p>NSPointerFunctions<br>这些指针函数可以被用在 NSHashTable，NSMapTable和 NSPointerArray 中，定义了对存储在这个集合中的对象的获取和保留行为。这里只介绍最有用的选项。完整列表参见 NSPointerFunctions.h。</p>
<p>有两组选项。内存选项决定了内存管理，个性化定义了哈希和相等。</p>
<p>NSPointerFunctionsStrongMemory 创建了一个r etain/release 对象的集合，非常像常规的 NSSet 或 NSArray。</p>
<p>NSPointerFunctionsWeakMemory 使用和 __weak 等价的方式来存储对象并自动移除被销毁的对象。</p>
<p>NSPointerFunctionsCopyIn 在对象被加入到集合前拷贝它们。</p>
<p>NSPointerFunctionsObjectPersonality 使用对象的 hash 和 isEqual: (默认)。</p>
<p>NSPointerFunctionsObjectPointerPersonality 对于 isEqual: 和 hash 使用直接的指针比较。</p>
<p>NSHashTable 性能特征<br>类 / 时间 [ms]    1.000.000 elements<br>NSHashTable, adding    2511.96<br>NSMutableSet, adding    1423.26<br>NSHashTable, random access    3.13<br>NSMutableSet, random access    4.39<br>NSHashTable, containsObject    6.56<br>NSMutableSet, containsObject    6.77<br>NSHashTable, NSFastEnumeration    39.03<br>NSMutableSet, NSFastEnumeration    30.43<br>如果你只是需要 NSSet 的特性，请坚持使用 NSSet。NSHashTable 在添加对象时花费了将近2倍的时间，但是其他方面的效率却非常相近。</p>
<p>NSMapTable<br>NSMapTable 和 NSHashTable 相似，但是效仿的是 NSDictionary。因此，我们可以通过 mapTableWithKeyOptions:valueOptions: 分别控制键和值的对象获取/保留行为。存储弱引用是 NSMapTable 最有用的特性，这里有4个方便的构造函数:</p>
<p>strongToStrongObjectsMapTable<br>weakToStrongObjectsMapTable<br>strongToWeakObjectsMapTable<br>weakToWeakObjectsMapTable<br>注意，除了使用 NSPointerFunctionsCopyIn，任何的默认行为都会 retain (或弱引用)键对象而不会拷贝它，这与 CFDictionary 的行为相同而与 NSDictionary 不同。当你需要一个字典，它的键没有实现 NSCopying 协议的时候（比如像 UIView），这会非常有用。</p>
<p>如果你好奇为什么苹果”忘记”为 NSMapTable 增加下标，你现在知道了。下标访问需要一个 id<nscopying> 作为 key，对 NSMapTable 来说这不是强制的。如果不通过一个非法的 API 协议或者移除 NSCopying 协议来削弱全局下标，是没有办法给它增加下标的。</nscopying></p>
<p>你可以通过 dictionaryRepresentation 把内容转换为普通的 NSDictionary。不像 NSOrderedSet，这个方法返回的是一个常规的字典而不是一个代理。</p>
<p>NSMapTable 性能特征<br>类 / 时间 [ms]    1.000.000 elements<br>NSMapTable, adding    2958.48<br>NSMutableDictionary, adding    2522.47<br>NSMapTable, random access    13.25<br>NSMutableDictionary, random access    9.18<br>NSMapTable 只比 NSDictionary 略微慢一点。如果你需要一个不 retain 键的字典，放弃 CFDictionary 而使用它吧。</p>
<p>NSPointerArray<br>NSPointerArray类是一个稀疏数组，工作起来与 NSMutableArray 相似，但可以存储 NULL 值，并且 count 方法会反应这些空点。可以用 NSPointerFunctions 对其进行各种设置，也有应对常见的使用场景的快捷构造函数 strongObjectsPointerArray 和 weakObjectsPointerArray。</p>
<p>在能使用 insertPointer:atIndex: 之前，我们需要通过直接设置 count 属性来申请空间，否则会产生一个异常。另一种选择是使用 addPointer:，这个方法可以自动根据需要增加数组的大小。</p>
<p>你可以通过 allObjects 将一个 NSPointerArray 转换成常规的 NSArray。这时所有的 NULL 值会被去掉，只有真正存在的对象被加入到数组 — 因此数组的对象索引很有可能会跟指针数组的不同。注意：如果向指针数组中存入任何非对象的东西，试图执行 allObjects 都会造成 EXC_BAD_ACCESS 崩溃，因为它会一个一个地去 retain ”对象”。</p>
<p>从调试的角度讲，NSPointerArray没有受到太多欢迎。description方法只是简单的返回了<nsconcretepointerarray: 0x17015ac50="">。为了得到所有的对象需要执行[pointerArray allObjects]，当然，如果存在NULL的话会改变索引。</nsconcretepointerarray:></p>
<p>NSPointerArray 性能特征<br>在性能方面， NSPointerArray 真的非常非常慢，所以当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用 NSNull 作为空标记的 NSMutableArray ，而对 NSPointerArray 我们用 NSPointerFunctionsStrongMemory 来进行设置 (这样对象会被适当的 retain)。在一个有 10,000 个元素的数组中，我们每隔十个插入一个字符串 ”Entry %d”。此测试包括了用 NSNull.null 填充 NSMutableArray 的总时间。对于 NSPointerArray，我们使用 setCount: 来代替:</p>
<p>类 / 时间 [ms]    10.000 elements<br>NSMutableArray, adding    15.28<br>NSPointerArray, adding    3851.51<br>NSMutableArray, random access    0.23<br>NSPointerArray, random access    0.34<br>注意 NSPointerArray 需要的时间比 NSMutableArray 多了超过<em> 250 倍(!)</em> 。这非常奇怪和意外。跟踪内存是比较困难的，所以按理说 NSPointerArray 会更高效才对。不过由于我们使用的是同一个 NSNull 来标记空对象，所以除了指针也没有什么更多的消耗。</p>
<p>NSCache<br>NSCache 是一个非常奇怪的集合。在 iOS 4 / Snow Leopard 中加入，默认为可变并且线程安全的。这使它很适合缓存那些创建起来代价高昂的对象。它自动对内存警告做出反应并基于可设置的”成本”清理自己。与 NSDictionary 相比，键是被 retain 而不是被 copy 的。</p>
<p>NSCache 的回收方法是不确定的，在文档中也没有说明。向里面放一些类似图片那样超大的对象并不是一个好主意，有可能它在能回收之前就更快地把你的 cache 给填满了。(这是在 PSPDFKit 中很多跟内存有关的 crash 的原因，在使用自定义的基于 LRU 的链表缓存的代码之前，我们起初使用了 NSCache 存储事先渲染的图片。)</p>
<p>可以对 NSCache 进行设置，这样它就能自动回收那些实现了 NSDiscardableContent 协议的对象。实现了该属性的一个比较常用的类是同时间加入的 NSPurgeableData，但是在 OS X 10.9 之前，它是非完全线程安全的 (也没有信息表明这个变化也影响到了 iOS，或者说在 iOS 7 中被修复了)。</p>
<p>NSCache 性能<br>那么相比起 NSMutableDictionary 来说，NSCache 表现如何呢？加入的线程安全必然会带来一些消耗。处于好奇，我也加入了一个自定义的线程安全的字典的子类 (PSPDFThreadSafeMutableDictionary)，它通过 OSSpinLock 实现同步的访问。</p>
<p>类 / 时间 [ms]    1.000.000 elements    iOS 7x64 Simulator    iPad Mini iOS 6<br>NSMutableDictionary, adding    195.35    51.90    921.02<br>PSPDFThreadSafeMutableDictionary, adding    248.95    57.03    1043.79<br>NSCache, adding    557.68    395.92    1754.59<br>NSMutableDictionary, random access    6.82    2.31    23.70<br>PSPDFThreadSafeMutableDictionary, random access    9.09    2.80    32.33<br>NSCache, random access    9.01    29.06    53.25<br>NSCache 表现的相当好，随机访问跟我们自定义的线程安全字典一样快。如我们预料的，添加更慢一些，因为 NSCache 要多维护一个决定何时回收对象的成本系数。就这一点来看这不是一个非常公平的比较。有趣的是，在模拟器上运行效率要慢了几乎 10 倍。无论对 32 或 64 位的系统都是这样。而且看起来这个类已经在 iOS 7 中优化过，或者是受益于 64 位 runtime 环境。当在老的设备上测试时，使用 NSCache 的性能消耗就明显得多。</p>
<p>iOS 6(32 bit) 和 iOS 7(64 bit) 的区别也很明显，因为 64 位运行时使用标签指针 (tagged pointer)，因此我们的 @(idx) boxing 要更为高效。</p>
<p>NSIndexSet<br>有些使用场景下 NSIndexSet (和它的可变变体，NSMutableIndexSet) 真的非常出色，对它的使用贯穿在 Foundation 中。它可以用一种非常高效的方法存储一组无符号整数的集合，尤其是如果只是一个或少量范围的时候。正如 set 这个名字已经暗示的那样，每一个 NSUInteger 要么在索引 set 中，要么不在。如果你需要存储任意非唯一的数的时候，最好使用 NSArray。</p>
<p>下面是如何把一个整数数组转换为 NSIndexSet:</p>
<p>NSIndexSet <em>PSPDFIndexSetFromArray(NSArray </em>array) {<br>    NSMutableIndexSet <em>indexSet = [NSMutableIndexSet indexSet];<br>    for (NSNumber </em>number in array) {<br>        [indexSet addIndex:[number unsignedIntegerValue]];<br>    }<br>    return [indexSet copy];<br>}<br>如果不使用block，从索引set中拿到所有的索引有点麻烦，getIndexes:maxCount:inIndexRange: 是最快的方法，其次是使用 firstIndex 并迭代直到 indexGreaterThanIndex: 返回 NSNotFound。随着 block 的到来，使用 NSIndexSet 工作变得方便的多:</p>
<p>NSArray <em>PSPDFArrayFromIndexSet(NSIndexSet </em>indexSet) {<br>    NSMutableArray <em>indexesArray = [NSMutableArray arrayWithCapacity:indexSet.count];<br>    [indexSet enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL </em>stop) {<br>       [indexesArray addObject:@(idx)];<br>    }];<br>    return [indexesArray copy];<br>}<br>NSIndexSet性能<br>Core Foundation 中没有和 NSIndexSet 相当的类，苹果也没有对性能做出任何承诺。NSIndexSet 和 NSSet 之间的比较也相对的不公平，因为常规的 set 需要对数字进行包装。为了缓解这个影响，这里的测试准备了实现包装好的 NSUintegers ，并且在两个循环中都会执行 unsignedIntegerValue:</p>
<p>类 / 时间 [ms]    1.000.000 elements    iOS 7x64 Simulator    iPad Mini iOS 6<br>NSMutableDictionary, adding    195.35    51.90    921.02<br>PSPDFThreadSafeMutableDictionary, adding    248.95    57.03    1043.79<br>NSCache, adding    557.68    395.92    1754.59<br>NSMutableDictionary, random access    6.82    2.31    23.70<br>PSPDFThreadSafeMutableDictionary, random access    9.09    2.80    32.33<br>NSCache, random access    9.01    29.06    53.25<br>我们看到在一百万左右对象的时候，NSIndexSet 开始变得比 NSSet 慢，但只是因为新的运行时和标签指针。在 iOS 6 上运行相同的测试表明，甚至在更高数量级实体的条件下，NSIndexSet 更快。实际上，在大多数应用中，你不会添加太多的整数到索引 set 中。还有一点这里没有测试，就是 NSIndexSet 跟 NSSet 比无疑有更好的内存优化。</p>
<p>结论<br>本文提供了一些真实的测试，使你在使用基础集合类的时候做出有根据的选择。除了上面讨论的类，还有一些不常用但确实有用的类，尤其是 NSCountedSet，CFBag，CFTree，CFBitVector和CFBinaryHeap。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/28/kvc-slash-kvoyuan-li-xiang-jie-ji-bian-cheng-zhi-nan/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/28/kvc-slash-kvoyuan-li-xiang-jie-ji-bian-cheng-zhi-nan/" itemprop="url">
                  [iOS]KVC/KVO原理详解及编程指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-28T17:48:12+08:00">
              2014-10-28
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/28/kvc-slash-kvoyuan-li-xiang-jie-ji-bian-cheng-zhi-nan/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/28/kvc-slash-kvoyuan-li-xiang-jie-ji-bian-cheng-zhi-nan/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##前言：</p>
<ol>
<li>本文基本不讲KVC/KVO的用法，只结合网上的资料说说对这种技术的理解。</li>
<li>由于KVO内容较少，而且是以KVC为基础实现的，本文将着重介绍KVC部分。</li>
</ol>
<p>##一、简介</p>
<p>KVC/KVO是观察者模式的一种实现，在Cocoa中是以被万物之源NSObject类实现的<code>NSKeyValueCoding/NSKeyValueObserving</code>非正式协议的形式被定义为基础框架的一部分。从协议的角度来说，KVC/KVO本质上是定义了一套让我们去遵守和实现的方法。</p>
<p>当然，KVC/KVO实现的根本是Objective-C的动态性和runtime，这在后文的原理部分会有详述。<br>另外，KVC/KVO机制离不开访问器方法的实现，这在后文中也有解释。</p>
<ol>
<li><p>KVC简介<br>全称是Key-value coding，翻译成键值编码。顾名思义，在某种程度上跟map的关系匪浅。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。</p>
</li>
<li><p>KVO简介<br>全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。</p>
</li>
</ol>
<p>##二、KVC相关技术</p>
<p>1.Key和Key Path</p>
<p>KVC定义了一种按名称访问对象属性的机制，支持这种访问的主要方法是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;  </div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;  </div><div class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;  </div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure>
<p>前边两个方法用到的Key较容易理解，就是要访问的属性名称对应的字符串。<br>后面两个方法用到的KeyPath是一个被点操作符隔开的用于访问对象的指定属性的字符串序列。比如KeyPath address.street将会访问消息接收对象所包含的address属性中包含的一个street属性。其实KeyPath说白了就是我们平时使用点操作访问某个对象的属性时所写的那个字符串。</p>
<p>2.点语法和KVC</p>
<p>在实现了访问器方法的类中，使用点语法和KVC访问对象其实差别不大，二者可以任意混用。但是没有访问起方法的类中，点语法无法使用，这时KVC就有优势了。（原因见第三部分的第一节：KVC如何访问属性值。）</p>
<p>3.一对多关系（To-Many）中的集合访问器方法</p>
<p>我们平时大部分使用的属性都是一对一关系（To-One）,比如Person类中的name属性，每个人只有一个名字。但也有一对多的关系，比如Person中有一个friendsName属性，这是个集合（在Objective-C中可以是NSArray，NSSet等），保存的是一个人的所有朋友的名字。</p>
<p>当操作一对多的属性中的内容时，我们有两种选择：</p>
<p>①间接操作<br>先通过KVC方法取到集合属性，然后通过集合属性操作集合中的元素。</p>
<p>②直接操作<br>苹果为我们提供了一些方法模板，我们可以以规定的格式实现这些方法来达到访问集合属性中元素的目的。</p>
<p>有序集合对应方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-countOf&lt;Key&gt;  <span class="comment">//必须实现，对应于NSArray的基本方法count:  </span></div><div class="line">-objectIn&lt;Key&gt;AtIndex:  </div><div class="line">-&lt;key&gt;AtIndexes:  <span class="comment">//这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes:  </span></div><div class="line">-get&lt;Key&gt;:range:  <span class="comment">//不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 getObjects:range:  </span></div><div class="line">-insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:  </div><div class="line">-insert&lt;Key&gt;:atIndexes:  <span class="comment">//两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes:  </span></div><div class="line">-removeObjectFrom&lt;Key&gt;AtIndex:  </div><div class="line">-remove&lt;Key&gt;AtIndexes:  <span class="comment">//两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:  </span></div><div class="line">-replaceObjectIn&lt;Key&gt;AtIndex:withObject:  </div><div class="line">-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:  <span class="comment">//可选的，如果在此类操作上有性能问题，就需要考虑实现之</span></div></pre></td></tr></table></figure>
<p>无序集合对应方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[java] view plaincopy</div><div class="line">-countOf&lt;Key&gt;  <span class="comment">//必须实现，对应于NSArray的基本方法count:  </span></div><div class="line">-objectIn&lt;Key&gt;AtIndex:  </div><div class="line">-&lt;key&gt;AtIndexes:  <span class="comment">//这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes:  </span></div><div class="line">-get&lt;Key&gt;:range:  <span class="comment">//不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 getObjects:range:  </span></div><div class="line">-insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:  </div><div class="line">-insert&lt;Key&gt;:atIndexes:  <span class="comment">//两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes:  </span></div><div class="line">-removeObjectFrom&lt;Key&gt;AtIndex:  </div><div class="line">-remove&lt;Key&gt;AtIndexes:  <span class="comment">//两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:  </span></div><div class="line">-replaceObjectIn&lt;Key&gt;AtIndex:withObject:  </div><div class="line">-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:  <span class="comment">//这两个都是可选的，如果在此类操作上有性能问题，就需要考虑实现之</span></div></pre></td></tr></table></figure>
<p>不过这些方法除非是很有需求，否则个人认为没有实现的必要，间接法也不是很麻烦，基本能满足需求了。值得指出的是，苹果甚至都没有让这些方法以哪怕是非正式协议的形式出现，而只是在编程指南中提了一下。</p>
<p>4.键值验证（Key-Value Validation）</p>
<p>KVC提供了验证Key对应的Value是否可用的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> *)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</div></pre></td></tr></table></figure>
<p>该方法默认的实现是调用一个如下格式的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validate&lt;Key&gt;:error:</div></pre></td></tr></table></figure>
<p>比如属性name对应的方法为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)validateName:(<span class="keyword">id</span> *)ioValue error:(<span class="built_in">NSError</span> * __autoreleasing *)outError &#123;  </div><div class="line">    <span class="comment">// Implementation specific code.  </span></div><div class="line">    <span class="keyword">return</span> ...;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就给了我们一次纠错的机会。需要指出的是，KVC是不会自动调用键值验证方法的，就是说我们需要手动验证。但是有些技术，比如CoreData会自动调用。</p>
<p>5.KVC对数值和结构体型属性的支持</p>
<p>一套机制如果不支持数值和结构体型的数据，那么它的实用性就会大大折扣。幸运的是KVC中苹果对这方面的支持做的很好。KVC可以自动的将数值或结构体型的数据打包或解包成<code>NSNumber</code>或<code>NSValue</code>对象，以达到适配的目的。</p>
<p>举个例子，Person类有个个<code>NSInteger</code>类型的age属性</p>
<p>①修改值</p>
<p>我们通过KVC技术使用如下方式设置age属性的值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person setValue:[<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">5</span>] forKey:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure>
<p>我们赋给age的是一个<code>NSNumber</code>对象，KVC会自动的将<code>NSNumber</code>对象转换成<code>NSInteger</code>对象，然后再调用相应的访问器方法设置age的值。</p>
<p>②获取值</p>
<p>同样，以如下方式获取age属性值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person valueForKey:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure>
<p>这时，会以NSNumber的形式返回age的值。需要说明的是，什么时候返回的是NSNumber，什么时候返回的是NSValue？</p>
<p>③使用<code>NSNumber</code>封装</p>
<p>可以使用NSNumber的数据类型有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithChar:(<span class="keyword">char</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedChar:(<span class="keyword">unsigned</span> <span class="keyword">char</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithShort:(<span class="keyword">short</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedShort:(<span class="keyword">unsigned</span> <span class="keyword">short</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithInt:(<span class="keyword">int</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedInt:(<span class="keyword">unsigned</span> <span class="keyword">int</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithLong:(<span class="keyword">long</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedLong:(<span class="keyword">unsigned</span> <span class="keyword">long</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithLongLong:(<span class="keyword">long</span> <span class="keyword">long</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedLongLong:(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithFloat:(<span class="keyword">float</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithDouble:(<span class="keyword">double</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithBool:(<span class="built_in">BOOL</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithInteger:(<span class="built_in">NSInteger</span>)value <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedInteger:(<span class="built_in">NSUInteger</span>)value <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</div></pre></td></tr></table></figure>
<p>总之就是一些常见的数值型数据。</p>
<p>④使用<code>NSValue</code>封装</p>
<p><code>NSValue</code>主要用于处理结构体型的数据，它本身提供了如下集中结构的支持：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithCGPoint:(<span class="built_in">CGPoint</span>)point;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithCGSize:(<span class="built_in">CGSize</span>)size;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithCGRect:(<span class="built_in">CGRect</span>)rect;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithCGAffineTransform:(<span class="built_in">CGAffineTransform</span>)transform;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithUIEdgeInsets:(<span class="built_in">UIEdgeInsets</span>)insets;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithUIOffset:(<span class="built_in">UIOffset</span>)insets <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure>
<p>只有有限的6种而已！那对于其它自定义的结构体怎么办？别担心，任何结构体都是可以转化成NSValue对象的，具体实现方法参见我之前的一篇文章：<br><a href="http://blog.csdn.net/wzzvictory/article/details/8614433" target="_blank" rel="external">http://blog.csdn.net/wzzvictory/article/details/8614433</a></p>
<p>6.集合运算符（Collection Operators）</p>
<p>集合运算符是一个特殊的Key Path，可以作为参数传递给<code>valueForKeyPath:</code>方法，注意只能是这个方法，如果传给了<code>valueForKey:</code>方法保证你程序崩溃。</p>
<p>运算符是一个以@开头的特殊字符串，格式如下图所示：</p>
<p>①简单集合运算符</p>
<p>简单集合运算符共有<code>@avg</code>，<code>@count</code>，<code>@max</code>，<code>@min</code>，<code>@sum</code>5种，都表示啥不用我说了吧，目前还不支持自定义。<br>有一个集合类的对象：transactions，它存储了一个个的Transaction类的实例，该类有三个属性：payee，amount，date。下面以此为例说明如何使用这些运算符：<br>要获取amount的平均值可以这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *transactionAverage = [transactions valueForKeyPath:<span class="string">@"@avg.amount"</span>];</div></pre></td></tr></table></figure>
<p>要获取transactions集合中元素数目可以这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *numberOfTransactions = [transactions valueForKeyPath:<span class="string">@"@count"</span>];</div></pre></td></tr></table></figure>
<p>需要之处的是，@count是这些集合运算符中比较特殊的一个，因为它没有右路经，原因很容易理解。</p>
<p>②对象运算符</p>
<p>比集合运算符稍微复杂，能以数组的方式返回指定的内容，一共有两种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@distinctUnionOfObjects  </div><div class="line">@unionOfObjects</div></pre></td></tr></table></figure>
<p>它们的返回值都是NSArray，区别是前者返回的元素都是唯一的，是去重以后的结果；后者返回的元素是全集。<br>用法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *payees = [transactions valueForKeyPath:<span class="string">@"@distinctUnionOfObjects.payee"</span>];  </div><div class="line"><span class="built_in">NSArray</span> *payees = [transactions valueForKeyPath:<span class="string">@"@unionOfObjects.payee"</span>];</div></pre></td></tr></table></figure>
<p>前者会将收款人的姓名去除重复的以后返回，后者直接返回所有收款人的姓名。</p>
<p>③Array和Set操作符</p>
<p>这种情况更复杂了，说的是集合中包含集合的情况，我们执行了如下的一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create the array that contains additional arrays.  </span></div><div class="line"><span class="keyword">self</span>.arrayOfTransactionsArray = [<span class="built_in">NSMutableArray</span> array];  </div><div class="line"><span class="comment">// Add the array of objects used in the above examples.  </span></div><div class="line">[arrayOfTransactionsArray addObject:transactions];  </div><div class="line"><span class="comment">// Add a second array of objects; this array contains alternate values.  </span></div><div class="line">[arrayOfTransactionsArrays addObject:moreTransactions];</div></pre></td></tr></table></figure>
<p>得到了一个包含集合的集合：<code>arrayOfTransactionsArray</code>, 这时如果我们想操作<code>arrayOfTransactionsArray</code>中包含的集合中的元素时，可以使用如下三个运算符：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@distinctUnionOfArrays  </div><div class="line">@unionOfArrays  </div><div class="line">@distinctUnionOfSets</div></pre></td></tr></table></figure>
<p>前两个针对的集合是Arrays，后一个针对的集合是Sets。因为Sets中的元素本身就是唯一的，所以没有对应的<code>@unionOfSets</code>运算符。</p>
<p>它们的用法举例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *payees = [arrayOfTransactionsArrays valueForKeyPath:<span class="string">@"@unionOfArrays.payee"</span>];</div></pre></td></tr></table></figure>
<p>##三、实现原理</p>
<p>1.KVC如何访问属性值</p>
<p>KVC再某种程度上提供了访问器的替代方案。不过访问器方法是一个很好的东西，以至于只要是有可能，KVC也尽量再访问器方法的帮助下工作。为了设置或者返回对象属性，KVC按顺序使用如下技术：</p>
<p>①检查是否存在<code>-&lt;key&gt;</code>、<code>-is&lt;key&gt;</code>（只针对布尔值有效）或者<code>-get&lt;key&gt;</code>的访问器方法，如果有可能，就是用这些方法返回值；</p>
<p>检查是否存在名为-set<key>:的方法，并使用它做设置值。对于<code>-get&lt;key&gt;</code>和<code>-set&lt;key&gt;:</code>方法，将大写Key字符串的第一个字母，并与Cocoa的方法命名保持一致；</key></p>
<p>②如果上述方法不可用，则检查名为<code>-_&lt;key&gt;</code>、<code>-_is&lt;key&gt;</code>（只针对布尔值有效）、<code>-_get&lt;key&gt;</code>和-<code>_set&lt;key&gt;:</code>方法；</p>
<p>③如果没有找到访问器方法，可以尝试直接访问实例变量。实例变量可以是名为：<code>&lt;key&gt;</code>或<code>_&lt;key&gt;</code>;</p>
<p>④如果仍为找到，则调用<code>valueForUndefinedKey:</code>和<code>setValue:forUndefinedKey:</code>方法。这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</p>
<p>2.KVC/KVO实现原理</p>
<p>键值编码和键值观察是根据<code>isa-swizzling</code>技术来实现的，主要依据runtime的强大动态能力。下面的这段话是引自网上的一篇文章：<br><a href="http://blog.csdn.net/kesalin/article/details/8194240" target="_blank" rel="external">http://blog.csdn.net/kesalin/article/details/8194240</a></p>
<p>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。</p>
<p>派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。</p>
<p>同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。</p>
<p>原文写的很好，还举了解释性的例子，大家可以去看看。</p>
<p>在我之前的一篇介绍Objective-C类和元类的文章：<br><a href="http://blog.csdn.net/wzzvictory/article/details/8592492" target="_blank" rel="external">http://blog.csdn.net/wzzvictory/article/details/8592492</a><br>中介绍过，isa指针指向的其实是类的元类，如果之前的类名为：Person，那么被runtime更改以后的类名会变成：<code>NSKVONotifying_Person</code>。</p>
<p>新的<code>NSKVONotifying_Person</code>类会重写以下方法：</p>
<p>增加了监听的属性对应的set方法，<code>class</code>，<code>dealloc</code>，<code>_isKVOA</code>。</p>
<p>①class<br>重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。打印如下内容：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"self-&gt;isa:%@"</span>,<span class="keyword">self</span>-&gt;isa);  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"self class:%@"</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]);</div></pre></td></tr></table></figure>
<p>在建立KVO监听前，打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>-&gt;isa:Person  </div><div class="line"><span class="keyword">self</span> <span class="keyword">class</span>:Person</div></pre></td></tr></table></figure>
<p>在建立KVO监听之后，打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>-&gt;isa:<span class="built_in">NSKVONotifying_Person</span>  </div><div class="line"><span class="keyword">self</span> <span class="keyword">class</span>:Person</div></pre></td></tr></table></figure>
<p>这也是isa指针和class方法的一个区别，大家使用的时候注意。</p>
<p>②重写set方法</p>
<p>新类会重写对应的set方法，是为了在set方法中增加另外两个方法的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key  </div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>其中，<code>didChangeValueForKey:</code>方法负责调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath  </div><div class="line">                      ofObject:(<span class="keyword">id</span>)object  </div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change  </div><div class="line">                       context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>方法，这就是KVO实现的原理了！</p>
<p>如果没有任何的访问器方法，<code>-setValue:forKey</code>方法会直接调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key  </div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>如果在没有使用键值编码且没有使用适当命名的访问起方法的时候，我们只需要显示调用上述两个方法，同样可以使用KVO！</p>
<p>总结一下，想使用KVO有三种方法：</p>
<p>1)使用了KVC</p>
<p>使用了KVC，如果有访问器方法，则运行时会在访问器方法中调用<code>will/didChangeValueForKey:</code>方法；<br>没用访问器方法，运行时会在<code>setValue:forKey</code>方法中调用<code>will/didChangeValueForKey:</code>方法。</p>
<p>2)有访问器方法</p>
<p>运行时会重写访问器方法调用<code>will/didChangeValueForKey:</code>方法。因此，直接调用访问器方法改变属性值时，KVO也能监听到。</p>
<p>3)显示调用<code>will/didChangeValueForKey:</code>方法。</p>
<p>总之，想使用KVO，只要有<code>will/didChangeValueForKey:</code>方法就可以了。</p>
<p>③_isKVOA</p>
<p>这个私有方法估计是用来标示该类是一个 KVO 机制声称的类。</p>
<p>##四、优点和缺点</p>
<p>1.优点</p>
<p>①可以再很大程度上简化代码</p>
<p>例子网上很多，这就不举了</p>
<p>②能跟脚本语言很好的配合</p>
<p>才疏学浅，没学过AppleScript等脚本语言，所以没能深刻体会到该优点。</p>
<p>2.缺点</p>
<p>KVC的缺点不明显，主要是KVO的，详情可以参考这篇文章：<br><a href="http://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="external">http://www.mikeash.com/pyblog/key-value-observing-done-right.html</a></p>
<p>核心思想是说KVO的回调机制，不能传一个selector或者block作为回调，而必须重写-<code>addObserver:forKeyPath:options:context:</code>方法所引发的一系列问题。问了解决这个问题，作者还亲自实现了一个<code>MAKVONotificationCenter</code>类，代码见<a href="github:
https://github.com/mikeash/MAKVONotificationCenter" target="_blank" rel="external">github:
https://github.com/mikeash/MAKVONotificationCenter</a>不过个人认为这只是苹果做的KVO不够完美，不能算是缺陷。</p>
<p>参考文档：</p>
<p><a href="http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1
http://blog.csdn.net/kesalin/article/details/8194240" target="_blank" rel="external">http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1
http://blog.csdn.net/kesalin/article/details/8194240</a></p>
<p>作者：wangzz</p>
<p>原文地址：<a href="http://blog.csdn.net/wzzvictory/article/details/9674431" target="_blank" rel="external">http://blog.csdn.net/wzzvictory/article/details/9674431</a></p>
<p>转载请注明出处</p>
<p>如果觉得文章对你有所帮助，请通过留言或关注微信公众帐号wangzzstrive来支持我，谢谢！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/23/ios-ioskai-fa-zhi-bridge,-bridge-transferhe-bridge-retained/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/23/ios-ioskai-fa-zhi-bridge,-bridge-transferhe-bridge-retained/" itemprop="url">
                  [iOS]IOS开发之__bridge，__bridge_transfer和__bridge_retained
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-23T14:18:25+08:00">
              2014-10-23
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/23/ios-ioskai-fa-zhi-bridge,-bridge-transferhe-bridge-retained/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/23/ios-ioskai-fa-zhi-bridge,-bridge-transferhe-bridge-retained/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Core Foundation 框架<br>Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。下面列举该框架支持进行管理的数据以及可提供的服务：</p>
<ol>
<li>群体数据类型 (数组、集合等)</li>
<li>程序包</li>
<li>字符串管理</li>
<li>日期和时间管理</li>
<li>原始数据块管理</li>
<li>偏好管理</li>
<li>URL及数据流操作</li>
<li>线程和RunLoop</li>
<li>端口和soket通讯</li>
</ol>
<p>Core Foundation框架和Foundation框架紧密相关，它们为相同功能提供接口，但Foundation框架提供Objective-C接口。如果您将Foundation对象和Core Foundation类型掺杂使用，则可利用两个框架之间的 “toll-free bridging”。所谓的Toll-free bridging是说您可以在某个框架的方法或函数同时使用Core Foundatio和Foundation 框架中的某些类型。很多数据类型支持这一特性，其中包括群体和字符串数据类型。每个框架的类和类型描述都会对某个对象是否为 toll-free bridged，应和什么对象桥接进行说明。<br>如需进一步信息，请阅读Core Foundation 框架参考。</p>
<p>自 Xcode4.2 开始导入ARC机制后，为了支持对象间的转型，Apple又增加了许多转型用的关键字。这一讲我们就来了解其用法，以及产生的理由。</p>
<p>###引子<br>我们先来看一下ARC无效的时候，我们写id类型转void*类型的写法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = obj;</div></pre></td></tr></table></figure>
<p>反过来，当把void*对象变回id类型时，只是简单地如下来写，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = p;</div><div class="line">[obj release];</div></pre></td></tr></table></figure>
<p>但是上面的代码在ARC有效时，就有了下面的错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">error: implicit conversion of an Objective-C pointer</div><div class="line">    to ’<span class="keyword">void</span> *’ is disallowed with ARC</div><div class="line">    <span class="keyword">void</span> *p = obj;</div><div class="line">              ^</div><div class="line"> </div><div class="line">error: implicit conversion of a non-Objective-C pointer</div><div class="line">    type ’<span class="keyword">void</span> *’ to ’<span class="keyword">id</span>’ is disallowed with ARC</div><div class="line">    <span class="keyword">id</span> o = p;</div><div class="line">            ^</div></pre></td></tr></table></figure>
<p>###<strong>bridge<br>为了解决这一问题，我们使用 </strong>bridge 关键字来实现id类型与void*类型的相互转换。看下面的例子。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;</div><div class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;</div></pre></td></tr></table></figure>
<p>将Objective-C的对象类型用 <strong>bridge 转换为 void* 类型和使用 </strong>unsafe_unretained 关键字修饰的变量是一样的。被代入对象的所有者需要明确对象生命周期的管理，不要出现异常访问的问题。<br>除过 <strong>bridge 以外，还有两个 </strong>bridge 相关的类型转换关键字：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__bridge_transfer</div><div class="line">__bridge_retained</div></pre></td></tr></table></figure>
<p>接下来，我们将看看这两个关键字的区别。</p>
<p>###<strong>bridge_retained<br>先来看使用 </strong>bridge_retained 关键字的例子程序：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)obj;</div></pre></td></tr></table></figure>
<p>从名字上我们应该能理解其意义：类型被转换时，其对象的所有权也将被变换后变量所持有。如果不是ARC代码，类似下面的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = obj;</div><div class="line">[(<span class="keyword">id</span>)p <span class="keyword">retain</span>];</div></pre></td></tr></table></figure>
<p>可以用一个实际的例子验证，对象所有权是否被持有。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    p = (__bridge_retained <span class="keyword">void</span> *)obj;</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);</div></pre></td></tr></table></figure>
<p>出了大括号的范围后，p 仍然指向一个有效的实体。说明他拥有该对象的所有权，该对象没有因为出其定义范围而被销毁。</p>
<p>###<strong>bridge_transfer<br>相反，当想把本来拥有对象所有权的变量，在类型转换后，让其释放原先所有权的时候，需要使用</strong>bridge_transfer 关键字。文字有点绕口，我们还是来看一段代码吧。</p>
<p>如果ARC无效的时候，我们可能需要写下面的代码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p 变量原先持有对象的所有权</span></div><div class="line"><span class="keyword">id</span> obj = (<span class="keyword">id</span>)p;</div><div class="line">[obj <span class="keyword">retain</span>];</div><div class="line">[(<span class="keyword">id</span>)p release];</div></pre></td></tr></table></figure>
<p>那么ARC有效后，我们可以用下面的代码来替换：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p 变量原先持有对象的所有权</span></div><div class="line"><span class="keyword">id</span> obj = (__bridge_transfer <span class="keyword">id</span>)p;</div><div class="line">可以看出来，__bridge_retained 是编译器替我们做了 <span class="keyword">retain</span> 操作，而 __bridge_transfer 是替我们做了 release1。</div></pre></td></tr></table></figure>
<p>###Toll-Free bridged<br>在iOS世界，主要有两种对象：Objective-C 对象和 Core Foundation 对象0。Core Foundation 对象主要是有C语言实现的 Core Foundation Framework 的对象，其中也有对象引用计数的概念，只是不是 Cocoa Framework::Foundation Framework 的 retain/release，而是自身的 CFRetain/CFRelease 接口。</p>
<p>这两种对象间可以互相转换和操作，不使用ARC的时候，单纯的用C原因的类型转换，不需要消耗CPU的资源，所以叫做 Toll-Free bridged。比如 NSArray和CFArrayRef, NSString和CFStringRef，他们虽然属于不同的 Framework，但是具有相同的对象结构，所以可以用标准C的类型转换。</p>
<p>比如不使用ARC时，我们用下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:...];</div><div class="line"><span class="built_in">CFStringRef</span> cfString = (<span class="built_in">CFStringRef</span>)string;</div></pre></td></tr></table></figure>
<p>同样，Core Foundation类型向Objective-C类型转换时，也是简单地用标准C的类型转换即可。<br>但是在ARC有效的情况下，将出现类似下面的编译错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Cast of Objective-C pointer type ‘<span class="built_in">NSString</span> *’ to C pointer type ‘<span class="built_in">CFStringRef</span>’ (aka ‘<span class="keyword">const</span> <span class="keyword">struct</span> __CFString *’) requires a bridged cast</div><div class="line">Use __bridge to convert directly (no change <span class="keyword">in</span> ownership)</div><div class="line">Use __bridge_retained to make an ARC object available as a +<span class="number">1</span> ‘<span class="built_in">CFStringRef</span>’ (aka ‘<span class="keyword">const</span> <span class="keyword">struct</span> __CFString *’)</div></pre></td></tr></table></figure>
<p>错误中已经提示了我们需要怎样做：用 <strong>bridge 或者 </strong>bridge_retained 来转型，其差别就是变更对象的所有权。</p>
<p>正因为Objective-C是ARC管理的对象，而Core Foundation不是ARC管理的对象，所以才要特意这样转换，这与id类型向void*转换是一个概念。也就是说，当这两种类型（有ARC管理，没有ARC管理）在转换时，需要告诉编译器怎样处理对象的所有权。</p>
<p>上面的例子，使用 <strong>bridge/</strong>bridge_retained 后的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:...];</div><div class="line"><span class="built_in">CFStringRef</span> cfString = (__bridge <span class="built_in">CFStringRef</span>)string;</div></pre></td></tr></table></figure>
<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当string对象被释放的时候，cfString也不能被使用了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:...];</div><div class="line"><span class="built_in">CFStringRef</span> cfString = (__bridge_retained <span class="built_in">CFStringRef</span>)string;</div><div class="line">...</div><div class="line"><span class="built_in">CFRelease</span>(cfString); <span class="comment">// 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release</span></div></pre></td></tr></table></figure>
<p>使用 __bridge_retained 可以通过转换目标处（cfString）的 retain 处理，来使所有权转移。即使 string 变量被释放，cfString 还是可以使用具体的对象。只是有一点，由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release。</p>
<p>实际上，Core Foundation 内部，为了实现Core Foundation对象类型与Objective-C对象类型的相互转换，提供了下面的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">CFTypeRef  <span class="title">CFBridgingRetain</span><span class="params">(id  X)</span>  </span>&#123;</div><div class="line">    <span class="keyword">return</span>  (__bridge_retained  CFTypeRef)X;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">id  <span class="title">CFBridgingRelease</span><span class="params">(CFTypeRef  X)</span>  </span>&#123;</div><div class="line">    <span class="keyword">return</span>  (__bridge_transfer  id)X;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，可以用 CFBridgingRetain 替代 __bridge_retained 关键字：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:...];</div><div class="line"><span class="built_in">CFStringRef</span> cfString = <span class="built_in">CFBridgingRetain</span>(string);</div><div class="line">...</div><div class="line"><span class="built_in">CFRelease</span>(cfString); <span class="comment">// 由于Core Foundation不在ARC管理范围内，所以需要主动release。</span></div></pre></td></tr></table></figure>
<p>###<strong>bridge_transfer<br>所有权被转移的同时，被转换变量将失去对象的所有权。当Core Foundation对象类型向Objective-C对象类型转换的时候，会经常用到 </strong>bridge_transfer 关键字。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> cfString = <span class="built_in">CFStringCreate</span>...();</div><div class="line"><span class="built_in">NSString</span> *string = (__bridge_transfer <span class="built_in">NSString</span> *)cfString;</div><div class="line"><span class="comment">// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release</span></div></pre></td></tr></table></figure>
<p>同样，我们可以使用 CFBridgingRelease() 来代替 __bridge_transfer 关键字。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> cfString = <span class="built_in">CFStringCreate</span>...();</div><div class="line"><span class="built_in">NSString</span> *string = <span class="built_in">CFBridgingRelease</span>(cfString);</div></pre></td></tr></table></figure>
<p>###总结<br>由上面的学习我们了解到 ARC 中类型转换的用法，那么我们实际使用中按照怎样的原则或者方法来区分使用呢，下面我总结了几点关键要素。</p>
<p>明确被转换类型是否是 ARC 管理的对象</p>
<p>Core Foundation 对象类型不在 ARC 管理范畴内</p>
<p>Cocoa Framework::Foundation 对象类型（即一般使用到的Objectie-C对象类型）在 ARC 的管理范畴内<br>如果不在 ARC 管理范畴内的对象，那么要清楚 release 的责任应该是谁。</p>
<p>各种对象的生命周期是怎样的</p>
<ol>
<li>声明 id obj 的时候，其实是缺省的申明了一个 <strong>strong 修饰的变量，所以编译器自动地加入了 retain 的处理，所以说 </strong>bridge_transfer 关键字只为我们做了 release 处理。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar/avatar.jpg"
               alt="姜楠" />
          <p class="site-author-name" itemprop="name">姜楠</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">115</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/njiang1987" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姜楠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"njiang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
