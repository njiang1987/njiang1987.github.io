<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="天空の城">
<meta property="og:url" content="http://www.njiang.cn/page/5/index.html">
<meta property="og:site_name" content="天空の城">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天空の城">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.njiang.cn/page/5/"/>





  <title> 天空の城 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-43682645-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">天空の城</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">愤怒的程序员，梦想着有一天也能飞！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/31/2014-10-iOS-基础集合类/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/31/2014-10-iOS-基础集合类/" itemprop="url">
                  [iOS]基础集合类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-31T15:37:24+08:00">
              2014-10-31
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/31/2014-10-iOS-基础集合类/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/31/2014-10-iOS-基础集合类/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSArray, NSSet, NSOrderedSet 和 NSDictionary<br>基础集合类是每一个 Mac/iOS 应用的基本组成部分。在本文中，我们将对”老类” (NSArray, NSSet)和”新类” (NSMapTable, NSHashTable, NSPointerArray) 进行一个深入的研究，探索每一个的效率细节，并讨论其使用场景。</p>
<p>作者提示：本文包含一些参照结果，但它们并不意味着绝对精确，也没有进行均差分析及多次的测试。这些结果的目的是给出运行时统计，来帮助我们认识到通常来说用什么会更快。所有的测试基于 iPhone 5s，使用 Xcode 5.1b1 和 iOS 7.1b1 的 64 位程序。编译选项设置为 -Ofast 的发布构建。Vectorize loops 和 unroll loops (默认设置) 均设置为关闭。</p>
<p>大 O 符号，算法复杂度计量<br>首先，我们需要一些理论知识。效率通常用大 O 符号描述。它定义了一个函数的极限特征，通常被用于描绘其算法效率。O 定义了函数增长率的上限。不同量级的差异非常巨大，可以看看通常使用的 O 符号的量级以及它们所对应需要的操作数的关系。</p>
<p>例如，如果用算法复杂度为 O(n^2)的算法对一个有 50 个元素的数组排序，需要 2,500 步的操作。而且，还有内部的系统开销和方法调用 — 所以是 250 0个操作的时间常量。 O(1)是理想的复杂度，代表着恒定的时间。好的排序算法通常需要 O(n*log n) 的时间。</p>
<p>可变性<br>大多数的集合类存在两个版本:可变和不可变(默认)。这和其他大多数的框架有非常大的不同，一开始会让人觉得有一点奇怪。然而其他的框架现在也应用了这一特性：就在几个月前，.NET公布了作为官方扩展的不可变集合。</p>
<p>最大的好处是什么？线程安全。不可变的集合完全是线程安全的，可以同时在多个线程中迭代，避免各种转变时出现异常的风险。你的 API 绝不应该暴露一个可变的集合。</p>
<p>当然从不可变到可变然后再回来是会有一定代价的 — 对象必须被拷贝两次，所有集合内的对象将被 retain/release。有时在内部使用一个可变的集合，而在访问时返回一个不可变的对象副本会更高效。</p>
<p>与其他框架不同的是，苹果没有提供一个线程安全的可变集合，NSCache 是例外，但它真的算不上是集合类，因为它不是一个通用的容器。大多数时候，你不会需要在集合层级的同步特性。想象一段代码，作用是检查字典中一个 key 是否存在，并根据检查结果决定设置一个新的 key 或者返回某些值 — 你通常需要把多个操作归类，这时线程安全的可变集合并不能对你有所帮助。</p>
<p>其实也有一些同步的，线程安全的可以使用的可变集合案例，它们往往只需要用几行代码，通过子类和组合的方法建立，比如这个 NSDictionary 或这个 NSArray。</p>
<p>需要注意的是，一些较新的集合类，如 NSHashTable，NSMapTable 和 NSPointerArray 默认就是可变的，它们并没有对应的不可变的类。它们用于类的内部使用，你基本应该不会能找到需要它们的不可变版本的应用场景。</p>
<p>NSArray<br>NSArray 作为一个存储对象的有序集合，可能是被使用最多的集合类。这也是为什么它有自己的比原来的 [NSArray arrayWithObjects:…, nil] 简短得多的快速语法糖符号 @[…]。 NSArray 实现了 objectAtIndexedSubscript:，因为我们可以使用类 C 的语法 array[0] 来代替原来的 [array objectAtIndex:0]。</p>
<p>性能特征<br>关于 NSArray 的内容比你想象的要多的多。基于存储对象的多少，它使用各种内部的变体。最有趣的部分是苹果对于个别的对象访问并不保证 O(1) 的访问时间 — 正如你在 CFArray.h CoreFoundation 头文件中的关于算法复杂度的注解中可以读到的:</p>
<p>对于 array 中值的访问时间，不管是在现在还是将来，我们保证在任何一种实现下最坏情况是 O(lg N)。但是通常来说它会是 O(1) (常数时间)。线性搜索操作很可能在最坏情况下的复杂度为 O(N<em>lg N)，但通常来说上限会更小一些。插入和删除操作耗时通常和数组中的值的数量成线性关系。但在某些实现的最坏情况下会是 O(N</em>lg N) 。在数组中，没有对于性能上特别有优势的数据位置，也就是说，为了更快地访问到元素而将其设为在较低的 index 上，或者在较高的 index 上进行插入和删除，或者类似的一些做法，是没有必要的。</p>
<p>在测量的时候，NSArray 产生了一些有趣的额外的性能特征。在数组的开头和结尾插入/删除元素通常是一个 O(1)操作，而随机的插入/删除通常是 O(N) 的。</p>
<p>有用的方法<br>NSArray 的大多数方法使用 isEqual: 来检查对象间的关系(例如 containsObject: 中)。有一个特别的方法 indexOfObjectIdenticalTo: 用来检查指针相等，如果你确保在同一个集合中搜索，那么这个方法可以很大的提升搜索速度。 在 iOS 7 中，我们最终得到了与 lastObject 对应的公开的 firstObject 方法，对于空数组，这两个方法都会返回 nil — 而常规的访问方法会抛出一个 NSRangeException 异常。</p>
<p>关于构造（可变）数组有一个漂亮的细节可以节省代码量。如果你通过一个可能为 nil 的数组创建一个可变数组，通常会这么写:</p>
<p>NSMutableArray *mutableObjects = [array mutableCopy];<br>if (!mutableObjects) {<br>    mutableObjects = [NSMutableArray array];<br>}<br>或者通过更简洁的三元运算符:</p>
<p>NSMutableArray *mutableObjects = [array mutableCopy] ?: [NSMutableArray array];<br>更好的解决方案是使用arrayWithArray:，即使原数组为nil，该方法也会返回一个数组对象:</p>
<p>NSMutableArray *mutableObjects = [NSMutableArray arrayWithArray:array];<br>这两个操作在效率上几乎相等。使用 copy 会快一点点，不过话说回来，这不太可能是你应用的瓶颈所在。提醒：不要使用 [@[] mutableCopy]。经典的[NSMutableArray array]可读性更好。</p>
<p>逆序一个数组非常简单：array.reverseObjectEnumerator.allObjects。我们使用系统提供的 reverseObjectEnumerator，每一个 NSEnumerator 都实现了 allObjects，该方法返回一个新数组。虽然没有原生的 randomObjectEnumerator 方法，你可以写一个自定义的打乱数组顺序的枚举器或者使用一些出色的开源代码。</p>
<p>数组排序<br>有很多各种各样的方法来对一个数组排序。如果数组存储的是字符串对象，sortedArrayUsingSelector:是第一选择:</p>
<p>NSArray <em>array = @[@”John Appleseed”, @”Tim Cook”, @”Hair Force One”, @”Michael Jurewitz”];<br>NSArray </em>sortedArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];<br>下面的代码对存储数字的内容同样很好，因为 NSNumber 实现了 compare::</p>
<p>NSArray <em>numbers = @[@9, @5, @11, @3, @1];<br>NSArray </em>sortedNumbers = [numbers sortedArrayUsingSelector:@selector(compare:)];<br>如果想更可控，可以使用基于函数指针的排序方法:</p>
<ul>
<li>(NSData *)sortedArrayHint;</li>
<li>(NSArray <em>)sortedArrayUsingFunction:(NSInteger (</em>)(id, id, void *))comparator<pre><code>context:(void *)context;
</code></pre></li>
<li>(NSArray <em>)sortedArrayUsingFunction:(NSInteger (</em>)(id, id, void *))comparator<pre><code>context:(void *)context hint:(NSData *)hint;
</code></pre>苹果增加了一个方法来加速使用 sortedArrayHint 的排序。</li>
</ul>
<p>hinted sort 方式在你有一个已排序的大数组 (N 个元素) 并且只改变其中一小部分（P 个添加和删除，这里 P远小于 N）时，会非常有效。你可以重用原来的排序结果，然后在 N 个老项目和 P 个新项目进行一个概念上的归并排序。为了得到合适的 hint，你应该在原来的数组排序后使用 sortedArrayHint 来在你需要的时候(比如在数组改变后想重新排序时)保证持有它。</p>
<p>因为block的引入，也出现了一些基于block的排序方法:</p>
<ul>
<li>(NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;</li>
<li>(NSArray *)sortedArrayWithOptions:(NSSortOptions)opts<pre><code>usingComparator:(NSComparator)cmptr;
</code></pre>性能上来说，不同的方法间并没有太多的不同。有趣的是，基于 selector 的方式是最快的。你可以在 GitHub 上找到测试用的源代码:</li>
</ul>
<p>Sorting 1000000 elements. selector: 4947.90[ms] function: 5618.93[ms] block: 5082.98[ms].</p>
<p>二分查找<br>NSArray 从 iOS 4 / Snow Leopard 开始内置了二分查找</p>
<p>typedef NS_OPTIONS(NSUInteger, NSBinarySearchingOptions) {<br>    NSBinarySearchingFirstEqual     = (1UL &lt;&lt; 8),<br>    NSBinarySearchingLastEqual      = (1UL &lt;&lt; 9),<br>    NSBinarySearchingInsertionIndex = (1UL &lt;&lt; 10),<br>};</p>
<ul>
<li>(NSUInteger)indexOfObject:(id)obj<pre><code>  inSortedRange:(NSRange)r
        options:(NSBinarySearchingOptions)opts
usingComparator:(NSComparator)cmp;
</code></pre>为什么要使用这个方法？类似 containsObject: 和 indexOfObject: 这样的方法从 0 索引开始搜索每个对象直到找到目标 — 这样不需要数组被排序，但是却是 O(n)的效率特性。如果使用二分查找的话，需要数组事先被排序，但在查找时只需要 O(log n) 的时间。因此，对于 一百万条记录，二分查找法最多只需要 21 次比较，而传统的线性查找则平均需要 500,000 次的比较。</li>
</ul>
<p>这是个简单的衡量二分查找有多快的数据:</p>
<p>Time to search for 1000 entries within 1000000 objects. Linear: 54130.38[ms]. Binary: 7.62[ms]<br>作为比较，查找 NSOrderedSet 中的指定索引花费 0.23 毫秒 — 就算和二分查找相比也又快了 30 多倍。</p>
<p>记住排序的开销也是昂贵的。苹果使用复杂度为 O(n*log n) 的归并排序，所以如果你执行一次 indexOfObject: 的话，就没有必要使用二分查找了。</p>
<p>通过指定 NSBinarySearchingInsertionIndex，你可以获得正确的插入索引，以确保在插入元素后仍然可以保证数组的顺序。</p>
<p>枚举和总览<br>作为测试，我们来看一个普通的使用场景。从一个数组中过滤出一些元素组成另一个数组。这些测试都包括了枚举的方法以及使用 API 进行过滤的方式：</p>
<p>// 第一种方式，使用 <code>indexesOfObjectsWithOptions:passingTest:</code>.<br>NSIndexSet <em>indexes = [randomArray indexesOfObjectsWithOptions:NSEnumerationConcurrent<br>                                               passingTest:^BOOL(id obj, NSUInteger idx, BOOL </em>stop) {<br>    return testObj(obj);<br>}];<br>NSArray *filteredArray = [randomArray objectsAtIndexes:indexes];</p>
<p>// 使用 predicate 过滤，包括 block 的方式和文本 predicate 的方式<br>NSArray <em>filteredArray2 = [randomArray filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id obj, NSDictionary </em>bindings) {<br>    return testObj(obj);<br>}]];</p>
<p>// 基于 block 的枚举<br>NSMutableArray <em>mutableArray = [NSMutableArray array];<br>[randomArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL </em>stop) {<br>    if (testObj(obj)) {<br>        [mutableArray addObject:obj];<br>    }<br>}];</p>
<p>// 传统的枚举<br>NSMutableArray *mutableArray = [NSMutableArray array];<br>for (id obj in randomArray) {<br>    if (testObj(obj)) {<br>        [mutableArray addObject:obj];<br>    }<br>}</p>
<p>// 使用 NSEnumerator，传统学院派<br>NSMutableArray <em>mutableArray = [NSMutableArray array];<br>NSEnumerator </em>enumerator = [randomArray objectEnumerator];<br>id obj = nil;<br>while ((obj = [enumerator nextObject]) != nil) {<br>    if (testObj(obj)) {<br>        [mutableArray addObject:obj];<br>    }<br>}</p>
<p>// 通过下标使用 objectAtIndex：<br>NSMutableArray *mutableArray = [NSMutableArray array];<br>for (NSUInteger idx = 0; idx &lt; randomArray.count; idx++) {<br>    id obj = randomArray[idx];<br>    if (testObj(obj)) {<br>        [mutableArray addObject:obj];<br>    }<br>}<br>枚举方法 / 时间 [ms]    10.000.000 elements    10.000 elements<br>indexesOfObjects:, concurrent    1844.73    2.25<br>NSFastEnumeration (for in)    3223.45    3.21<br>indexesOfObjects:    4221.23    3.36<br>enumerateObjectsUsingBlock:    5459.43    5.43<br>objectAtIndex:    5282.67    5.53<br>NSEnumerator    5566.92    5.75<br>filteredArrayUsingPredicate:    6466.95    6.31<br>为了更好的理解这里的效率测量，我们首先看一下数组是如何迭代的。</p>
<p>indexesOfObjectsWithOptions:passingTest: 必须每次都执行一次 block 因此比传统的使用 NSFastEnumeration 技术的基于 for 循环的枚举要稍微低效一些。但是如果开启了并发枚举，那么前者的速度则会大大的超过后者几乎 2 倍。iPhone 5s 是双核的，所以这说得通。这里并没有体现出来的是 NSEnumerationConcurrent 只对大量的对象有意义，如果你的集合中的对象数量很少，用哪个方法就真的无关紧要。甚至 NSEnumerationConcurrent 上额外的线程管理实际上会使结果变得更慢。</p>
<p>最大的输家是 filteredArrayUsingPredicate:。NSPredicate 需要在这里提及是因为，人们可以写出非常复杂的表达式，尤其是用不基于 block 的变体。使用 Core Data 的用户应该会很熟悉。</p>
<p>为了比较的完整，我们也加入了 NSEnumerator 作为比较 — 虽然没有任何理由再使用它了。然而它竟出人意料的快(至少还是比基于 NSPredicate 的过滤要快)，它的运行时消耗无疑比快速枚举更多 — 现在它只用于向后兼容。甚至没有优化过的 objectAtIndex: 都要更快些。</p>
<p>NSFastEnumeration<br>在OSX 10.5和iOS的最初版本中，苹果增加了 NSFastEnumeration。在此之前，只有每次返回一个元素的 NSEnumeration ，每次迭代都有运行时开销。而快速枚举，苹果通过 countByEnumeratingWithState:objects:count: 返回一个数据块。该数据块被解析成 id 类型的 C 数组。这就是更快的速度的原因；迭代一个 C 数组要快得多，而且可以被编译器更深一步的优化。手动的实现快速枚举是十分难办的，所以苹果的 FastEnumerationSample 是一个不错的开始，还有一篇 Mike Ash 的文章也很不错。</p>
<p>应该用arrayWithCapacity:吗?<br>初始化NSArray的时候，可以选择指定数组的预期大小。在检测的时候，结果是在效率上没有差别 — 至少在统计误差范围内的测量的时间几乎相等。有消息透漏说实际上苹果根本没有使用这个参数。然而使用 arrayWithCapacity: 仍然好处，它可以作为一种隐性的文档来帮助你理解代码:</p>
<p>Adding 10.000.000 elements to NSArray. no count 1067.35[ms] with count: 1083.13[ms].</p>
<p>子类化注意事项<br>很少有理由去子类化基础集合类。大多数时候，使用 CoreFoundation 级别的类并且自定义回调函数定制自定义行为是更好的解决方案。 创建一个大小写不敏感的字典，一种方法是子类化 NSDictionary 并且自定义访问方法，使其将字符串始终变为小写(或大写)，并对排序也做类似的修改。更快更好的解决方案是提供一组不同的 CFDictionaryKeyCallBacks 集，你可以提供自定义的 hash 和 isEqual: 回调。你可以在这里找到一个例子。这种方法的优美之处应该归功于 toll-free 桥接)，它仍然是一个简单的字典，因此可以被任何使用 NSDictionary 作为参数的API接受。</p>
<p>子类作用的一个例子是有序字典的用例。.NET 提供了一个 SortedDictionary，Java 有 TreeMap，C++ 有 std::map。虽然你可以使用 C++ 的 STL 容器，但却无法使它自动的 retain/release ，这会让使用起来笨拙得多。因为 NSDictionary 是一个类簇，所以子类化跟人们想象的相比非常不同。这已经超过了本文的讨论范畴，这里有一个真实的有序字典的例子。</p>
<p>NSDictionary<br>一个字典存储任意的对象键值对。 由于历史原因，初始化方法 [NSDictionary dictionaryWithObjectsAndKeys:object, key, nil] 使用了相反的值到键的顺序，而新的快捷语法则从 key 开始，@{key : value, …}。</p>
<p>NSDictionary 中的键是被拷贝的并且需要是不变的。如果在一个键在被用于在字典中放入一个值后被改变的话，那么这个值就会变得无法获取了。一个有趣的细节是，在 NSDictionary 中键是被 copy 的，但是在使用一个 toll-free 桥接的 CFDictionary 时却只会被 retain。CoreFoundation 类没有通用的拷贝对象的方法，因此这时拷贝是不可能的(*)。这只适用于你使用 CFDictionarySetValue() 的时候。如果你是通过 setObject:forKey 来使用一个 toll-free 桥接的 CFDictionary 的话，苹果会为其增加额外处理逻辑，使得键被拷贝。但是反过来这个结论则不成立 — 使用已经转换为 CFDictionary 的 NSDictionary 对象，并用对其使用 CFDictionarySetValue() 方法，还是会导致调用回 setObject:forKey 并对键进行拷贝。</p>
<p>(*)其实有一个现成的键的回调函数 kCFCopyStringDictionaryKeyCallBacks 可以拷贝字符串，因为对于 ObjC对象来说， CFStringCreateCopy() 会调用 [NSObject copy]，我们可以巧妙使用这个回调来创建一个能进行键拷贝的 CFDictionary。</p>
<p>性能特征<br>苹果在定义字典的计算复杂度时显得相当低调。唯一的信息可以在 CFDictionary 的头文件中找到:</p>
<p>对于字典中值的访问时间，不管是在现在还是将来，我们保证在任何一种实现下最坏情况是 O(N)。但通常来说它会是 O(1) (常数时间)。插入和删除操作一般来说也会是常数时间，但是在某些实现中最坏情况将为 O(N*N)。通过键来访问值将比直接访问值要快（如果你有这样的操作要做的话）。对于同样数目的值，字典需要花费比数组多得多的内存空间。</p>
<p>跟数组相似的，字典根据尺寸的不同使用不同的实现，并在其中无缝切换。</p>
<p>枚举和总览<br>过滤字典有几个不同的方法:</p>
<p>// 使用 keysOfEntriesWithOptions:passingTest:，可并行<br>NSSet <em>matchingKeys = [randomDict keysOfEntriesWithOptions:NSEnumerationConcurrent<br>                                               passingTest:^BOOL(id key, id obj, BOOL </em>stop)<br>{<br>    return testObj(obj);<br>}];<br>NSArray <em>keys = matchingKeys.allObjects;<br>NSArray </em>values = [randomDict objectsForKeys:keys notFoundMarker:NSNull.null];<br>__unused NSDictionary *filteredDictionary = [NSDictionary dictionaryWithObjects:values<br>                                                                        forKeys:keys];</p>
<p>// 基于 block 的枚举<br>NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];<br>[randomDict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL </em>stop) {<br>    if (testObj(obj)) {<br>        mutableDictionary[key] = obj;<br>    }<br>}];</p>
<p>// NSFastEnumeration<br>NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];<br>for (id key in randomDict) {<br>    id obj = randomDict[key];<br>    if (testObj(obj)) {<br>        mutableDictionary[key] = obj;<br>    }<br>}</p>
<p> // NSEnumeration<br> NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];<br> NSEnumerator </em>enumerator = [randomDict keyEnumerator];<br> id key = nil;<br> while ((key = [enumerator nextObject]) != nil) {<br>       id obj = randomDict[key];<br>       if (testObj(obj)) {<br>           mutableDictionary[key] = obj;<br>       }<br> }</p>
<p>// 基于 C 数组，通过 getObjects:andKeys: 枚举<br>NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];<br>id <strong>unsafe_unretained objects[numberOfEntries];<br>id </strong>unsafe_unretained keys[numberOfEntries];<br>[randomDict getObjects:objects andKeys:keys];<br>for (int i = 0; i &lt; numberOfEntries; i++) {<br>    id obj = objects[i];<br>    id key = keys[i];<br>    if (testObj(obj)) {<br>       mutableDictionary[key] = obj;<br>    }<br> }<br>过滤/枚举方法    Time [ms], 50.000 elements    1.000.000 elements<br>keysOfEntriesWithOptions:, concurrent    16.65    425.24<br>getObjects:andKeys:    30.33    798.49</em><br>keysOfEntriesWithOptions:    30.59    856.93<br>enumerateKeysAndObjectsUsingBlock:    36.33    882.93<br>NSFastEnumeration    41.20    1043.42<br>NSEnumeration    42.21    1113.08<br>(*)使用 getObjects:andKeys: 时需要注意。在上面的代码例子中，我们使用了可变长度数组这一 C99 特性(通常，数组的数量需要是一个固定值)。这将在栈上分配内存，虽然更方便一点，但却有其限制。上面的代码在元素数量很多的时候会崩溃掉，所以我们使用基于 malloc/calloc 的分配 (和 free) 以确保安全。</p>
<p>为什么这次 NSFastEnumeration 这么慢？迭代字典通常需要键和值两者，快速枚举只能枚举键，我们必须每次都自己获取值。使用基于 block 的 enumerateKeysAndObjectsUsingBlock: 更高效，因为两者都可以更高效的被提前获取。</p>
<p>这次测试的胜利者又是通过 keysOfEntriesWithOptions:passingTest: 和 objectsForKeys:notFoundMarker: 的并发迭代。代码稍微多了一点，但是可以用 category 进行漂亮的封装。</p>
<p>应该用 dictionaryWithCapacity: 吗?<br>到现在你应该已经知道该如何测试了，简单的回答是不，count 参数没有改变任何事情:</p>
<p>Adding 10000000 elements to NSDictionary. no count 10786.60[ms] with count: 10798.40[ms].</p>
<p>排序<br>关于字典排序没有太多可说的。你只能将键数组排序为一个新对象，因此你可以使用任何正规的 NSArray 的排序方法:</p>
<ul>
<li>(NSArray *)keysSortedByValueUsingSelector:(SEL)comparator;</li>
<li>(NSArray *)keysSortedByValueUsingComparator:(NSComparator)cmptr;</li>
<li>(NSArray *)keysSortedByValueWithOptions:(NSSortOptions)opts<pre><code>usingComparator:(NSComparator)cmptr;
</code></pre>共享键<br>从 iOS 6 和 OS X 10.8 开始，新建的字典可以使用一个预先生成好的键集，使用 sharedKeySetForKeys: 从一个数组中创建键集，然后用 dictionaryWithSharedKeySet: 创建字典。共享键集会复用对象，以节省内存。根据 Foundation Release Notes，sharedKeySetForKeys: 中会计算一个最小完美哈希，这个哈希值可以取代字典查找过程中探索循环的需要，因此使键的访问更快。</li>
</ul>
<p>虽然在我们有限的测试中没有法线苹果在 NSJSONSerialization 中使用这个特性，但毫无疑问，在处理 JSON 的解析工作时这个特性可以发挥得淋漓尽致。(使用共享键集创建的字典是 NSSharedKeyDictionary 的子类；通常的字典是 <strong>NSDictionaryI / </strong>NSDictionaryM，I / M 表明可变性；可变和不可变的的字典在 toll-free 桥接后对应的都是 _NSCFDictionary 类。)</p>
<p>有趣的细节：共享键字典始终是可变的，即使对它们执行了”copy”命令后也是。这个行为文档中并没有说明，但很容易被测试:</p>
<p>id sharedKeySet = [NSDictionary sharedKeySetForKeys:@[@1, @2, @3]]; // 返回 NSSharedKeySet<br>NSMutableDictionary <em>test = [NSMutableDictionary dictionaryWithSharedKeySet:sharedKeySet];<br>test[@4] = @”First element (not in the shared key set, but will work as well)”;<br>NSDictionary </em>immutable = [test copy];<br>NSParameterAssert(immutable.count == 1);<br>((NSMutableDictionary *)immutable)[@5] = @”Adding objects to an immutable collection should throw an exception.”;<br>NSParameterAssert(immutable.count == 2);<br>NSSet<br>NSSet 和它的可变变体 NSMutableSet 是无序对象集合。检查一个对象是否存在通常是一个 O(1) 的操作，使得比 NSArray 快很多。NSSet 只在被使用的哈希方法平衡的情况下能高效的工作；如果所有的对象都在同一个哈希筐内，NSSet 在查找对象是否存在时并不比 NSArray 快多少。</p>
<p>NSSet 还有变体 NSCountedSet，以及非 toll-free 计数变体 CFBag / CFMutableBag。</p>
<p>NSSet 会 retain 它其中的对象，但是根据 set 的规定，对象应该是不可变的。添加一个对象到 set 中随后改变它会导致一些奇怪的问题并破坏 set 的状态。</p>
<p>NSSet 的方法比 NSArray 少的多。没有排序方法，但有一些方便的枚举方法。重要的方法有 allObjects，将对象转化为 NSArray，anyObject 则返回任意的对象，如果 set 为空，则返回 nil。</p>
<p>Set 操作<br>NSMutableSet 有几个很强大的方法，例如 intersectSet:，minusSet: 和 unionSet:。</p>
<p>img</p>
<p>应该用setWithCapacity:吗?<br>我们再一次测试当创建 set 时给定容量大小是否会有显著的速度差异:</p>
<p>Adding 1.000.000 elements to NSSet. no count 2928.49[ms] with count: 2947.52[ms].</p>
<p>在统计误差范围内，结果没有显著差异。有一份证据表明至少在上一个 runtime 版本中，有很多的性能上的影响。</p>
<p>NSSet 性能特征<br>苹果在 CFSet 头文件中没有提供任何关于算法复杂度的注释。</p>
<p>类 / 时间 [ms]    1.000.000 elements<br>NSMutableSet, adding    2504.38<br>NSMutableArray, adding    1413.38<br>NSMutableSet, random access    4.40<br>NSMutableArray, random access    7.95<br>这个检测非常符合我们的预期：NSSet 在每一个被添加的对象上执行 hash 和 isEqual: 方法并管理一系列哈希值，所以在添加元素时耗费了更多的时间。set的随机访问比较难以测试，因为这里执行的都是 anyObject。</p>
<p>这里没有必要包含 containsObject: 的测试，set 要快几个数量级，毕竟这是它的特点。</p>
<p>NSOrderedSet<br>NSOrderedSet 在 iOS 5 和 Mac OS X 10.7 中第一次被引入，除了 Core Data，几乎没有直接使用它的 API。看上去它综合了 NSArray 和 NSSet 两者的好处，对象查找，对象唯一性，和快速随机访问。</p>
<p>NSOrderedSet 有着优秀的 API 方法，使得它可以很便利的与其他 set 或者有序 set 对象合作。合并，交集，差集，就像 NSSet 支持的那样。它有 NSArray 中除了比较陈旧的基于函数的排序方法和二分查找以外的大多数排序方法。毕竟 containsObject: 非常快，所以没有必要再用二分查找了。</p>
<p>NSOrderedSet 的 array 和 set 方法分别返回一个 NSArray 和 NSSet，这些对象表面上是不可变的对象，但实际上在 NSOrderedSet 更新的时候，它们也会更新自己。如果你在不同线程上使用这些对象并发生了诡异异常的时候，知道这一点是非常有好处的。本质上，这些类使用的是 <strong>NSOrderedSetSetProxy 和 </strong>NSOrderedSetArrayProxy。</p>
<p>附注：如果你想知道为什么 NSOrderedSet 不是 NSSet 的子类，NSHipster 上有一篇非常好的文章解释了可变/不可变类簇的缺点。</p>
<p>NSOrderedSet 性能特征<br>如果你看到这份测试，你就会知道 NSOrderedSet 代价高昂了，毕竟天下没有免费的午餐:</p>
<p>类 / 时间 [ms]    1.000.000 elements<br>NSMutableOrderedSet, adding    3190.52<br>NSMutableSet, adding    2511.96<br>NSMutableArray, adding    1423.26<br>NSMutableOrderedSet, random access    10.74<br>NSMutableSet, random access    4.47<br>NSMutableArray, random access    8.08<br>这个测试在每一个集合类中添加自定义字符串，随后随机访问它们。</p>
<p>NSOrderedSet 比 NSSet 和 NSArray 占用更多的内存，因为它需要同时维护哈希值和索引。</p>
<p>NSHashTable<br>NSHashTable 效仿了 NSSet，但在对象/内存处理时更加的灵活。可以通过自定义 CFSet 的回调获得 NSHashTable 的一些特性，哈希表可以保持对对象的弱引用并在对象被销毁之后正确的将其移除，有时候如果手动在 NSSet 中添加的话，想做到这个是挺恶心的一件事。它是默认可变的 — 并且这个类没有相应的不可变版本。</p>
<p>NSHashTable 有 ObjC 和原始的 C API，C API 可以用来存储任意对象。苹果在 10.5 Leopard 系统中引入了这个类，但是 iOS 的话直到最近的 iOS 6 中才被加入。足够有趣的是它们只移植了 ObjC API；更多强大的 C API 没有包括在 iOS 中。</p>
<p>NSHashTable 可以通过 initWithPointerFunctions:capacity: 进行大量的设置 — 我们只选取使用预先定义的 hashTableWithOptions: 这一最普遍的使用场景。其中最有用的选项有利用 weakObjectsHashTable 来使用其自身的构造函数。</p>
<p>NSPointerFunctions<br>这些指针函数可以被用在 NSHashTable，NSMapTable和 NSPointerArray 中，定义了对存储在这个集合中的对象的获取和保留行为。这里只介绍最有用的选项。完整列表参见 NSPointerFunctions.h。</p>
<p>有两组选项。内存选项决定了内存管理，个性化定义了哈希和相等。</p>
<p>NSPointerFunctionsStrongMemory 创建了一个r etain/release 对象的集合，非常像常规的 NSSet 或 NSArray。</p>
<p>NSPointerFunctionsWeakMemory 使用和 __weak 等价的方式来存储对象并自动移除被销毁的对象。</p>
<p>NSPointerFunctionsCopyIn 在对象被加入到集合前拷贝它们。</p>
<p>NSPointerFunctionsObjectPersonality 使用对象的 hash 和 isEqual: (默认)。</p>
<p>NSPointerFunctionsObjectPointerPersonality 对于 isEqual: 和 hash 使用直接的指针比较。</p>
<p>NSHashTable 性能特征<br>类 / 时间 [ms]    1.000.000 elements<br>NSHashTable, adding    2511.96<br>NSMutableSet, adding    1423.26<br>NSHashTable, random access    3.13<br>NSMutableSet, random access    4.39<br>NSHashTable, containsObject    6.56<br>NSMutableSet, containsObject    6.77<br>NSHashTable, NSFastEnumeration    39.03<br>NSMutableSet, NSFastEnumeration    30.43<br>如果你只是需要 NSSet 的特性，请坚持使用 NSSet。NSHashTable 在添加对象时花费了将近2倍的时间，但是其他方面的效率却非常相近。</p>
<p>NSMapTable<br>NSMapTable 和 NSHashTable 相似，但是效仿的是 NSDictionary。因此，我们可以通过 mapTableWithKeyOptions:valueOptions: 分别控制键和值的对象获取/保留行为。存储弱引用是 NSMapTable 最有用的特性，这里有4个方便的构造函数:</p>
<p>strongToStrongObjectsMapTable<br>weakToStrongObjectsMapTable<br>strongToWeakObjectsMapTable<br>weakToWeakObjectsMapTable<br>注意，除了使用 NSPointerFunctionsCopyIn，任何的默认行为都会 retain (或弱引用)键对象而不会拷贝它，这与 CFDictionary 的行为相同而与 NSDictionary 不同。当你需要一个字典，它的键没有实现 NSCopying 协议的时候（比如像 UIView），这会非常有用。</p>
<p>如果你好奇为什么苹果”忘记”为 NSMapTable 增加下标，你现在知道了。下标访问需要一个 id<nscopying> 作为 key，对 NSMapTable 来说这不是强制的。如果不通过一个非法的 API 协议或者移除 NSCopying 协议来削弱全局下标，是没有办法给它增加下标的。</nscopying></p>
<p>你可以通过 dictionaryRepresentation 把内容转换为普通的 NSDictionary。不像 NSOrderedSet，这个方法返回的是一个常规的字典而不是一个代理。</p>
<p>NSMapTable 性能特征<br>类 / 时间 [ms]    1.000.000 elements<br>NSMapTable, adding    2958.48<br>NSMutableDictionary, adding    2522.47<br>NSMapTable, random access    13.25<br>NSMutableDictionary, random access    9.18<br>NSMapTable 只比 NSDictionary 略微慢一点。如果你需要一个不 retain 键的字典，放弃 CFDictionary 而使用它吧。</p>
<p>NSPointerArray<br>NSPointerArray类是一个稀疏数组，工作起来与 NSMutableArray 相似，但可以存储 NULL 值，并且 count 方法会反应这些空点。可以用 NSPointerFunctions 对其进行各种设置，也有应对常见的使用场景的快捷构造函数 strongObjectsPointerArray 和 weakObjectsPointerArray。</p>
<p>在能使用 insertPointer:atIndex: 之前，我们需要通过直接设置 count 属性来申请空间，否则会产生一个异常。另一种选择是使用 addPointer:，这个方法可以自动根据需要增加数组的大小。</p>
<p>你可以通过 allObjects 将一个 NSPointerArray 转换成常规的 NSArray。这时所有的 NULL 值会被去掉，只有真正存在的对象被加入到数组 — 因此数组的对象索引很有可能会跟指针数组的不同。注意：如果向指针数组中存入任何非对象的东西，试图执行 allObjects 都会造成 EXC_BAD_ACCESS 崩溃，因为它会一个一个地去 retain ”对象”。</p>
<p>从调试的角度讲，NSPointerArray没有受到太多欢迎。description方法只是简单的返回了<nsconcretepointerarray: 0x17015ac50="">。为了得到所有的对象需要执行[pointerArray allObjects]，当然，如果存在NULL的话会改变索引。</nsconcretepointerarray:></p>
<p>NSPointerArray 性能特征<br>在性能方面， NSPointerArray 真的非常非常慢，所以当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用 NSNull 作为空标记的 NSMutableArray ，而对 NSPointerArray 我们用 NSPointerFunctionsStrongMemory 来进行设置 (这样对象会被适当的 retain)。在一个有 10,000 个元素的数组中，我们每隔十个插入一个字符串 ”Entry %d”。此测试包括了用 NSNull.null 填充 NSMutableArray 的总时间。对于 NSPointerArray，我们使用 setCount: 来代替:</p>
<p>类 / 时间 [ms]    10.000 elements<br>NSMutableArray, adding    15.28<br>NSPointerArray, adding    3851.51<br>NSMutableArray, random access    0.23<br>NSPointerArray, random access    0.34<br>注意 NSPointerArray 需要的时间比 NSMutableArray 多了超过<em> 250 倍(!)</em> 。这非常奇怪和意外。跟踪内存是比较困难的，所以按理说 NSPointerArray 会更高效才对。不过由于我们使用的是同一个 NSNull 来标记空对象，所以除了指针也没有什么更多的消耗。</p>
<p>NSCache<br>NSCache 是一个非常奇怪的集合。在 iOS 4 / Snow Leopard 中加入，默认为可变并且线程安全的。这使它很适合缓存那些创建起来代价高昂的对象。它自动对内存警告做出反应并基于可设置的”成本”清理自己。与 NSDictionary 相比，键是被 retain 而不是被 copy 的。</p>
<p>NSCache 的回收方法是不确定的，在文档中也没有说明。向里面放一些类似图片那样超大的对象并不是一个好主意，有可能它在能回收之前就更快地把你的 cache 给填满了。(这是在 PSPDFKit 中很多跟内存有关的 crash 的原因，在使用自定义的基于 LRU 的链表缓存的代码之前，我们起初使用了 NSCache 存储事先渲染的图片。)</p>
<p>可以对 NSCache 进行设置，这样它就能自动回收那些实现了 NSDiscardableContent 协议的对象。实现了该属性的一个比较常用的类是同时间加入的 NSPurgeableData，但是在 OS X 10.9 之前，它是非完全线程安全的 (也没有信息表明这个变化也影响到了 iOS，或者说在 iOS 7 中被修复了)。</p>
<p>NSCache 性能<br>那么相比起 NSMutableDictionary 来说，NSCache 表现如何呢？加入的线程安全必然会带来一些消耗。处于好奇，我也加入了一个自定义的线程安全的字典的子类 (PSPDFThreadSafeMutableDictionary)，它通过 OSSpinLock 实现同步的访问。</p>
<p>类 / 时间 [ms]    1.000.000 elements    iOS 7x64 Simulator    iPad Mini iOS 6<br>NSMutableDictionary, adding    195.35    51.90    921.02<br>PSPDFThreadSafeMutableDictionary, adding    248.95    57.03    1043.79<br>NSCache, adding    557.68    395.92    1754.59<br>NSMutableDictionary, random access    6.82    2.31    23.70<br>PSPDFThreadSafeMutableDictionary, random access    9.09    2.80    32.33<br>NSCache, random access    9.01    29.06    53.25<br>NSCache 表现的相当好，随机访问跟我们自定义的线程安全字典一样快。如我们预料的，添加更慢一些，因为 NSCache 要多维护一个决定何时回收对象的成本系数。就这一点来看这不是一个非常公平的比较。有趣的是，在模拟器上运行效率要慢了几乎 10 倍。无论对 32 或 64 位的系统都是这样。而且看起来这个类已经在 iOS 7 中优化过，或者是受益于 64 位 runtime 环境。当在老的设备上测试时，使用 NSCache 的性能消耗就明显得多。</p>
<p>iOS 6(32 bit) 和 iOS 7(64 bit) 的区别也很明显，因为 64 位运行时使用标签指针 (tagged pointer)，因此我们的 @(idx) boxing 要更为高效。</p>
<p>NSIndexSet<br>有些使用场景下 NSIndexSet (和它的可变变体，NSMutableIndexSet) 真的非常出色，对它的使用贯穿在 Foundation 中。它可以用一种非常高效的方法存储一组无符号整数的集合，尤其是如果只是一个或少量范围的时候。正如 set 这个名字已经暗示的那样，每一个 NSUInteger 要么在索引 set 中，要么不在。如果你需要存储任意非唯一的数的时候，最好使用 NSArray。</p>
<p>下面是如何把一个整数数组转换为 NSIndexSet:</p>
<p>NSIndexSet <em>PSPDFIndexSetFromArray(NSArray </em>array) {<br>    NSMutableIndexSet <em>indexSet = [NSMutableIndexSet indexSet];<br>    for (NSNumber </em>number in array) {<br>        [indexSet addIndex:[number unsignedIntegerValue]];<br>    }<br>    return [indexSet copy];<br>}<br>如果不使用block，从索引set中拿到所有的索引有点麻烦，getIndexes:maxCount:inIndexRange: 是最快的方法，其次是使用 firstIndex 并迭代直到 indexGreaterThanIndex: 返回 NSNotFound。随着 block 的到来，使用 NSIndexSet 工作变得方便的多:</p>
<p>NSArray <em>PSPDFArrayFromIndexSet(NSIndexSet </em>indexSet) {<br>    NSMutableArray <em>indexesArray = [NSMutableArray arrayWithCapacity:indexSet.count];<br>    [indexSet enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL </em>stop) {<br>       [indexesArray addObject:@(idx)];<br>    }];<br>    return [indexesArray copy];<br>}<br>NSIndexSet性能<br>Core Foundation 中没有和 NSIndexSet 相当的类，苹果也没有对性能做出任何承诺。NSIndexSet 和 NSSet 之间的比较也相对的不公平，因为常规的 set 需要对数字进行包装。为了缓解这个影响，这里的测试准备了实现包装好的 NSUintegers ，并且在两个循环中都会执行 unsignedIntegerValue:</p>
<p>类 / 时间 [ms]    1.000.000 elements    iOS 7x64 Simulator    iPad Mini iOS 6<br>NSMutableDictionary, adding    195.35    51.90    921.02<br>PSPDFThreadSafeMutableDictionary, adding    248.95    57.03    1043.79<br>NSCache, adding    557.68    395.92    1754.59<br>NSMutableDictionary, random access    6.82    2.31    23.70<br>PSPDFThreadSafeMutableDictionary, random access    9.09    2.80    32.33<br>NSCache, random access    9.01    29.06    53.25<br>我们看到在一百万左右对象的时候，NSIndexSet 开始变得比 NSSet 慢，但只是因为新的运行时和标签指针。在 iOS 6 上运行相同的测试表明，甚至在更高数量级实体的条件下，NSIndexSet 更快。实际上，在大多数应用中，你不会添加太多的整数到索引 set 中。还有一点这里没有测试，就是 NSIndexSet 跟 NSSet 比无疑有更好的内存优化。</p>
<p>结论<br>本文提供了一些真实的测试，使你在使用基础集合类的时候做出有根据的选择。除了上面讨论的类，还有一些不常用但确实有用的类，尤其是 NSCountedSet，CFBag，CFTree，CFBitVector和CFBinaryHeap。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/28/kvc-slash-kvoyuan-li-xiang-jie-ji-bian-cheng-zhi-nan/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/28/kvc-slash-kvoyuan-li-xiang-jie-ji-bian-cheng-zhi-nan/" itemprop="url">
                  [iOS]KVC/KVO原理详解及编程指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-28T17:48:12+08:00">
              2014-10-28
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/28/kvc-slash-kvoyuan-li-xiang-jie-ji-bian-cheng-zhi-nan/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/28/kvc-slash-kvoyuan-li-xiang-jie-ji-bian-cheng-zhi-nan/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##前言：</p>
<ol>
<li>本文基本不讲KVC/KVO的用法，只结合网上的资料说说对这种技术的理解。</li>
<li>由于KVO内容较少，而且是以KVC为基础实现的，本文将着重介绍KVC部分。</li>
</ol>
<p>##一、简介</p>
<p>KVC/KVO是观察者模式的一种实现，在Cocoa中是以被万物之源NSObject类实现的<code>NSKeyValueCoding/NSKeyValueObserving</code>非正式协议的形式被定义为基础框架的一部分。从协议的角度来说，KVC/KVO本质上是定义了一套让我们去遵守和实现的方法。</p>
<p>当然，KVC/KVO实现的根本是Objective-C的动态性和runtime，这在后文的原理部分会有详述。<br>另外，KVC/KVO机制离不开访问器方法的实现，这在后文中也有解释。</p>
<ol>
<li><p>KVC简介<br>全称是Key-value coding，翻译成键值编码。顾名思义，在某种程度上跟map的关系匪浅。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。</p>
</li>
<li><p>KVO简介<br>全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。</p>
</li>
</ol>
<p>##二、KVC相关技术</p>
<p>1.Key和Key Path</p>
<p>KVC定义了一种按名称访问对象属性的机制，支持这种访问的主要方法是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;  </div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;  </div><div class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;  </div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure>
<p>前边两个方法用到的Key较容易理解，就是要访问的属性名称对应的字符串。<br>后面两个方法用到的KeyPath是一个被点操作符隔开的用于访问对象的指定属性的字符串序列。比如KeyPath address.street将会访问消息接收对象所包含的address属性中包含的一个street属性。其实KeyPath说白了就是我们平时使用点操作访问某个对象的属性时所写的那个字符串。</p>
<p>2.点语法和KVC</p>
<p>在实现了访问器方法的类中，使用点语法和KVC访问对象其实差别不大，二者可以任意混用。但是没有访问起方法的类中，点语法无法使用，这时KVC就有优势了。（原因见第三部分的第一节：KVC如何访问属性值。）</p>
<p>3.一对多关系（To-Many）中的集合访问器方法</p>
<p>我们平时大部分使用的属性都是一对一关系（To-One）,比如Person类中的name属性，每个人只有一个名字。但也有一对多的关系，比如Person中有一个friendsName属性，这是个集合（在Objective-C中可以是NSArray，NSSet等），保存的是一个人的所有朋友的名字。</p>
<p>当操作一对多的属性中的内容时，我们有两种选择：</p>
<p>①间接操作<br>先通过KVC方法取到集合属性，然后通过集合属性操作集合中的元素。</p>
<p>②直接操作<br>苹果为我们提供了一些方法模板，我们可以以规定的格式实现这些方法来达到访问集合属性中元素的目的。</p>
<p>有序集合对应方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-countOf&lt;Key&gt;  <span class="comment">//必须实现，对应于NSArray的基本方法count:  </span></div><div class="line">-objectIn&lt;Key&gt;AtIndex:  </div><div class="line">-&lt;key&gt;AtIndexes:  <span class="comment">//这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes:  </span></div><div class="line">-get&lt;Key&gt;:range:  <span class="comment">//不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 getObjects:range:  </span></div><div class="line">-insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:  </div><div class="line">-insert&lt;Key&gt;:atIndexes:  <span class="comment">//两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes:  </span></div><div class="line">-removeObjectFrom&lt;Key&gt;AtIndex:  </div><div class="line">-remove&lt;Key&gt;AtIndexes:  <span class="comment">//两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:  </span></div><div class="line">-replaceObjectIn&lt;Key&gt;AtIndex:withObject:  </div><div class="line">-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:  <span class="comment">//可选的，如果在此类操作上有性能问题，就需要考虑实现之</span></div></pre></td></tr></table></figure>
<p>无序集合对应方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[java] view plaincopy</div><div class="line">-countOf&lt;Key&gt;  <span class="comment">//必须实现，对应于NSArray的基本方法count:  </span></div><div class="line">-objectIn&lt;Key&gt;AtIndex:  </div><div class="line">-&lt;key&gt;AtIndexes:  <span class="comment">//这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes:  </span></div><div class="line">-get&lt;Key&gt;:range:  <span class="comment">//不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 getObjects:range:  </span></div><div class="line">-insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:  </div><div class="line">-insert&lt;Key&gt;:atIndexes:  <span class="comment">//两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes:  </span></div><div class="line">-removeObjectFrom&lt;Key&gt;AtIndex:  </div><div class="line">-remove&lt;Key&gt;AtIndexes:  <span class="comment">//两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:  </span></div><div class="line">-replaceObjectIn&lt;Key&gt;AtIndex:withObject:  </div><div class="line">-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:  <span class="comment">//这两个都是可选的，如果在此类操作上有性能问题，就需要考虑实现之</span></div></pre></td></tr></table></figure>
<p>不过这些方法除非是很有需求，否则个人认为没有实现的必要，间接法也不是很麻烦，基本能满足需求了。值得指出的是，苹果甚至都没有让这些方法以哪怕是非正式协议的形式出现，而只是在编程指南中提了一下。</p>
<p>4.键值验证（Key-Value Validation）</p>
<p>KVC提供了验证Key对应的Value是否可用的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> *)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</div></pre></td></tr></table></figure>
<p>该方法默认的实现是调用一个如下格式的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validate&lt;Key&gt;:error:</div></pre></td></tr></table></figure>
<p>比如属性name对应的方法为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)validateName:(<span class="keyword">id</span> *)ioValue error:(<span class="built_in">NSError</span> * __autoreleasing *)outError &#123;  </div><div class="line">    <span class="comment">// Implementation specific code.  </span></div><div class="line">    <span class="keyword">return</span> ...;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就给了我们一次纠错的机会。需要指出的是，KVC是不会自动调用键值验证方法的，就是说我们需要手动验证。但是有些技术，比如CoreData会自动调用。</p>
<p>5.KVC对数值和结构体型属性的支持</p>
<p>一套机制如果不支持数值和结构体型的数据，那么它的实用性就会大大折扣。幸运的是KVC中苹果对这方面的支持做的很好。KVC可以自动的将数值或结构体型的数据打包或解包成<code>NSNumber</code>或<code>NSValue</code>对象，以达到适配的目的。</p>
<p>举个例子，Person类有个个<code>NSInteger</code>类型的age属性</p>
<p>①修改值</p>
<p>我们通过KVC技术使用如下方式设置age属性的值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person setValue:[<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">5</span>] forKey:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure>
<p>我们赋给age的是一个<code>NSNumber</code>对象，KVC会自动的将<code>NSNumber</code>对象转换成<code>NSInteger</code>对象，然后再调用相应的访问器方法设置age的值。</p>
<p>②获取值</p>
<p>同样，以如下方式获取age属性值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person valueForKey:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure>
<p>这时，会以NSNumber的形式返回age的值。需要说明的是，什么时候返回的是NSNumber，什么时候返回的是NSValue？</p>
<p>③使用<code>NSNumber</code>封装</p>
<p>可以使用NSNumber的数据类型有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithChar:(<span class="keyword">char</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedChar:(<span class="keyword">unsigned</span> <span class="keyword">char</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithShort:(<span class="keyword">short</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedShort:(<span class="keyword">unsigned</span> <span class="keyword">short</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithInt:(<span class="keyword">int</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedInt:(<span class="keyword">unsigned</span> <span class="keyword">int</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithLong:(<span class="keyword">long</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedLong:(<span class="keyword">unsigned</span> <span class="keyword">long</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithLongLong:(<span class="keyword">long</span> <span class="keyword">long</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedLongLong:(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithFloat:(<span class="keyword">float</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithDouble:(<span class="keyword">double</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithBool:(<span class="built_in">BOOL</span>)value;  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithInteger:(<span class="built_in">NSInteger</span>)value <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);  </div><div class="line">+ (<span class="built_in">NSNumber</span> *)numberWithUnsignedInteger:(<span class="built_in">NSUInteger</span>)value <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</div></pre></td></tr></table></figure>
<p>总之就是一些常见的数值型数据。</p>
<p>④使用<code>NSValue</code>封装</p>
<p><code>NSValue</code>主要用于处理结构体型的数据，它本身提供了如下集中结构的支持：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithCGPoint:(<span class="built_in">CGPoint</span>)point;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithCGSize:(<span class="built_in">CGSize</span>)size;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithCGRect:(<span class="built_in">CGRect</span>)rect;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithCGAffineTransform:(<span class="built_in">CGAffineTransform</span>)transform;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithUIEdgeInsets:(<span class="built_in">UIEdgeInsets</span>)insets;  </div><div class="line">+ (<span class="built_in">NSValue</span> *)valueWithUIOffset:(<span class="built_in">UIOffset</span>)insets <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure>
<p>只有有限的6种而已！那对于其它自定义的结构体怎么办？别担心，任何结构体都是可以转化成NSValue对象的，具体实现方法参见我之前的一篇文章：<br><a href="http://blog.csdn.net/wzzvictory/article/details/8614433" target="_blank" rel="external">http://blog.csdn.net/wzzvictory/article/details/8614433</a></p>
<p>6.集合运算符（Collection Operators）</p>
<p>集合运算符是一个特殊的Key Path，可以作为参数传递给<code>valueForKeyPath:</code>方法，注意只能是这个方法，如果传给了<code>valueForKey:</code>方法保证你程序崩溃。</p>
<p>运算符是一个以@开头的特殊字符串，格式如下图所示：</p>
<p>①简单集合运算符</p>
<p>简单集合运算符共有<code>@avg</code>，<code>@count</code>，<code>@max</code>，<code>@min</code>，<code>@sum</code>5种，都表示啥不用我说了吧，目前还不支持自定义。<br>有一个集合类的对象：transactions，它存储了一个个的Transaction类的实例，该类有三个属性：payee，amount，date。下面以此为例说明如何使用这些运算符：<br>要获取amount的平均值可以这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *transactionAverage = [transactions valueForKeyPath:<span class="string">@"@avg.amount"</span>];</div></pre></td></tr></table></figure>
<p>要获取transactions集合中元素数目可以这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *numberOfTransactions = [transactions valueForKeyPath:<span class="string">@"@count"</span>];</div></pre></td></tr></table></figure>
<p>需要之处的是，@count是这些集合运算符中比较特殊的一个，因为它没有右路经，原因很容易理解。</p>
<p>②对象运算符</p>
<p>比集合运算符稍微复杂，能以数组的方式返回指定的内容，一共有两种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@distinctUnionOfObjects  </div><div class="line">@unionOfObjects</div></pre></td></tr></table></figure>
<p>它们的返回值都是NSArray，区别是前者返回的元素都是唯一的，是去重以后的结果；后者返回的元素是全集。<br>用法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *payees = [transactions valueForKeyPath:<span class="string">@"@distinctUnionOfObjects.payee"</span>];  </div><div class="line"><span class="built_in">NSArray</span> *payees = [transactions valueForKeyPath:<span class="string">@"@unionOfObjects.payee"</span>];</div></pre></td></tr></table></figure>
<p>前者会将收款人的姓名去除重复的以后返回，后者直接返回所有收款人的姓名。</p>
<p>③Array和Set操作符</p>
<p>这种情况更复杂了，说的是集合中包含集合的情况，我们执行了如下的一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create the array that contains additional arrays.  </span></div><div class="line"><span class="keyword">self</span>.arrayOfTransactionsArray = [<span class="built_in">NSMutableArray</span> array];  </div><div class="line"><span class="comment">// Add the array of objects used in the above examples.  </span></div><div class="line">[arrayOfTransactionsArray addObject:transactions];  </div><div class="line"><span class="comment">// Add a second array of objects; this array contains alternate values.  </span></div><div class="line">[arrayOfTransactionsArrays addObject:moreTransactions];</div></pre></td></tr></table></figure>
<p>得到了一个包含集合的集合：<code>arrayOfTransactionsArray</code>, 这时如果我们想操作<code>arrayOfTransactionsArray</code>中包含的集合中的元素时，可以使用如下三个运算符：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@distinctUnionOfArrays  </div><div class="line">@unionOfArrays  </div><div class="line">@distinctUnionOfSets</div></pre></td></tr></table></figure>
<p>前两个针对的集合是Arrays，后一个针对的集合是Sets。因为Sets中的元素本身就是唯一的，所以没有对应的<code>@unionOfSets</code>运算符。</p>
<p>它们的用法举例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *payees = [arrayOfTransactionsArrays valueForKeyPath:<span class="string">@"@unionOfArrays.payee"</span>];</div></pre></td></tr></table></figure>
<p>##三、实现原理</p>
<p>1.KVC如何访问属性值</p>
<p>KVC再某种程度上提供了访问器的替代方案。不过访问器方法是一个很好的东西，以至于只要是有可能，KVC也尽量再访问器方法的帮助下工作。为了设置或者返回对象属性，KVC按顺序使用如下技术：</p>
<p>①检查是否存在<code>-&lt;key&gt;</code>、<code>-is&lt;key&gt;</code>（只针对布尔值有效）或者<code>-get&lt;key&gt;</code>的访问器方法，如果有可能，就是用这些方法返回值；</p>
<p>检查是否存在名为-set<key>:的方法，并使用它做设置值。对于<code>-get&lt;key&gt;</code>和<code>-set&lt;key&gt;:</code>方法，将大写Key字符串的第一个字母，并与Cocoa的方法命名保持一致；</key></p>
<p>②如果上述方法不可用，则检查名为<code>-_&lt;key&gt;</code>、<code>-_is&lt;key&gt;</code>（只针对布尔值有效）、<code>-_get&lt;key&gt;</code>和-<code>_set&lt;key&gt;:</code>方法；</p>
<p>③如果没有找到访问器方法，可以尝试直接访问实例变量。实例变量可以是名为：<code>&lt;key&gt;</code>或<code>_&lt;key&gt;</code>;</p>
<p>④如果仍为找到，则调用<code>valueForUndefinedKey:</code>和<code>setValue:forUndefinedKey:</code>方法。这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</p>
<p>2.KVC/KVO实现原理</p>
<p>键值编码和键值观察是根据<code>isa-swizzling</code>技术来实现的，主要依据runtime的强大动态能力。下面的这段话是引自网上的一篇文章：<br><a href="http://blog.csdn.net/kesalin/article/details/8194240" target="_blank" rel="external">http://blog.csdn.net/kesalin/article/details/8194240</a></p>
<p>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。</p>
<p>派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。</p>
<p>同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。</p>
<p>原文写的很好，还举了解释性的例子，大家可以去看看。</p>
<p>在我之前的一篇介绍Objective-C类和元类的文章：<br><a href="http://blog.csdn.net/wzzvictory/article/details/8592492" target="_blank" rel="external">http://blog.csdn.net/wzzvictory/article/details/8592492</a><br>中介绍过，isa指针指向的其实是类的元类，如果之前的类名为：Person，那么被runtime更改以后的类名会变成：<code>NSKVONotifying_Person</code>。</p>
<p>新的<code>NSKVONotifying_Person</code>类会重写以下方法：</p>
<p>增加了监听的属性对应的set方法，<code>class</code>，<code>dealloc</code>，<code>_isKVOA</code>。</p>
<p>①class<br>重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。打印如下内容：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"self-&gt;isa:%@"</span>,<span class="keyword">self</span>-&gt;isa);  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"self class:%@"</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]);</div></pre></td></tr></table></figure>
<p>在建立KVO监听前，打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>-&gt;isa:Person  </div><div class="line"><span class="keyword">self</span> <span class="keyword">class</span>:Person</div></pre></td></tr></table></figure>
<p>在建立KVO监听之后，打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>-&gt;isa:<span class="built_in">NSKVONotifying_Person</span>  </div><div class="line"><span class="keyword">self</span> <span class="keyword">class</span>:Person</div></pre></td></tr></table></figure>
<p>这也是isa指针和class方法的一个区别，大家使用的时候注意。</p>
<p>②重写set方法</p>
<p>新类会重写对应的set方法，是为了在set方法中增加另外两个方法的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key  </div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>其中，<code>didChangeValueForKey:</code>方法负责调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath  </div><div class="line">                      ofObject:(<span class="keyword">id</span>)object  </div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change  </div><div class="line">                       context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>方法，这就是KVO实现的原理了！</p>
<p>如果没有任何的访问器方法，<code>-setValue:forKey</code>方法会直接调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key  </div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>如果在没有使用键值编码且没有使用适当命名的访问起方法的时候，我们只需要显示调用上述两个方法，同样可以使用KVO！</p>
<p>总结一下，想使用KVO有三种方法：</p>
<p>1)使用了KVC</p>
<p>使用了KVC，如果有访问器方法，则运行时会在访问器方法中调用<code>will/didChangeValueForKey:</code>方法；<br>没用访问器方法，运行时会在<code>setValue:forKey</code>方法中调用<code>will/didChangeValueForKey:</code>方法。</p>
<p>2)有访问器方法</p>
<p>运行时会重写访问器方法调用<code>will/didChangeValueForKey:</code>方法。因此，直接调用访问器方法改变属性值时，KVO也能监听到。</p>
<p>3)显示调用<code>will/didChangeValueForKey:</code>方法。</p>
<p>总之，想使用KVO，只要有<code>will/didChangeValueForKey:</code>方法就可以了。</p>
<p>③_isKVOA</p>
<p>这个私有方法估计是用来标示该类是一个 KVO 机制声称的类。</p>
<p>##四、优点和缺点</p>
<p>1.优点</p>
<p>①可以再很大程度上简化代码</p>
<p>例子网上很多，这就不举了</p>
<p>②能跟脚本语言很好的配合</p>
<p>才疏学浅，没学过AppleScript等脚本语言，所以没能深刻体会到该优点。</p>
<p>2.缺点</p>
<p>KVC的缺点不明显，主要是KVO的，详情可以参考这篇文章：<br><a href="http://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="external">http://www.mikeash.com/pyblog/key-value-observing-done-right.html</a></p>
<p>核心思想是说KVO的回调机制，不能传一个selector或者block作为回调，而必须重写-<code>addObserver:forKeyPath:options:context:</code>方法所引发的一系列问题。问了解决这个问题，作者还亲自实现了一个<code>MAKVONotificationCenter</code>类，代码见<a href="github:
https://github.com/mikeash/MAKVONotificationCenter" target="_blank" rel="external">github:
https://github.com/mikeash/MAKVONotificationCenter</a>不过个人认为这只是苹果做的KVO不够完美，不能算是缺陷。</p>
<p>参考文档：</p>
<p><a href="http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1
http://blog.csdn.net/kesalin/article/details/8194240" target="_blank" rel="external">http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1
http://blog.csdn.net/kesalin/article/details/8194240</a></p>
<p>作者：wangzz</p>
<p>原文地址：<a href="http://blog.csdn.net/wzzvictory/article/details/9674431" target="_blank" rel="external">http://blog.csdn.net/wzzvictory/article/details/9674431</a></p>
<p>转载请注明出处</p>
<p>如果觉得文章对你有所帮助，请通过留言或关注微信公众帐号wangzzstrive来支持我，谢谢！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/23/ios-ioskai-fa-zhi-bridge,-bridge-transferhe-bridge-retained/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/23/ios-ioskai-fa-zhi-bridge,-bridge-transferhe-bridge-retained/" itemprop="url">
                  [iOS]IOS开发之__bridge，__bridge_transfer和__bridge_retained
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-23T14:18:25+08:00">
              2014-10-23
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/23/ios-ioskai-fa-zhi-bridge,-bridge-transferhe-bridge-retained/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/23/ios-ioskai-fa-zhi-bridge,-bridge-transferhe-bridge-retained/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Core Foundation 框架<br>Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。下面列举该框架支持进行管理的数据以及可提供的服务：</p>
<ol>
<li>群体数据类型 (数组、集合等)</li>
<li>程序包</li>
<li>字符串管理</li>
<li>日期和时间管理</li>
<li>原始数据块管理</li>
<li>偏好管理</li>
<li>URL及数据流操作</li>
<li>线程和RunLoop</li>
<li>端口和soket通讯</li>
</ol>
<p>Core Foundation框架和Foundation框架紧密相关，它们为相同功能提供接口，但Foundation框架提供Objective-C接口。如果您将Foundation对象和Core Foundation类型掺杂使用，则可利用两个框架之间的 “toll-free bridging”。所谓的Toll-free bridging是说您可以在某个框架的方法或函数同时使用Core Foundatio和Foundation 框架中的某些类型。很多数据类型支持这一特性，其中包括群体和字符串数据类型。每个框架的类和类型描述都会对某个对象是否为 toll-free bridged，应和什么对象桥接进行说明。<br>如需进一步信息，请阅读Core Foundation 框架参考。</p>
<p>自 Xcode4.2 开始导入ARC机制后，为了支持对象间的转型，Apple又增加了许多转型用的关键字。这一讲我们就来了解其用法，以及产生的理由。</p>
<p>###引子<br>我们先来看一下ARC无效的时候，我们写id类型转void*类型的写法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = obj;</div></pre></td></tr></table></figure>
<p>反过来，当把void*对象变回id类型时，只是简单地如下来写，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = p;</div><div class="line">[obj release];</div></pre></td></tr></table></figure>
<p>但是上面的代码在ARC有效时，就有了下面的错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">error: implicit conversion of an Objective-C pointer</div><div class="line">    to ’<span class="keyword">void</span> *’ is disallowed with ARC</div><div class="line">    <span class="keyword">void</span> *p = obj;</div><div class="line">              ^</div><div class="line"> </div><div class="line">error: implicit conversion of a non-Objective-C pointer</div><div class="line">    type ’<span class="keyword">void</span> *’ to ’<span class="keyword">id</span>’ is disallowed with ARC</div><div class="line">    <span class="keyword">id</span> o = p;</div><div class="line">            ^</div></pre></td></tr></table></figure>
<p>###<strong>bridge<br>为了解决这一问题，我们使用 </strong>bridge 关键字来实现id类型与void*类型的相互转换。看下面的例子。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;</div><div class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;</div></pre></td></tr></table></figure>
<p>将Objective-C的对象类型用 <strong>bridge 转换为 void* 类型和使用 </strong>unsafe_unretained 关键字修饰的变量是一样的。被代入对象的所有者需要明确对象生命周期的管理，不要出现异常访问的问题。<br>除过 <strong>bridge 以外，还有两个 </strong>bridge 相关的类型转换关键字：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__bridge_transfer</div><div class="line">__bridge_retained</div></pre></td></tr></table></figure>
<p>接下来，我们将看看这两个关键字的区别。</p>
<p>###<strong>bridge_retained<br>先来看使用 </strong>bridge_retained 关键字的例子程序：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)obj;</div></pre></td></tr></table></figure>
<p>从名字上我们应该能理解其意义：类型被转换时，其对象的所有权也将被变换后变量所持有。如果不是ARC代码，类似下面的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = obj;</div><div class="line">[(<span class="keyword">id</span>)p <span class="keyword">retain</span>];</div></pre></td></tr></table></figure>
<p>可以用一个实际的例子验证，对象所有权是否被持有。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    p = (__bridge_retained <span class="keyword">void</span> *)obj;</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);</div></pre></td></tr></table></figure>
<p>出了大括号的范围后，p 仍然指向一个有效的实体。说明他拥有该对象的所有权，该对象没有因为出其定义范围而被销毁。</p>
<p>###<strong>bridge_transfer<br>相反，当想把本来拥有对象所有权的变量，在类型转换后，让其释放原先所有权的时候，需要使用</strong>bridge_transfer 关键字。文字有点绕口，我们还是来看一段代码吧。</p>
<p>如果ARC无效的时候，我们可能需要写下面的代码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p 变量原先持有对象的所有权</span></div><div class="line"><span class="keyword">id</span> obj = (<span class="keyword">id</span>)p;</div><div class="line">[obj <span class="keyword">retain</span>];</div><div class="line">[(<span class="keyword">id</span>)p release];</div></pre></td></tr></table></figure>
<p>那么ARC有效后，我们可以用下面的代码来替换：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p 变量原先持有对象的所有权</span></div><div class="line"><span class="keyword">id</span> obj = (__bridge_transfer <span class="keyword">id</span>)p;</div><div class="line">可以看出来，__bridge_retained 是编译器替我们做了 <span class="keyword">retain</span> 操作，而 __bridge_transfer 是替我们做了 release1。</div></pre></td></tr></table></figure>
<p>###Toll-Free bridged<br>在iOS世界，主要有两种对象：Objective-C 对象和 Core Foundation 对象0。Core Foundation 对象主要是有C语言实现的 Core Foundation Framework 的对象，其中也有对象引用计数的概念，只是不是 Cocoa Framework::Foundation Framework 的 retain/release，而是自身的 CFRetain/CFRelease 接口。</p>
<p>这两种对象间可以互相转换和操作，不使用ARC的时候，单纯的用C原因的类型转换，不需要消耗CPU的资源，所以叫做 Toll-Free bridged。比如 NSArray和CFArrayRef, NSString和CFStringRef，他们虽然属于不同的 Framework，但是具有相同的对象结构，所以可以用标准C的类型转换。</p>
<p>比如不使用ARC时，我们用下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:...];</div><div class="line"><span class="built_in">CFStringRef</span> cfString = (<span class="built_in">CFStringRef</span>)string;</div></pre></td></tr></table></figure>
<p>同样，Core Foundation类型向Objective-C类型转换时，也是简单地用标准C的类型转换即可。<br>但是在ARC有效的情况下，将出现类似下面的编译错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Cast of Objective-C pointer type ‘<span class="built_in">NSString</span> *’ to C pointer type ‘<span class="built_in">CFStringRef</span>’ (aka ‘<span class="keyword">const</span> <span class="keyword">struct</span> __CFString *’) requires a bridged cast</div><div class="line">Use __bridge to convert directly (no change <span class="keyword">in</span> ownership)</div><div class="line">Use __bridge_retained to make an ARC object available as a +<span class="number">1</span> ‘<span class="built_in">CFStringRef</span>’ (aka ‘<span class="keyword">const</span> <span class="keyword">struct</span> __CFString *’)</div></pre></td></tr></table></figure>
<p>错误中已经提示了我们需要怎样做：用 <strong>bridge 或者 </strong>bridge_retained 来转型，其差别就是变更对象的所有权。</p>
<p>正因为Objective-C是ARC管理的对象，而Core Foundation不是ARC管理的对象，所以才要特意这样转换，这与id类型向void*转换是一个概念。也就是说，当这两种类型（有ARC管理，没有ARC管理）在转换时，需要告诉编译器怎样处理对象的所有权。</p>
<p>上面的例子，使用 <strong>bridge/</strong>bridge_retained 后的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:...];</div><div class="line"><span class="built_in">CFStringRef</span> cfString = (__bridge <span class="built_in">CFStringRef</span>)string;</div></pre></td></tr></table></figure>
<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当string对象被释放的时候，cfString也不能被使用了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:...];</div><div class="line"><span class="built_in">CFStringRef</span> cfString = (__bridge_retained <span class="built_in">CFStringRef</span>)string;</div><div class="line">...</div><div class="line"><span class="built_in">CFRelease</span>(cfString); <span class="comment">// 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release</span></div></pre></td></tr></table></figure>
<p>使用 __bridge_retained 可以通过转换目标处（cfString）的 retain 处理，来使所有权转移。即使 string 变量被释放，cfString 还是可以使用具体的对象。只是有一点，由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release。</p>
<p>实际上，Core Foundation 内部，为了实现Core Foundation对象类型与Objective-C对象类型的相互转换，提供了下面的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">CFTypeRef  <span class="title">CFBridgingRetain</span><span class="params">(id  X)</span>  </span>&#123;</div><div class="line">    <span class="keyword">return</span>  (__bridge_retained  CFTypeRef)X;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">id  <span class="title">CFBridgingRelease</span><span class="params">(CFTypeRef  X)</span>  </span>&#123;</div><div class="line">    <span class="keyword">return</span>  (__bridge_transfer  id)X;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，可以用 CFBridgingRetain 替代 __bridge_retained 关键字：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:...];</div><div class="line"><span class="built_in">CFStringRef</span> cfString = <span class="built_in">CFBridgingRetain</span>(string);</div><div class="line">...</div><div class="line"><span class="built_in">CFRelease</span>(cfString); <span class="comment">// 由于Core Foundation不在ARC管理范围内，所以需要主动release。</span></div></pre></td></tr></table></figure>
<p>###<strong>bridge_transfer<br>所有权被转移的同时，被转换变量将失去对象的所有权。当Core Foundation对象类型向Objective-C对象类型转换的时候，会经常用到 </strong>bridge_transfer 关键字。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> cfString = <span class="built_in">CFStringCreate</span>...();</div><div class="line"><span class="built_in">NSString</span> *string = (__bridge_transfer <span class="built_in">NSString</span> *)cfString;</div><div class="line"><span class="comment">// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release</span></div></pre></td></tr></table></figure>
<p>同样，我们可以使用 CFBridgingRelease() 来代替 __bridge_transfer 关键字。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> cfString = <span class="built_in">CFStringCreate</span>...();</div><div class="line"><span class="built_in">NSString</span> *string = <span class="built_in">CFBridgingRelease</span>(cfString);</div></pre></td></tr></table></figure>
<p>###总结<br>由上面的学习我们了解到 ARC 中类型转换的用法，那么我们实际使用中按照怎样的原则或者方法来区分使用呢，下面我总结了几点关键要素。</p>
<p>明确被转换类型是否是 ARC 管理的对象</p>
<p>Core Foundation 对象类型不在 ARC 管理范畴内</p>
<p>Cocoa Framework::Foundation 对象类型（即一般使用到的Objectie-C对象类型）在 ARC 的管理范畴内<br>如果不在 ARC 管理范畴内的对象，那么要清楚 release 的责任应该是谁。</p>
<p>各种对象的生命周期是怎样的</p>
<ol>
<li>声明 id obj 的时候，其实是缺省的申明了一个 <strong>strong 修饰的变量，所以编译器自动地加入了 retain 的处理，所以说 </strong>bridge_transfer 关键字只为我们做了 release 处理。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/22/ios-shen-ru-qian-chu-objczhi-xiao-xi/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/22/ios-shen-ru-qian-chu-objczhi-xiao-xi/" itemprop="url">
                  [iOS]深入浅出ObjC之消息
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-22T21:57:41+08:00">
              2014-10-22
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/22/ios-shen-ru-qian-chu-objczhi-xiao-xi/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/22/ios-shen-ru-qian-chu-objczhi-xiao-xi/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在入门级别的ObjC 教程中，我们常对从C++或Java 或其他面向对象语言转过来的程序员说，ObjC 中的方法调用（ObjC中的术语为消息）跟其他语言中的方法调用差不多，只是形式有些不同而已。<br>譬如Ｃ++ 中的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bird * aBird = <span class="keyword">new</span> Bird();</div><div class="line">aBird-&gt;fly();</div></pre></td></tr></table></figure>
<p>在ObjC 中则如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bird * aBird = [[Bird alloc] init];</div><div class="line">[aBird fly];</div></pre></td></tr></table></figure>
<p>初看起来，好像只是书写形式不同而已，实则差异大矣。Ｃ++中的方法调用可能是动态的，也可能是静态的；而ObjC中的消息都为动态的。下文将详细介绍为什么是动态的，以及编译器在这背后做了些什么事情。<br>要说清楚消息这个话题，我们必须先来了解三个概念Class, SEL, IMP，它们在objc/objc.h 中定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</div><div class="line">	Class isa;</div><div class="line">&#125; *id;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>;</div><div class="line"><span class="comment">///Class 的含义</span></div><div class="line"><span class="comment">///Class 被定义为一个指向 objc_class的结构体指针，这个结构体表示每一个类的类结构。而 objc_class 在objc/objc_class.h中定义如下:</span></div><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">	<span class="keyword">struct</span> objc_class super_class; <span class="comment">/*父类*/</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/*类名字*/</span></div><div class="line">	<span class="keyword">long</span> version; <span class="comment">/*版本信息*/</span></div><div class="line">	<span class="keyword">long</span> info; <span class="comment">/*类信息*/</span></div><div class="line">	<span class="keyword">long</span> instance_size; <span class="comment">/*实例大小*/</span></div><div class="line">	<span class="keyword">struct</span> objc_ivar_list *ivars; <span class="comment">/*实例参数链表*/</span></div><div class="line">	<span class="keyword">struct</span> objc_method_list **methodLists; <span class="comment">/*方法链表*/</span></div><div class="line">	<span class="keyword">struct</span> objc_cache *cache; <span class="comment">/*方法缓存*/</span></div><div class="line">	<span class="keyword">struct</span> objc_protocol_list *protocols; <span class="comment">/*协议链表*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由此可见，Class 是指向类结构体的指针，该类结构体含有一个指向其父类类结构的指针，该类方法的链表，该类方法的缓存以及其他必要信息。</p>
<p>NSObject 的class 方法就返回这样一个指向其类结构的指针。每一个类实例对象的第一个实例变量是一个指向该对象的类结构的指针，叫做isa。通过该指针，对象可以访问它对应的类以及相应的父类。如图一所示：</p>
<img src="/uploads/2014/10/22/1.gif" class="center">
<p>如图一所示，圆形所代表的实例对象的第一个实例变量为 isa，它指向该类的类结构 The object’s class。而该类结构有一个指向其父类类结构的指针superclass， 以及自身消息名称(selector)/实现地址(address)的方法链表。</p>
<p>##方法的含义：<br>注意这里所说的方法链表里面存储的是Method 类型的。图一中selector 就是指 Method的 SEL, address就是指Method的 IMP。 Method 在头文件 objc_class.h中定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ method &#123;</div><div class="line">SEL method_name;</div><div class="line"><span class="keyword">char</span> *method_types;</div><div class="line">IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个方法 Method，其包含一个方法选标 SEL – 表示该方法的名称，一个types – 表示该方法的参数，一个 IMP - 指向该方法的具体实现的函数指针。</p>
<p>##SEL 的含义：</p>
<p>在前面我们看到方法选标 SEL 的定义为：<br><code>typedef struct objc_selector *SEL;</code></p>
<p>它是一个指向 objc_selector 指针，表示方法的名字。如下所示，打印出 selector。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSInteger</span>)maxIn:(<span class="built_in">NSInteger</span>)a theOther:(<span class="built_in">NSInteger</span>)b</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> (a &gt; b) ? a : b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"SEL=%s"</span>, <span class="keyword">@selector</span>(maxIn:theOther:));</div></pre></td></tr></table></figure>
<p>输出：SEL=maxIn:theOther:</p>
<p>不同的类可以拥有相同的 selector，这个没有问题，因为不同类的实例对象performSelector相同的 selector 时，会在各自的消息选标(selector)/实现地址(address) 方法链表中根据 selector 去查找具体的方法实现IMP, 然后用这个方法实现去执行具体的实现代码。这是一个动态绑定的过程，在编译的时候，我们不知道最终会执行哪一些代码，只有在执行的时候，通过selector去查询，我们才能确定具体的执行代码。</p>
<p>##IMP 的含义：<br>在前面我们也看到 IMP 的定义为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...);</div></pre></td></tr></table></figure>
<p>根据前面id 的定义，我们知道 id是一个指向 objc_object 结构体的指针，该结构体只有一个成员isa，所以任何继承自 NSObject 的类对象都可以用id 来指代，因为 NSObject 的第一个成员实例就是isa。</p>
<p>至此，我们就很清楚地知道 IMP 的含义：IMP 是一个函数指针，这个被指向的函数包含一个接收消息的对象<br>id(self 指针), 调用方法的选标 SEL (方法名)，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码 。我们可以像在Ｃ语言里面一样使用这个函数指针。<br>NSObject 类中的methodForSelector：方法就是这样一个获取指向方法实现IMP 的指针，methodForSelector：返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型。<br>下面的例子展示了怎么使用指针来调用setFilled:的方法实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span>(*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</div><div class="line">	<span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<p>使用methodForSelector：来避免动态绑定将减少大部分消息的开销，但是这只有在指定的消息被重复发送很多次时才有意义，例如上面的for循环。<br>注意，methodForSelector：是Cocoa运行时系统的提供的功能，而不是Objective-C语言本身的功能。</p>
<p>##消息调用过程：<br>至此我们对ObjC 中的消息应该有个大致思路了：示例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bird * aBird = [[Bird alloc] init];</div><div class="line">[aBird fly];</div></pre></td></tr></table></figure>
<p>中对 fly 的调用，编译器通过插入一些代码，将之转换为对方法具体实现IMP的调用，这个 IMP是通过在 Bird 的类结构中的方法链表中查找名称为fly 的 选标SEL 对应的具体方法实现找到的。<br>上面的思路还有一些没有提及的话题，比如说编译器插入了什么代码，如果在方法链表中没有找到对应的 IMP又会如何，这些话题在下面展开。</p>
<p>##消息函数 obj_msgSend：<br>编译器会将消息转换为对消息函数 objc_msgSend的调用，该函数有两个主要的参数：消息接收者id 和消息对应的方法选标 SEL, 同时接收消息中的任意参数：<br>id objc_msgSend(id theReceiver, SELtheSelector, …)<br>如上面的消息 [aBird fly]会被转换为如下形式的函数调用：<br>objc_msgSend(aBird, @selector(fly));<br>该消息函数做了动态绑定所需要的一切工作：<br>1，它首先找到 SEL 对应的方法实现 IMP。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。<br>2，然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传递给方法实现 IMP。<br>3，最后，将方法实现的返回值作为该函数的返回值返回。</p>
<p>编译器会自动插入调用该消息函数objc_msgSend的代码，我们无须在代码中显示调用该消息函数。当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数：消息的接收者以及方法名称 SEL。这些参数帮助方法实现获得了消息表达式的信息。它们被认为是”隐藏“的是因为它们并没有在定义方法的源代码中声明，而是在代码编译时是插入方法的实现中的。</p>
<p>尽管这些参数没有被显示声明，但在源代码中仍然可以引用它们（就象可以引用消息接收者对象的实例变量一样）。在方法中可以通过self来引用消息接收者对象，通过选标_cmd来引用方法本身。在下面的例子中，_cmd 指的是strange方法，self指的收到strange消息的对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> target = getTheReceiver();</div><div class="line">	SEL method = getTheMethod();</div><div class="line">	<span class="keyword">if</span> (target == <span class="keyword">self</span> || mothod == _cmd)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">	<span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这两个参数中，self更有用一些。实际上，它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<p>##查找 IMP 的过程：</p>
<p>前面说了，objc_msgSend 会根据方法选标 SEL 在类结构的方法列表中查找方法实现IMP。这里头有一些文章，我们在前面的类结构中也看到有一个叫objc_cache *cache 的成员，这个缓存为提高效率而存在的。每个类都有一个独立的缓存，同时包括继承的方法和在该类中定义的方法。。<br>查找IMP 时：</p>
<ol>
<li>首先去该类的方法 cache 中查找，如果找到了就返回它；</li>
<li>如果没有找到，就去该类的方法列表中查找。如果在该类的方法列表中找到了，则将 IMP 返回，并将它加入cache中缓存起来。根据最近使用原则，这个方法再次调用的可能性很大，缓存起来可以节省下次调用再次查找的开销。</li>
<li>如果在该类的方法列表中没找到对应的 IMP，在通过该类结构中的 super_class指针在其父类结构的方法列表中去查找，直到在某个父类的方法列表中找到对应的IMP，返回它，并加入cache中。</li>
<li>如果在自身以及所有父类的方法列表中都没有找到对应的 IMP，则进入下文中要讲的消息转发流程。</li>
</ol>
<p>##便利函数：<br>我们可以通过NSObject的一些方法获取运行时信息或动态执行一些消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> 返回对象的类；</div><div class="line">isKindOfClass 和 isMemberOfClass检查对象是否在指定的类继承体系中；</div><div class="line">respondsToSelector 检查对象能否相应指定的消息；</div><div class="line">conformsToProtocol 检查对象是否实现了指定协议类的方法；</div><div class="line">methodForSelector 返回指定方法实现的地址。</div><div class="line">performSelector:withObject 执行SEL 所指代的方法。</div></pre></td></tr></table></figure>
<p>##消息转发：<br>通常，给一个对象发送它不能处理的消息会得到出错提示，然而，Objective-C运行时系统在抛出错误之前，会给消息接收对象发送一条特别的消息forwardInvocation 来通知该对象，该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。<br>我们可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<p>关于消息转发的作用，可以考虑如下情景：假设，我们需要设计一个能够响应negotiate消息的对象，并且能够包括其它类型的对象对消息的响应。 通过在negotiate方法的实现中将negotiate消息转发给其它的对象来很容易的达到这一目的。</p>
<p>更进一步，假设我们希望我们的对象和另外一个类的对象对negotiate的消息的响应完全一致。一种可能的方式就是让我们的类继承其它类的方法实现。 然后，有时候这种方式不可行，因为我们的类和其它类可能需要在不同的继承体系中响应negotiate消息。</p>
<p>虽然我们的类无法继承其它类的negotiate方法，但我们仍然可以提供一个方法实现，这个方法实现只是简单的将negotiate消息转发给其他类的对象，就好像从其它类那儿“借”来的现一样。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- negotiate</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> ([someOtherObject respondsToSelector:<span class="keyword">@selector</span>(negotiate)])</div><div class="line">		<span class="keyword">return</span> [someOtherObject negotiate];</div><div class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式显得有欠灵活，特别是有很多消息都希望传递给其它对象时，我们就必须为每一种消息提供方法实现。此外，这种方式不能处理未知的消息。当我们写下代码时，所有我们需要转发的消息的集合都必须确定。然而，实际上，这个集合会随着运行时事件的发生，新方法或者新类的定义而变化。</p>
<p><code>forwardInvocation:</code>消息给这个问题提供了一个更特别的，动态的解决方案：当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过forwardInvocation:消息通知该对象。每个对象都从NSObject类中继承了<code>forwardInvocation:</code>方法。然而，NSObject中的方法实现只是简单地调用了doesNotRecognizeSelector:。通过实现我们自己的<code>forwardInvocation:</code>方法，我们可以在该方法实现中将消息转发给其它对象。</p>
<p>要转发消息给其它对象，forwardInvocation:方法所必须做的有：</p>
<ol>
<li>决定将消息转发给谁，并且</li>
<li>将消息和原来的参数一块转发出去。</li>
</ol>
<p>消息可以通过invokeWithTarget:方法来转发：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> ([someOtherObject respondsToSelector:[anInvocation selector]])</div><div class="line">		[anInvocation invokeWithTarget:someOtherObject];</div><div class="line">	<span class="keyword">else</span></div><div class="line">		[<span class="keyword">super</span> forwardInvocation:anInvocation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转发消息后的返回值将返回给原来的消息发送者。您可以将返回任何类型的返回值，包括: id，结构体，浮点数等。</p>
<p><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。forwardInvocation:方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p>
<p>注意： <code>forwardInvocation:</code>方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将negotiate消息转发给其它对象，则这个对象不能有negotiate方法。否则，forwardInvocation:将不可能会被调用。</p>
<p>##参考资料：<br>Objective-CRuntime Reference:<br><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html" target="_blank" rel="external">http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html</a><br>Objective-C Runtime Programming Guide:<br><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></p>
<p>转自：<br>罗朝辉（<a href="http://blog.csdn.net/kesalin）" target="_blank" rel="external">http://blog.csdn.net/kesalin）</a><br><a href="http://hi.baidu.com/jt_one/blog/item/96f972cf411a7027f9dc61d8.html" target="_blank" rel="external">http://hi.baidu.com/jt_one/blog/item/96f972cf411a7027f9dc61d8.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/22/ios-iosmian-shi-wen-ti-zong-jie/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/22/ios-iosmian-shi-wen-ti-zong-jie/" itemprop="url">
                  [iOS]IOS面试问题总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-22T17:47:48+08:00">
              2014-10-22
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/22/ios-iosmian-shi-wen-ti-zong-jie/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/22/ios-iosmian-shi-wen-ti-zong-jie/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过网络搜寻和自己总结经历找了一些IOS面试经常被问道的问题：</p>
<p>##1.搞清楚touch事件的传递(事件的响应链)</p>
<p>事件的响应（responder chain）<br></p>
<p>只有继承了UIResponder的类才能响应touch事件，从上图的响应者链可以看出，优先是最上层的view响应事件，如果该view有视图控制器的话会是下一个响应者，否者就是该view的父视图，这样至上而下传递事件。直到单例UIWindow对象，最后是单例UIApplication对象以终止，UIApplication的下一个响应者是nil，已结束整个响应循环。事件在传递过程中视图可以决定是否需要对该事件进行响应。<br></p>
<p>事件分发（Event Delivery）<br></p>
<p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。整个响应者链和事件分发的使命都是找出第一响应者。</p>
<p>UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。</p>
<p>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。</p>
<p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果pointInside:withEvent:返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。<br>hitTest:withEvent:方法的处理流程如下:<br>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;<br>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</p>
<p>##2.fame，bounds，center，alpha,opaque,hidden</p>
<p>这些都是view的一些基本属性。frame是描述该view在其父视图中的一块区域。其坐标系是在其父视图中的坐标。我们在进行view的初始化时会经常使用到frame。bounds也是描述该view的大小，是其在自身的坐标系中的位置大小。center是描述其在父视图的中心位置坐标。我们在进行view的位置改变而不改变view的大小的时，会使用center。alpha是用来描述改view的透明度从0到1，0表示的是透明，1表示不透明。alpha支持动画（animation），alpha = 0 与 hidden ＝ YES 效果一样都是看不到view，但是后者相比开销大。在alpha等于0时view接受touch事件，但是hidden则不接受。并且hidden和apaque 不支持动画。alpha并不影响镶嵌在其内部view行为，而hidden会影响。当把view设置为透明背景时，一般把opaque设置为NO，可以减少开销，优化内存.opaque影响图形绘制系统。设置为YES，会优化view的绘制。</p>
<p>##3，nil,NSNULL,NULL区别</p>
<p>nil是指向obj－c中对象的空指针，是一个对象，在o－c中ni对象调用方法不会引起crash。</p>
<p>Nil是指向obj－c中的类的空指针，表示的是一个空类。</p>
<p>NULL是指向任何类型的空指针（如c／c++中的空指针），在objective－c中是一个数值。</p>
<p>NSNULL用于集合操作，在集合对象中，表示一个空值的集合对象。</p>
<p>##4.KVC and KVO</p>
<p>KVC（key－value－coding）键值编码，是一种间接操作对象属性的一种机制，可以给属性设置值。通过setValue：forKey：和valueForKey，实现对属性的存取和访问。</p>
<p>KVO（key－value－observing）键值观察，是一种使用观察者模式来观察属性的变化以便通知注册的观察者。通过注册observing对象addObserver:forKeyPath:options:context:和观察者类必须重写方法 observeValueForKeyPath:ofObject:change:context:。常应用MVC模型中，数据库（dataModal）发生变化时，引起view改变。</p>
<p>##5.NSThread,NSOperation,GCD</p>
<p>NSThread,NSOperation,GCD是IOS中使用多线程的三种方式之一。他们各有优缺点。抽象层次是从低到高的，抽象度越高的使用越简单。</p>
<p>NSThread，缺点：需要自己维护线程的生命周期和线程的同步和互斥，但是这些都需要耗费系统的资源。优点：比其它两个更轻。</p>
<p>NSOperation,优点：不需要自己管理线程的生命周期和线程的同步和互斥等。只是需要关注自己的业务逻辑处理，需要和NSOperationQueue一起使用。</p>
<p>GCD，是Apple开发的一个多核编程解决方法，优点：比前面两者更高效更强大。</p>
<p>##6.autorelease ,ARC 和非ARC</p>
<p>autorelease 自动释放，与之相关联的是一个自动释放池（NSAutoReleasePool）.autorelease的变量会被放入自动释放池中。等到自动释放池释放时（drain）时，自动释放池中的自动释放变量会随之释放。ios系统应用程序在创建是有一个默认的NSAutoReleasePool，程序退出时会被销毁。但是对于每一个RunLoop，系统会隐含创建一个AutoReleasePool，所有的release pool会构成一个栈式结构，每一个RunLoop结束，当前栈顶的pool会被销毁。</p>
<p>ARC，自动应用计数。（iOS 6加入）IOS内存管理是基于变量的应用计数的。这样系统帮你管理变量的release，retain等操作。</p>
<p>非ARC，非自动应用计数。手动管理内存。自己负责系统变量的release，retain等操作。做到谁分配谁释放，及alloc和release像对应。函数返回对象时使用autorelease。</p>
<p>可以使用Xcode将非ARC转化为ARC，ARC和非ARC混编。可在在编译ARC时使用－fno－objc－arc，-fobjc-arc标签。实际需要看工程是支持还是不支持ARC模式。</p>
<p>##7.xib，storyboard，手动书写代码</p>
<p>xib（interface buider）,方便对界面进行编辑。可以在窗口上面直接添加各种视图，优点：直接看到界面的效果，操作简单。缺点：不方便对视图进行动态控制，不灵活。</p>
<p>手动编写代码，继承（主要是UIView，UIViewController），优点：可以对视图进行定制，灵活控制方便。缺点：不能马上看到效果，复杂。</p>
<p>storyboard（故事板在ios6加入）。优点：可以看到界面效果，能同时进行多个界面的交互，高效快速。缺点：不能进行进行界面的定制，却笑灵活性。</p>
<p>xib和storyboard主要用于界面中的元素位置固定和清楚里面有哪些元素。但是如果需要动态变化界面还是手动编写代码比较好。一般还是各种方式混合使用。</p>
<p>##8.loadView,viewDidLoad,ViewDidUnload,viewWillAppear,viewDidAppear,viewwilldDisappear,viewDidDisappear</p>
<p>当view的nib文件为nil时，手动创建界面时调用loadView，当view的nib文件存在时，会在viewDidLoad中实现。但是当你的程序运行期间内存不足时，视图控制器收到didReceiveMemoryWarning时，系统会检查当前的视图控制器的view是否还在使用，如果不在，这个view会被release，再次调用loadView来创建一个新的View。viewDidLoad ,不论是从xib中加载视图，还是从loadview生成视图，都会被调用。但是如果改view在栈中下一次显示是不会被调用。ViewWillAppear，ViewDidAppear会在view每次即将可见和完全显示时都会调用。我们会在ViewWillAppear里面进行一些view显示的准备工作，ViewDidDi sappear 和ViewWillDisAppear时会在view每次消失时都会调用。当系统收到didReceiveMemoryWarning通知时显示内存不足时，会调用ViewDidUnload来清理View中的数据和release后置为nil。</p>
<p>##9，copy 和retain区别</p>
<p>retain,相当于指针拷贝。变量的引用计数加一。另外一个指针也指向改地址。</p>
<p>copy，相当于内容拷贝。变量的引用计数加一。但是自己本身计数不变。开辟另外一个地址空间放入相同变量的值进去。</p>
<p>##10，手动写setter和getter方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) setOldValue: (<span class="built_in">NSString</span>*) newValue </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (newValue !=oldValue) &#123;</div><div class="line">        [oldValue release];</div><div class="line">        oldValue = [newValue <span class="keyword">retain</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##11，NSRunLoop 和NSOperationQueue</p>
<p>NSRunLoop 是所有要监视的输入源和定时源以及要通知的注册观察者的集合.用来处理诸如鼠标，键盘事件等的输入源。每一个线程拥有自己的RunLoop有系统自动创建。你不应该自己去创建，只能获取。一般不会用NSRunLoop,因为它不是线程安全的。一般都用CFRunLoop，这个是线程安全的，是一种消息处理模式，我们一般不用进行处理。</p>
<p>NSOperationQueue时一个管理NSOperation的队列。我们会把NSOperation放入queue中进行管理。</p>
<p>##12,IOS常用的设计模式</p>
<p>单例模式，DeafutCenter,Deafultqueue等</p>
<p>MVC模式，View，model,ViewController。</p>
<p>观察者模式，通知，KVO</p>
<p>工厂模式，</p>
<p>代理模式，delegate</p>
<p>##13.内存管理和优化</p>
<p>原则：</p>
<p>1.1    谁创建，谁释放（类似于“谁污染，谁治理”）。如果你通过alloc、new或copy来创建一个对象，那么你必须调用release或autorelease。换句话说，不是你创建的，就不用你去释放。<br>例如，你在一个函数中alloc生成了一个对象，且这个对象只在这个函数中被使用，那么你必须在这个函数中调用release或autorelease。如果你在一个class的某个方法中alloc一个成员对象，且没有调用autorelease，那么你需要在这个类的dealloc方法中调用release；如果调用了autorelease，那么在dealloc方法中什么都不需要做。<br>1.2  除了alloc、new或copy之外的方法创建的对象都被声明了autorelease。<br>1.3  谁retain，谁release。只要你调用了retain，无论这个对象是如何生成的，你都要调用release。有时候你的代码中明明没有retain，可是系统会在默认实现中加入retain。</p>
<p>优化：</p>
<p>在收到内存didReceiveMemoryWarning的警告时，释放掉一些不再需要的资源，注意编码规范，如一些变量不使用需要及时的释放。避免是占用太多的内存空间，有时需要用空间去换取时间，尽量使用一些高效的算法和数据结构节约内存空间。最后使用一些内存检测工具和代码的静态分析查找内存泄漏和分配（instrument，leaks，allocations）。</p>
<p>##14，tableview的优化</p>
<p>优化：</p>
<p>1.1 正确的复用cell。</p>
<p>1.2 减少在返回每个cell里面的处理逻辑和处理时间。尽量将数据进行缓存和复用。</p>
<p>1.3，尽量减少处理加载和计算的时间，不阻塞UI线程。</p>
<p>1.4，尽量使用绘制每个cell。</p>
<p>1.5，设置每个cell的opaque属性。</p>
<p>1.6，尽量返回每行固定的height。</p>
<p>1.7，在每个cell减少图形效果。</p>
<p>1.8，分段加载数据。</p>
<p>##15，opengl，quatarz 2d</p>
<p>上面2种方式是进行图形绘制会使用到的技术。</p>
<p>quatarz 2d 是Apple提供的基于Core graphic的绘制基本图形工具库。操作简单方便，能够满足大部分需要。只是适用于2D图形的绘制。</p>
<p>opengl，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。功能强大但是复杂。</p>
<p>##16, animation</p>
<p>IOS提供丰富的Core Animation动画满足用户的需要，主要实现方式如下3种：</p>
<p>1.1  commitAnimations方式使用UIView动画</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> Animations 动画: </div><div class="line">[<span class="built_in">UIView</span> beginAnimations:<span class="string">@"animationID"</span> context:<span class="literal">nil</span>]; </div><div class="line">[<span class="built_in">UIView</span> setAnimationDuration:<span class="number">0.5</span>f]; </div><div class="line">[<span class="built_in">UIView</span> setAnimationCurve:<span class="built_in">UIViewAnimationCurveEaseInOut</span>]; </div><div class="line">[<span class="built_in">UIView</span> setAnimationRepeatAutoreverses:<span class="literal">NO</span>]; </div><div class="line"><span class="comment">//以下四种效果 </span></div><div class="line"><span class="comment">/* </span></div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:self.view cache:YES];//oglFlip, fromLeft </div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.view cache:YES];//oglFlip, fromRight  </div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionCurlUp forView:self.view cache:YES]; </div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionCurlDown forView:self.view cache:YES]; </div><div class="line">*/ </div><div class="line"><span class="comment">//你自己的操作</span></div><div class="line">[<span class="built_in">UIView</span> commitAnimations];</div></pre></td></tr></table></figure>
<p>1.2、CATransition</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CATransition</span> *animation = [<span class="built_in">CATransitionanimation</span>];</div><div class="line">animation.duration = <span class="number">0.5</span>f;</div><div class="line">animation.timingFunction =<span class="built_in">UIViewAnimationCurveEaseInOut</span>;</div><div class="line">animation.fillMode = kCAFillModeForwards;</div><div class="line">animation.type = kCATransitionMoveIn;</div><div class="line">animation.subtype = kCATransitionFromTop;</div><div class="line">[<span class="keyword">self</span>.window.layeraddAnimation:animationforKey:<span class="string">@"animation"</span>];</div></pre></td></tr></table></figure>
<p>///自己的操作<br>1.3、UIView animateWithDuration</p>
<p>方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">void</span>)animateWithDuration:(<span class="built_in">NSTimeInterval</span>)duration animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations; </div><div class="line">+ (<span class="keyword">void</span>)animateWithDuration:(<span class="built_in">NSTimeInterval</span>)duration animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion; <span class="comment">//多一个动画结束后可以执行的操作. </span></div><div class="line"></div><div class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.25</span> animations:^&#123; </div><div class="line"><span class="built_in">CGAffineTransform</span> newTransform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.2</span>, <span class="number">1.2</span>); </div><div class="line">[firstImageView setTransform:newTransform]; </div><div class="line">[secondImageView setTransform:newTransform];&#125; </div><div class="line">completion:^(<span class="built_in">BOOL</span> finished)&#123; </div><div class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.2</span> animations:^&#123; </div><div class="line">／／自己的操作&#125; completion:^(<span class="built_in">BOOL</span> finished)&#123; 自己的操作&#125;]; </div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>##17,定制化view </p>
<p>需要自己自己继承自cocoa touch提供的丰富的类。如（UIView，UiScrollView，UITableView等等）。需要重载实现drawRect，touch事件，init，initFrame等方法。</p>
<p>##18.core Data,sqlite,file，NSUserDefaults</p>
<p>上面四种是IOS中数据存取的方式。</p>
<p>Core Data，sqlite涉及到数据库。sqlite需要通过sqlite语句操作数据库，而core data是Apple提供的一个基于sqlite更抽象成对象的一种对数据库操作方式。</p>
<p>file，主要是把数据存储在磁盘中。通过写和读文件操作。</p>
<p>NSUserDefaults，主要是存储应用程序中的一些轻量级数据如应用程序的设置和属性和用户信息等。</p>
<p>##19.机型和尺寸的适配</p>
<p>Iphone 的主要尺寸是3.5和4英寸。分辨率为：320<em>480,480</em>960（retina）。</p>
<p>IPad 主要尺寸是7.9和9.7英寸。分辨率为：1024<em>768，2048</em>1536（retina）。</p>
<p>##20.添加手势的方式（gesture和touches事件）</p>
<ol>
<li><p>自己重载实现touchMoved，touchBegin，touchEnd，touchCanceled事件。</p>
</li>
<li><p>通过UIGestureRecongnizer添加AddGestureRecognier事件。该方式方便添加一些诸如点击，双击，拖动等基本的手势事件。</p>
</li>
</ol>
<p>##21.应用程序的生命周期和状态<br>(参照：<a href="http://blog.csdn.net/totogo2010/article/details/8048652）" target="_blank" rel="external">http://blog.csdn.net/totogo2010/article/details/8048652）</a></p>
<ol>
<li><p>Not running  未运行  程序没启动</p>
</li>
<li><p>Inactive          未激活        程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态</p>
</li>
<li><p>Active             激活           程序在前台运行而且接收到了事件。这也是前台的一个正常的模式</p>
</li>
<li><p>Backgroud     后台           程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态</p>
</li>
<li><p>Suspended    挂起           程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。<br>下图是程序状态变化图：</p>
</li>
</ol>
<p>各个程序运行状态时代理的回调：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">      告诉代理进程启动但还没进入状态保存</div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">     告诉代理启动基本完成程序准备开始运行</div><div class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application</div><div class="line">    当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</div><div class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application </div><div class="line">     当应用程序入活动状态执行，这个刚好跟上面那个方法相反</div><div class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</div><div class="line">    当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</div><div class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application</div><div class="line">当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</div><div class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application</div><div class="line">当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要要设置<span class="built_in">UIApplicationExitsOnSuspend</span>的键值。</div><div class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">UIApplication</span>*)application</div><div class="line">当程序载入后执行</div></pre></td></tr></table></figure>
<p>加载应用程序进入前台</p>
<p>加载应用程序进入后台</p>
<p>##22.block编程</p>
<p>Block 是一种具有匿名功能的内嵌函数块。Block 一般是用来表示、简化一小段的程式码，它特别适合用来建立一些同步执行的程式片段、封装一些小型的工作或是用来做为某一个工作完成时的回传呼叫（callback） 。格式如下：^(传入参数列) {行为主体};</p>
<p>##23.常用的开源框架</p>
<p>网络框架：ASIHttpRequest，AFNetworking,coocaHttpServer等。</p>
<p>进度条：SVprogressHUD,MBprogressHUD,</p>
<p>工具类：SSToolKit等。</p>
<p>分享类：ShareKit等</p>
<p>日志框架：log4j，cocoa lumberJack 等。</p>
<p>##24.通知消息和代理的区别</p>
<p>通知：分为本地和远程通知。接受通知的接受者需要进行注册改通知。这样通知被NSNotificationCenter发送出来后会被注册的接受者所接受。远程通知需要借助苹果的服务器去实现通知的中转。</p>
<p>代理：把某个对象要做的事情委托给别的对象去做。</p>
<p>两者区别：</p>
<p>delegate针对one-to-one关系，用于sender接受到reciever的某个功能反馈值。</p>
<p>notification针对one-to-one/many/none,reciver,用于通知多个object某个事件，sender只是负责把notification发送出去。</p>
<p>##25.数据解析（json和XML）</p>
<p>json数据的解析通常借助一些开源的框架如：SBJson，TouchJson,jsonKit,Apple 提供的原生的JSon解析 NSJSON Serialization等。去json数据转化为IOS中常用的字典等。</p>
<p>XML数据的解析。xml分为SAX和DOM两种解析方式。</p>
<p>DOM解析XML时，读入整个XML文档并构建一个驻留内存的树结构（节点树），通过遍历树结构可以检索任意XML节点，读取它的属性和值。而且通常情况下，可以借助XPath，直接查询XML节点。</p>
<p>SAX解析XML，是基于事件通知的模式，一边读取XML文档一边处理，不必等整个文档加载完之后才采取操作，当在读取解析过程中遇到需要处理的对象，会发出通知对其进行处理。</p>
<p>一般在iOS平台下，比较常用的XML解析类库有如下几种：</p>
<p>NSXMLParser，，这是一个SAX方式解析XML的类库，默认包含在iOS SDK中，使用也比较简单。</p>
<p>libxml2，是一套默认包含在iOS SDK中的开源类库，它是基于C语言的API，所以使用起来可能不如NSXML方便。这套类库同时支持DOM和SAX解析，libxml2的SAX解析方式还是非常酷的，因为它可以边读取边解析，尤其是在从网上下载一个很大的XML文件，就可以一边下载一边对已经下载好的内容进行解析，极大的提高解析效率。</p>
<p>TBXML，这是一套轻量级的DOM方式的XML解析类库，有很好的性能和低内存占用，不过它不对XML格式进行校验，不支持XPath，并且只支持解析，不支持对XML进行修改。</p>
<p>TouchXML，这也是一套DOM方式的XML解析类库，支持XPath，不支持XML的修改。</p>
<p>KissXML，这是一套基于TouchXML的XML解析类库，和TouchXML相比，支持了XML的修改。</p>
<p>TinyXML，这是一套小巧的基于C语言的DOM方式进行XML解析的类库，支持对XML的读取和修改，不直接支持XPath，需要借助另一个相关的类库TinyXPath才可以支持XPath。</p>
<p>GDataXML，这是一套Google开发的DOM方式XML解析类库，支持读取和修改XML文档，支持XPath方式查询。</p>
<p>##26.webservice</p>
<p>Web service是一个平台独立的，松耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。技术支持包含如下：</p>
<p>1.1 xml 和xsd</p>
<p>1.2 Soap</p>
<p>1.3 wsdl</p>
<p>1.4 uddi</p>
<p>1.5 调用RPC和消息传递</p>
<p>##27.开发App的步骤，开发者账号，发布app到appstore</p>
<p>  证书分两种：开发者证书、发布者证书。前者开发时使用，后者发布使用 </p>
<p>（1） 模拟器调试无需代码签名；真机调试需开发者证书代码签名；发布时需发布证书签名 </p>
<p>（2） 代码签名需要：证书+私钥，</p>
<p>（3） 真机调试时要求在设备上安装描述文件（provision profile），该文件包含信息：调试者证书，</p>
<p>授权调试设备清单，应用ID。一个应用对应一个描述文件。</p>
<p>##28.类继承，类的扩展（extension），类别（category）</p>
<p>category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。<br>并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。<br>类别主要有3个作用：</p>
<p>(1)将类的实现分散到多个不同文件或多个不同框架中。</p>
<p>(2)创建对私有方法的前向引用。</p>
<p>(3)向对象添加非正式协议。</p>
<p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>
<p>category和extensions的不同在于后者可以添加属性。另外后者添加的方法是必须要实现的。<br>extensions可以认为是一个私有的Category。</p>
<p>##29.CAlayer介绍</p>
<p>一个UIView包含CALayer树，CALayer是一个数据模型。包含了一些用来显示的对象，在UIView的子类中都可以找到层这个组件，层是位于固定的画布上的一个子片，可以被覆盖。层是彼此堆叠在一起的最终产生一个界面。除此之层可以包含多个层，通过层可以操作位于此层上面的其他内容，例如旋转，动画，翻页等。</p>
<p>##30.ios 怎么实现多继承</p>
<p>IOS通过实现protocol委托代理，实现多个接口来实现多继承。</p>
<p>##31.app性能测试方式</p>
<p>通过Xcode提供的工具如Instrument，测试CPU，Mermory性能。也可以适用一些开源的自动化测试工具：如Frank，KIF等。</p>
<p>##32.NSArray可以放基本数据类型不（int，float，nil）怎么放进一个结构体</p>
<p>NSArray 只能存放objective－c对象数据模型，这些基本数据类型需要先转化为NSNumber对象再存放进数组中。</p>
<p>##33.objective-c和c，c++混合编写</p>
<p>在 Objective-C++中，可以用C++代码调用方法也可以从Objective-C调用方法。在这两种语言里对象都是指针，可以在任何地方使用。例 如，C++类可以使用Objective-C对象的指针作为数据成员，Objective-C类也可以有C++对象指针做实例变量。Xcode需要源文件以”.mm”为扩展名，这样才能启动编译器的Objective-C++扩展。</p>
<p>##34.常见的语言编码(utf-8,unicode,gb2312,gbk)</p>
<p>常见的语言编码有：</p>
<p>GB2312:简体中文编码，一个汉字占用2字节，在大陆是主要编码方式。</p>
<p>BIG5:繁体中文编码。主要在台湾地区采用。 </p>
<p>GBK:支持简体及繁体中文，但对他国非拉丁字母语言还是有问题。 </p>
<p>UTF-8:Unicode编码的一种。Unicode用一些基本的保留字符制定了三套编码方式，它们分别UTF-8,UTF-16和UTF-32。在UTF－8中，字符是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分。UTF-8俗称“万国码”，可以同屏显示多语种，一个汉字占用3字节。为了做到国际化，网页应尽可能采用UTF-8编码。</p>
<p>当然，处理中文时http头也要改成UTF-8编码的—–加上<meta http-equiv="Content-Type" content="text/html; charset=utf-8">。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>字符集</th>
<th>正式名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>英语、西欧语</td>
<td>ASCII，ISO-8859-1</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>简体中文</td>
<td>GB2312</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>繁体中文</td>
<td>BIG5</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>简繁中文</td>
<td>GBK</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>中文、日文及朝鲜语</td>
<td>GB18030</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>各国语言</td>
<td>UNICODE，UCS</td>
<td>DBCS宽字节</td>
</tr>
</tbody>
</table>
<p>##35.常见的加解密方式(rsa,aes,md5)</p>
<p>常见的加解密方式有：</p>
<p>RSA：基于公钥和私钥的非对程加密算法。适用范围广。</p>
<p>AES：是一种对程加密的流行方式。加密涉及矩阵运算。</p>
<p>MD5:将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，</p>
<p>##36.objective－c语言的优缺点</p>
<p>objc优点：</p>
<p>1) Cateogies</p>
<p>2) Posing</p>
<p>3) 动态识别</p>
<p>4) 指标计算</p>
<p>5）弹性讯息传递</p>
<p>6) 不是一个过度复杂的 C 衍生语言</p>
<p>7) Objective-C 与 C++ 可混合编程</p>
<p>缺点:<br>1) 不支援命名空間</p>
<p>2) 不支持运算符重载</p>
<p>3）不支持多重继承</p>
<p>4）使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。</p>
<p>##37，ios应用的调试技巧</p>
<p>1.如遇到crash，分析崩溃日志（symbolicatedrash工具的适用）保留崩溃版本的.dSYM文件</p>
<p>2.在 XCode 中进入断点管理窗口；然后点击右下方的 +，增加新的 Exception Breakpoint。</p>
<p>3.如遇到EXC_BAD_ACCESS，打开Scheme选项选择EditScheme。然后按图勾上Enable Zombie Objects和Malloc Stack那两项。</p>
<p>4.有效的日志管理。NSLog和加入一些开源的日志管理框架。</p>
<p>5.程序断点debug模式。</p>
<p>##38，应用程序性能的调优（转<a href="http://www.open-open.com/lib/view/open1365861753734.html）" target="_blank" rel="external">http://www.open-open.com/lib/view/open1365861753734.html）</a></p>
<ol>
<li><p>用ARC去管理内存（Use ARC to Manage Memory）</p>
<p>2.适当的地方使用reuseIdentifier（Use a reuseIdentifier Where Appropriate）</p>
<p>3.尽可能设置视图为不透明（Set View as Opaque When Possible）</p>
<p>4.避免臃肿的XIBs文件（Avoid Fat XiBs）</p>
<p>5.不要阻塞主进程（Don’t Block the Main Thread）</p>
<p>6.调整图像视图中的图像尺寸（Size Images to Image Views）</p>
<p>7.选择正确集合（Choose the Correct Collection）</p>
<p>8.启用Gzip压缩（Enable GZIP Compression）</p>
</li>
<li><p>重用和延迟加载视图（Reuse and Lazy Load Views）</p>
<p>10.缓存，缓存，缓存（Cache,Cache,Cache）</p>
<p>11.考虑绘图（Consider Drawing）</p>
<p>12.处理内存警告（Handle Memory Warnings）</p>
<p>13.重用大开销对象（Reuse Expensive Objects）</p>
<p>14.使用精灵表（Use Sprite Sheets ）</p>
<p>15.避免重复处理数据（Avoid Re-Processing Data）</p>
<p>16.选择正确的数据格式（Choose the Right Data Format）</p>
<p>17.适当的设置背景图片（Set  Background Images Appropriately）</p>
<p>18.减少你的网络占用（Reduce Your Web Footprint）  </p>
<p>19.设置阴影路径（Set the Shadow Path ）</p>
<p>20.你的表格视图Optimize Your Table Views）</p>
<p>21.选择正确的数据存储方式（Choose Correct Data Storage Option）</p>
<p>22.加速启动时间（Speed up Launch Time ）</p>
<p>23.使用自动释放池（Use AutoRelease Pool）</p>
<p>24.缓存图像（Cache Images-Or not ）</p>
<p>25.尽可能避免日期格式化器（Avoid Date Formatters Where Possible）</p>
</li>
</ol>
<p>##39.UIScrollView 的contentSize、contentOffSet和contentInset属性的区别</p>
<p>contentSize表示UIScrollView滚动区域的大小。UIScrollView的frame属性在设置好了以后不会随内容的变化而变化。</p>
<p>contentOffSet表示是UIScrollView当前显示区域顶点相对于frame顶点的偏移量，一般用来设置UIScrollView显示的位置。</p>
<p>contentInset表示是scrollview的contentView的顶点相对于scrollview的位置，假设你的contentInset = (0 ,100)，那么你的contentView就是从scrollview的(0 ,100)开始显示。一般都是（0，0）表示从scrollView的开始显示。</p>
<p>##40.IOS6 AutoLayout</p>
<p>AutoLayout是IOS6之后引进的自动布局功能，有点类型有android的相对布局属性。通过勾选AutoLayout设置各种Constraint约束来实现在不同设备和不同方向上的自动布局。autosizing mask也就是 “springs and struts” 模式。autosizing mask决定了一个view会发生什么当它的superview 改变大小的时候。而autolayout 不仅可以设置superview改变时view所做的变化，还支持当相邻view变化时自己所做的变化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/14/ios8-uipopoverpresentationcontroller-on-ios-8/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/14/ios8-uipopoverpresentationcontroller-on-ios-8/" itemprop="url">
                  [iOS]UIPopoverPresentationController on iOS 8
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-14T14:01:02+08:00">
              2014-10-14
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/14/ios8-uipopoverpresentationcontroller-on-ios-8/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/14/ios8-uipopoverpresentationcontroller-on-ios-8/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>In Tumblr for iOS, we have a view controller that gets presented differently on iPhone and on iPad:</p>
<pre><code>1. iPhone: Modally, as the child of a custom container view controller, presented with a custom animation controller
2. iPad: In a popover
</code></pre><p>I’m in the process of trying to implement this same behavior using the new UIPresentationController classes introduced in iOS 8, and seem to have already hit an unfortunate limitation.<br>It’s easy to get the popover showing up correctly on iPad, with just the following code:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">presentedController.modalPresentationStyle = <span class="built_in">UIModalPresentationPopover</span>;</div><div class="line">presentedController.popoverPresentationController.permittedArrowDirections = <span class="built_in">UIPopoverArrowDirectionUp</span>;</div><div class="line">presentedController.popoverPresentationController.sourceRect = button.bounds;</div><div class="line">presentedController.popoverPresentationController.sourceView = button;</div><div class="line">presentedController.popoverPresentationController.delegate = <span class="keyword">self</span>;</div><div class="line">[<span class="keyword">self</span> presentViewController:presentedController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>On iPhone, this same controller will be presented modally, but first we need to wrap it in a custom container view controller. To do this, we implement a couple of methods on the UIPopoverPresentationControllerDelegate protocol:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIModalPresentationStyle</span>)adaptivePresentationStyleForPresentationController:(<span class="built_in">UIPresentationController</span> *)controller &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UIModalPresentationOverFullScreen</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">UIViewController</span> *)presentationController:(<span class="built_in">UIPresentationController</span> *)presentationController viewControllerForAdaptivePresentationStyle:(<span class="built_in">UIModalPresentationStyle</span>)style &#123;</div><div class="line">    <span class="keyword">return</span> [[CustomContainerController alloc] initWithRootViewController:presentationController.presentedViewController];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Simple enough so far.<br>A “dimming view” is faded in as the view controller transitions on screen. The end result looks something like this:</p>
<p><img src="/uploads/2014/10/14/1.png" class="center"><br></p>
<p>The custom container controller is animated on screen using a custom animation controller conforming to <code>UIViewControllerAnimatedTransitioning</code>. In iOS 7, this animation controller was also responsible for showing the dimming view.<br>As of iOS 8, adding the dimming view to the view hierarchy and modifying its opacity should no longer be the responsibility of the animation controller. Instead, a custom <code>UIPresentationController</code> subclass should take care of this. The same <code>UIViewControllerTransitioningDelegate</code> that vends our custom animation controller can also vend a custom presentation controller, providing for a cleaner separation of concerns.</p>
<p>转自: <a href="http://cocoa.tumblr.com/post/92070238973/how-can-i-use-both-uipopoverpresentationcontroller-and" target="_blank" rel="external">http://cocoa.tumblr.com/post/92070238973/how-can-i-use-both-uipopoverpresentationcontroller-and</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/12/ios-something-about-objective-c-blocks/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/12/ios-something-about-objective-c-blocks/" itemprop="url">
                  [iOS] Something about Objective-C Blocks (Editing)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-12T14:56:51+08:00">
              2014-10-12
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/12/ios-something-about-objective-c-blocks/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/12/ios-something-about-objective-c-blocks/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Block基础知识"><a href="#1-Block基础知识" class="headerlink" title="1. Block基础知识"></a>1. Block基础知识</h2><h3 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">^(<span class="keyword">int</span> event)&#123;</div><div class="line">	printf(<span class="string">"print something"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即<code>^ 返回值 参数列表 表达式</code>，其中返回值可省略。</p>
<h3 id="1-2-有关Blocks自动变量"><a href="#1-2-有关Blocks自动变量" class="headerlink" title="1.2 有关Blocks自动变量"></a>1.2 有关Blocks自动变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> val = <span class="number">0</span>;</div><div class="line">   <span class="keyword">void</span> (^blk)() = ^&#123; val = <span class="number">1</span>;&#125;;</div><div class="line">   blk();</div><div class="line">   printf(<span class="string">"val = %d\n"</span>, val);</div></pre></td></tr></table></figure>
<p>若想再Block语法的表达式中将值复给在Block语法外声明的自动变量，需要在该自动变量上附加<code>__block</code>说明符。</p>
<h3 id="1-3-函数指针与Block对比"><a href="#1-3-函数指针与Block对比" class="headerlink" title="1.3 函数指针与Block对比"></a>1.3 函数指针与Block对比</h3><p>函数指针定义：<code>int func (int count)( return count +1) ;  int (*funcptr)(int) = &amp;func;</code><br><br>函数指针使用：<code>int result = (*funcptr)(10);</code><br><br>Blocks定义：<code>int (^blk)(int) = ^(int count){return count+1;};</code><br><br>Blocks使用：<code>int result = blk(10);</code><br></p>
<h3 id="1-4-Block的实质"><a href="#1-4-Block的实质" class="headerlink" title="1.4 Block的实质"></a>1.4 Block的实质</h3><p>Block实际上是作为极普通的C语言源代码来处理的。通过支持Block的编译器，含有Block语法的源代码转换为一般的C语言编译器能够处理的源代码，并作为极为普通的C语言源代码被编译。运用Clang，通过<code>-rewrite-objc</code> 选项就能将含有Block语法的源代码变换为C++源代码（struct结构）。<br><code>clang -rewrite-objc 源代码文件名</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">void</span> (^blk)() = ^&#123;printf(<span class="string">"Block!\n"</span>);&#125;;</div><div class="line">	blk();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转化以后为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用来描述block的数据结构</span></div><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">  <span class="keyword">void</span> *isa;	<span class="comment">//此处可以看出block被当做一个object来处理</span></div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;</div><div class="line">  <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//函数具体的数据结构描述</span></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//此处是block的具体实现，参数就是用来描述block的数据结构指针</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Block!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用来描述block的数据结构</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//先声明了一个指向描述block的数据结构，参数分别是调用的函数具体实现以及描述数据结构</span></div><div class="line"> 	<span class="keyword">void</span> (*blk)() = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</div><div class="line"> 	<span class="comment">//获取到block的数据结构以后，直接访问前面设置的函数指针，调用静态函数，参数就是上面得到的block的数据结构</span></div><div class="line"> 	((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查了下runtime.h, <code>Class</code>即<code>struct objc_class*</code>的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<h3 id="1-5-Writable-Variables"><a href="#1-5-Writable-Variables" class="headerlink" title="1.5 Writable Variables"></a>1.5 Writable Variables</h3><p>用<code>__block</code>在block外部声明block内部使用的变量，全名叫<code>__block storage-class-specifier</code>。C语言中的<code>storage-class-specifier</code>还有<code>typedef</code>,<code>extern</code>,<code>static</code>,<code>auto</code>,<code>register</code>。例如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;val = <span class="number">1</span>;&#125;;</div></pre></td></tr></table></figure>
<p>转化以后的代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个数据结构用来保存变量的，__forwarding指向自己的指针</span></div><div class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</div><div class="line">  <span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_val_0 *__forwarding;</div><div class="line"> <span class="keyword">int</span> __flags;</div><div class="line"> <span class="keyword">int</span> __size;</div><div class="line"> <span class="keyword">int</span> val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这个就是block的数据结构</span></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></div><div class="line">(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</div><div class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"> __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</div><div class="line"> <span class="keyword">void</span> (*blk)() = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>);</div><div class="line"> ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/11/core-animation/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/11/core-animation/" itemprop="url">
                  [iOS] Something about Core Animation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-11T16:01:25+08:00">
              2014-10-11
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/11/core-animation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/11/core-animation/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##1. Implicit and explicit Animation</p>
<p>Implicit Animation:<code>￼theLayer.opacity = 0.0;</code><br>Explicit Animation:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CABasicAnimation</span>* fadeAnim = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"opacity"</span>];</div><div class="line">fadeAnim.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>];</div><div class="line">fadeAnim.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.0</span>];</div><div class="line">fadeAnim.duration = <span class="number">1.0</span>;</div><div class="line">[theLayer addAnimation:fadeAnim forKey:<span class="string">@"opacity"</span>];</div><div class="line"><span class="comment">// Change the actual data value in the layer to the final value.</span></div><div class="line">theLayer.opacity = <span class="number">0.0</span>;</div></pre></td></tr></table></figure>
<p>Unlike an implicit animation, which updates the layer object’s data value, an explicit animation does not modify the data in the layer tree. Explicit animations only produce the animations. At the end of the animation, Core Animation removes the animation object from the layer and redraws the layer using its current data values. If you want the changes from an explicit animation to be permanent, you must also update the layer’s property as shown in the preceding example.</p>
<p>##2. Anchor Point</p>
<p><img src="/uploads/2014/10/11/1.png" class="center"><br><br><img src="/uploads/2014/10/11/2.png" class="center"><br></p>
<p>Rotation:<br><img src="/uploads/2014/10/11/3.png" class="center"><br></p>
<p>##3. Layer Trees<br>An app using Core Animation has three sets of layer objects. Each set of layer objects has a different role in making the content of your app appear onscreen:</p>
<ol>
<li>Objects in the <b>model layer tree</b> (or simply “layer tree”) are the ones your app interacts with the most. </li>
<li>Objects in the <b>presentation tree</b> contain the in-flight values for any running animations. </li>
<li>Objects in the <b>render tree</b> perform the actual animations and are private to Core Animation.</li>
</ol>
<p><img src="/uploads/2014/10/11/4.png" class="center"><br><br><img src="/uploads/2014/10/11/5.png" class="center"><br></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/06/c-plus-plus-cookbook/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/06/c-plus-plus-cookbook/" itemprop="url">
                  C++ CookBook读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-06T11:25:17+08:00">
              2014-10-06
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/06/c-plus-plus-cookbook/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/06/c-plus-plus-cookbook/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>C++创建静态库</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">g++ -c -o john.o john.cpp</div><div class="line">g++ -c -o paul.o paul.cpp</div><div class="line">g++ -c -o johnpaul.o johnpaul.cpp</div><div class="line">ar ru libjohnpaul.a john.o paul.o johnpaul.o</div><div class="line">ranlib libjohnpaul.a</div></pre></td></tr></table></figure>
<ol>
<li>使用预定义宏进行条件编译</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></div><div class="line"><span class="meta">#	<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span>	\\ not windows</span></div><div class="line"><span class="meta">#	<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<ol>
<li>使源文件自动链接到指定的库</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOHNPAUL_HPP_INCLUDED</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> JOHNPAUL_HPP_INCLUDED</span></div><div class="line"><span class="meta">#prama comment(lib, <span class="meta-string">"libjohnpaul"</span>)	<span class="comment">// 静态库</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<ol>
<li>包含一个内联文件</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VALUE_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUE_H_</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Value</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Value(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; val): val_(val)&#123;&#125;</div><div class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getVal</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> val_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Value.inl"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// Value.inl</span></div><div class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> Value::getVal() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (val_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/04/template-class-symbols-not-found/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/04/template-class-symbols-not-found/" itemprop="url">
                  Template Class - Symbols not found
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-04T10:03:51+08:00">
              2014-10-04
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/04/template-class-symbols-not-found/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/04/template-class-symbols-not-found/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Detailed Explanation available from <a href="http://www.parashift.com/c++-faq-lite/templates.html" target="_blank" rel="external">http://www.parashift.com/c++-faq-lite/templates.html</a></p>
<p>[35.12] Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file?</p>
<p>If all you want to know is how to fix this situation, read the next two FAQs. But in order to understand why things are the way they are, first accept these facts:</p>
<p>A template is not a class or a function. A template is a “pattern” that the compiler uses to generate a family of classes or functions.<br>In order for the compiler to generate the code, it must see both the template definition (not just declaration) and the specific types/whatever used to “fill in” the template. For example, if you’re trying to use a Foo, the compiler must see both the Foo template and the fact that you’re trying to make a specific Foo.<br>Your compiler probably doesn’t remember the details of one .cpp file while it is compiling another .cpp file. It could, but most do not and if you are reading this FAQ, it almost definitely does not. BTW this is called the “separate compilation model.”<br>Now based on those facts, here’s an example that shows why things are the way they are. Suppose you have a template Foo defined like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </div><div class="line"><span class="keyword">class</span> Foo &#123; </div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Foo();</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(T x)</span></span>;  </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T x;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Along with similar definitions for the member functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Foo&lt;T&gt;::Foo()</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> Foo&lt;T&gt;::someMethod(T x)</div><div class="line">&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now suppose you have some code in file Bar.cpp that uses Foo:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Bar.cpp</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">blah_blah_blah</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	Foo&lt;<span class="keyword">int</span>&gt; f;</div><div class="line">	f.someMethod(<span class="number">5</span>);</div><div class="line">	...</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Clearly somebody somewhere is going to have to use the “pattern” for the constructor definition and for the someMethod() definition and instantiate those when T is actually int. But if you had put the definition of the constructor and someMethod() into file Foo.cpp, the compiler would see the template code when it compiled Foo.cpp and it would see Foo when it compiled Bar.cpp, but there would never be a time when it saw both the template code and Foo. So by rule #2 above, it could never generate the code for Foo::someMethod().</p>
<p>A note to the experts: I have obviously made several simplifications above. This was intentional so please don’t complain too loudly. If you know the difference between a .cpp file and a compilation unit, the difference between a class template and a template class, and the fact that templates really aren’t just glorified macros, then don’t complain: this particular question/answer wasn’t aimed at you to begin with. I simplified things so newbies would “get it,” even if doing so offends some experts.</p>
<p>[35.13] How can I avoid linker errors with my template functions?</p>
<p>Tell your C++ compiler which instantiations to make while it is compiling your template function’s .cpp file.</p>
<p>As an example, consider the header file foo.h which contains the following template function declaration:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "foo.h"</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>Now suppose file foo.cpp actually defines that template function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "foo.cpp"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Here I am!\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Suppose file main.cpp uses this template function by calling foo():</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "main.cpp"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	foo&lt;<span class="keyword">int</span>&gt;();</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If you compile and (try to) link these two .cpp files, most compilers will generate linker errors. There are three solutions for this. The first solution is to physically move the definition of the template function into the .h file, even if it is not an inline function. This solution may (or may not!) cause significant code bloat, meaning your executable size may increase dramatically (or, if your compiler is smart enough, may not; try it and see).</p>
<p>The other solution is to leave the definition of the template function in the .cpp file and simply add the line template void foo(); to that file:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "foo.cpp"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Here I am!\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> <span class="keyword">void</span> foo&lt;<span class="keyword">int</span>&gt;();</div></pre></td></tr></table></figure>
<p>If you can’t modify foo.cpp, simply create a new .cpp file such as foo-impl.cpp as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "foo-impl.cpp"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.cpp"</span></span></div><div class="line"><span class="keyword">template</span> <span class="keyword">void</span> foo&lt;<span class="keyword">int</span>&gt;();</div></pre></td></tr></table></figure>
<p>Notice that foo-impl.cpp #includes a .cpp file, not a .h file.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar/avatar.jpg"
               alt="姜楠" />
          <p class="site-author-name" itemprop="name">姜楠</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">118</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/njiang1987" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姜楠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"njiang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
