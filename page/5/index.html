<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="天空の城">
<meta property="og:url" content="http://www.njiang.cn/page/5/index.html">
<meta property="og:site_name" content="天空の城">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天空の城">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.njiang.cn/page/5/"/>





  <title> 天空の城 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-43682645-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">天空の城</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">愤怒的程序员，梦想着有一天也能飞！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/22/ios-shen-ru-qian-chu-objczhi-xiao-xi/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/22/ios-shen-ru-qian-chu-objczhi-xiao-xi/" itemprop="url">
                  [iOS]深入浅出ObjC之消息
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-22T21:57:41+08:00">
              2014-10-22
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/22/ios-shen-ru-qian-chu-objczhi-xiao-xi/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/22/ios-shen-ru-qian-chu-objczhi-xiao-xi/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在入门级别的ObjC 教程中，我们常对从C++或Java 或其他面向对象语言转过来的程序员说，ObjC 中的方法调用（ObjC中的术语为消息）跟其他语言中的方法调用差不多，只是形式有些不同而已。<br>譬如Ｃ++ 中的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bird * aBird = <span class="keyword">new</span> Bird();</div><div class="line">aBird-&gt;fly();</div></pre></td></tr></table></figure>
<p>在ObjC 中则如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bird * aBird = [[Bird alloc] init];</div><div class="line">[aBird fly];</div></pre></td></tr></table></figure>
<p>初看起来，好像只是书写形式不同而已，实则差异大矣。Ｃ++中的方法调用可能是动态的，也可能是静态的；而ObjC中的消息都为动态的。下文将详细介绍为什么是动态的，以及编译器在这背后做了些什么事情。<br>要说清楚消息这个话题，我们必须先来了解三个概念Class, SEL, IMP，它们在objc/objc.h 中定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</div><div class="line">	Class isa;</div><div class="line">&#125; *id;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>;</div><div class="line"><span class="comment">///Class 的含义</span></div><div class="line"><span class="comment">///Class 被定义为一个指向 objc_class的结构体指针，这个结构体表示每一个类的类结构。而 objc_class 在objc/objc_class.h中定义如下:</span></div><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">	<span class="keyword">struct</span> objc_class super_class; <span class="comment">/*父类*/</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/*类名字*/</span></div><div class="line">	<span class="keyword">long</span> version; <span class="comment">/*版本信息*/</span></div><div class="line">	<span class="keyword">long</span> info; <span class="comment">/*类信息*/</span></div><div class="line">	<span class="keyword">long</span> instance_size; <span class="comment">/*实例大小*/</span></div><div class="line">	<span class="keyword">struct</span> objc_ivar_list *ivars; <span class="comment">/*实例参数链表*/</span></div><div class="line">	<span class="keyword">struct</span> objc_method_list **methodLists; <span class="comment">/*方法链表*/</span></div><div class="line">	<span class="keyword">struct</span> objc_cache *cache; <span class="comment">/*方法缓存*/</span></div><div class="line">	<span class="keyword">struct</span> objc_protocol_list *protocols; <span class="comment">/*协议链表*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由此可见，Class 是指向类结构体的指针，该类结构体含有一个指向其父类类结构的指针，该类方法的链表，该类方法的缓存以及其他必要信息。</p>
<p>NSObject 的class 方法就返回这样一个指向其类结构的指针。每一个类实例对象的第一个实例变量是一个指向该对象的类结构的指针，叫做isa。通过该指针，对象可以访问它对应的类以及相应的父类。如图一所示：</p>
<img src="/uploads/2014/10/22/1.gif" class="center">
<p>如图一所示，圆形所代表的实例对象的第一个实例变量为 isa，它指向该类的类结构 The object’s class。而该类结构有一个指向其父类类结构的指针superclass， 以及自身消息名称(selector)/实现地址(address)的方法链表。</p>
<p>##方法的含义：<br>注意这里所说的方法链表里面存储的是Method 类型的。图一中selector 就是指 Method的 SEL, address就是指Method的 IMP。 Method 在头文件 objc_class.h中定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ method &#123;</div><div class="line">SEL method_name;</div><div class="line"><span class="keyword">char</span> *method_types;</div><div class="line">IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个方法 Method，其包含一个方法选标 SEL – 表示该方法的名称，一个types – 表示该方法的参数，一个 IMP - 指向该方法的具体实现的函数指针。</p>
<p>##SEL 的含义：</p>
<p>在前面我们看到方法选标 SEL 的定义为：<br><code>typedef struct objc_selector *SEL;</code></p>
<p>它是一个指向 objc_selector 指针，表示方法的名字。如下所示，打印出 selector。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSInteger</span>)maxIn:(<span class="built_in">NSInteger</span>)a theOther:(<span class="built_in">NSInteger</span>)b</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> (a &gt; b) ? a : b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"SEL=%s"</span>, <span class="keyword">@selector</span>(maxIn:theOther:));</div></pre></td></tr></table></figure>
<p>输出：SEL=maxIn:theOther:</p>
<p>不同的类可以拥有相同的 selector，这个没有问题，因为不同类的实例对象performSelector相同的 selector 时，会在各自的消息选标(selector)/实现地址(address) 方法链表中根据 selector 去查找具体的方法实现IMP, 然后用这个方法实现去执行具体的实现代码。这是一个动态绑定的过程，在编译的时候，我们不知道最终会执行哪一些代码，只有在执行的时候，通过selector去查询，我们才能确定具体的执行代码。</p>
<p>##IMP 的含义：<br>在前面我们也看到 IMP 的定义为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...);</div></pre></td></tr></table></figure>
<p>根据前面id 的定义，我们知道 id是一个指向 objc_object 结构体的指针，该结构体只有一个成员isa，所以任何继承自 NSObject 的类对象都可以用id 来指代，因为 NSObject 的第一个成员实例就是isa。</p>
<p>至此，我们就很清楚地知道 IMP 的含义：IMP 是一个函数指针，这个被指向的函数包含一个接收消息的对象<br>id(self 指针), 调用方法的选标 SEL (方法名)，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码 。我们可以像在Ｃ语言里面一样使用这个函数指针。<br>NSObject 类中的methodForSelector：方法就是这样一个获取指向方法实现IMP 的指针，methodForSelector：返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型。<br>下面的例子展示了怎么使用指针来调用setFilled:的方法实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span>(*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</div><div class="line">	<span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<p>使用methodForSelector：来避免动态绑定将减少大部分消息的开销，但是这只有在指定的消息被重复发送很多次时才有意义，例如上面的for循环。<br>注意，methodForSelector：是Cocoa运行时系统的提供的功能，而不是Objective-C语言本身的功能。</p>
<p>##消息调用过程：<br>至此我们对ObjC 中的消息应该有个大致思路了：示例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bird * aBird = [[Bird alloc] init];</div><div class="line">[aBird fly];</div></pre></td></tr></table></figure>
<p>中对 fly 的调用，编译器通过插入一些代码，将之转换为对方法具体实现IMP的调用，这个 IMP是通过在 Bird 的类结构中的方法链表中查找名称为fly 的 选标SEL 对应的具体方法实现找到的。<br>上面的思路还有一些没有提及的话题，比如说编译器插入了什么代码，如果在方法链表中没有找到对应的 IMP又会如何，这些话题在下面展开。</p>
<p>##消息函数 obj_msgSend：<br>编译器会将消息转换为对消息函数 objc_msgSend的调用，该函数有两个主要的参数：消息接收者id 和消息对应的方法选标 SEL, 同时接收消息中的任意参数：<br>id objc_msgSend(id theReceiver, SELtheSelector, …)<br>如上面的消息 [aBird fly]会被转换为如下形式的函数调用：<br>objc_msgSend(aBird, @selector(fly));<br>该消息函数做了动态绑定所需要的一切工作：<br>1，它首先找到 SEL 对应的方法实现 IMP。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。<br>2，然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传递给方法实现 IMP。<br>3，最后，将方法实现的返回值作为该函数的返回值返回。</p>
<p>编译器会自动插入调用该消息函数objc_msgSend的代码，我们无须在代码中显示调用该消息函数。当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数：消息的接收者以及方法名称 SEL。这些参数帮助方法实现获得了消息表达式的信息。它们被认为是”隐藏“的是因为它们并没有在定义方法的源代码中声明，而是在代码编译时是插入方法的实现中的。</p>
<p>尽管这些参数没有被显示声明，但在源代码中仍然可以引用它们（就象可以引用消息接收者对象的实例变量一样）。在方法中可以通过self来引用消息接收者对象，通过选标_cmd来引用方法本身。在下面的例子中，_cmd 指的是strange方法，self指的收到strange消息的对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> target = getTheReceiver();</div><div class="line">	SEL method = getTheMethod();</div><div class="line">	<span class="keyword">if</span> (target == <span class="keyword">self</span> || mothod == _cmd)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">	<span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这两个参数中，self更有用一些。实际上，它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<p>##查找 IMP 的过程：</p>
<p>前面说了，objc_msgSend 会根据方法选标 SEL 在类结构的方法列表中查找方法实现IMP。这里头有一些文章，我们在前面的类结构中也看到有一个叫objc_cache *cache 的成员，这个缓存为提高效率而存在的。每个类都有一个独立的缓存，同时包括继承的方法和在该类中定义的方法。。<br>查找IMP 时：</p>
<ol>
<li>首先去该类的方法 cache 中查找，如果找到了就返回它；</li>
<li>如果没有找到，就去该类的方法列表中查找。如果在该类的方法列表中找到了，则将 IMP 返回，并将它加入cache中缓存起来。根据最近使用原则，这个方法再次调用的可能性很大，缓存起来可以节省下次调用再次查找的开销。</li>
<li>如果在该类的方法列表中没找到对应的 IMP，在通过该类结构中的 super_class指针在其父类结构的方法列表中去查找，直到在某个父类的方法列表中找到对应的IMP，返回它，并加入cache中。</li>
<li>如果在自身以及所有父类的方法列表中都没有找到对应的 IMP，则进入下文中要讲的消息转发流程。</li>
</ol>
<p>##便利函数：<br>我们可以通过NSObject的一些方法获取运行时信息或动态执行一些消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> 返回对象的类；</div><div class="line">isKindOfClass 和 isMemberOfClass检查对象是否在指定的类继承体系中；</div><div class="line">respondsToSelector 检查对象能否相应指定的消息；</div><div class="line">conformsToProtocol 检查对象是否实现了指定协议类的方法；</div><div class="line">methodForSelector 返回指定方法实现的地址。</div><div class="line">performSelector:withObject 执行SEL 所指代的方法。</div></pre></td></tr></table></figure>
<p>##消息转发：<br>通常，给一个对象发送它不能处理的消息会得到出错提示，然而，Objective-C运行时系统在抛出错误之前，会给消息接收对象发送一条特别的消息forwardInvocation 来通知该对象，该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。<br>我们可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<p>关于消息转发的作用，可以考虑如下情景：假设，我们需要设计一个能够响应negotiate消息的对象，并且能够包括其它类型的对象对消息的响应。 通过在negotiate方法的实现中将negotiate消息转发给其它的对象来很容易的达到这一目的。</p>
<p>更进一步，假设我们希望我们的对象和另外一个类的对象对negotiate的消息的响应完全一致。一种可能的方式就是让我们的类继承其它类的方法实现。 然后，有时候这种方式不可行，因为我们的类和其它类可能需要在不同的继承体系中响应negotiate消息。</p>
<p>虽然我们的类无法继承其它类的negotiate方法，但我们仍然可以提供一个方法实现，这个方法实现只是简单的将negotiate消息转发给其他类的对象，就好像从其它类那儿“借”来的现一样。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- negotiate</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> ([someOtherObject respondsToSelector:<span class="keyword">@selector</span>(negotiate)])</div><div class="line">		<span class="keyword">return</span> [someOtherObject negotiate];</div><div class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式显得有欠灵活，特别是有很多消息都希望传递给其它对象时，我们就必须为每一种消息提供方法实现。此外，这种方式不能处理未知的消息。当我们写下代码时，所有我们需要转发的消息的集合都必须确定。然而，实际上，这个集合会随着运行时事件的发生，新方法或者新类的定义而变化。</p>
<p><code>forwardInvocation:</code>消息给这个问题提供了一个更特别的，动态的解决方案：当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过forwardInvocation:消息通知该对象。每个对象都从NSObject类中继承了<code>forwardInvocation:</code>方法。然而，NSObject中的方法实现只是简单地调用了doesNotRecognizeSelector:。通过实现我们自己的<code>forwardInvocation:</code>方法，我们可以在该方法实现中将消息转发给其它对象。</p>
<p>要转发消息给其它对象，forwardInvocation:方法所必须做的有：</p>
<ol>
<li>决定将消息转发给谁，并且</li>
<li>将消息和原来的参数一块转发出去。</li>
</ol>
<p>消息可以通过invokeWithTarget:方法来转发：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> ([someOtherObject respondsToSelector:[anInvocation selector]])</div><div class="line">		[anInvocation invokeWithTarget:someOtherObject];</div><div class="line">	<span class="keyword">else</span></div><div class="line">		[<span class="keyword">super</span> forwardInvocation:anInvocation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转发消息后的返回值将返回给原来的消息发送者。您可以将返回任何类型的返回值，包括: id，结构体，浮点数等。</p>
<p><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。forwardInvocation:方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p>
<p>注意： <code>forwardInvocation:</code>方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将negotiate消息转发给其它对象，则这个对象不能有negotiate方法。否则，forwardInvocation:将不可能会被调用。</p>
<p>##参考资料：<br>Objective-CRuntime Reference:<br><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html" target="_blank" rel="external">http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html</a><br>Objective-C Runtime Programming Guide:<br><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></p>
<p>转自：<br>罗朝辉（<a href="http://blog.csdn.net/kesalin）" target="_blank" rel="external">http://blog.csdn.net/kesalin）</a><br><a href="http://hi.baidu.com/jt_one/blog/item/96f972cf411a7027f9dc61d8.html" target="_blank" rel="external">http://hi.baidu.com/jt_one/blog/item/96f972cf411a7027f9dc61d8.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/22/ios-iosmian-shi-wen-ti-zong-jie/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/22/ios-iosmian-shi-wen-ti-zong-jie/" itemprop="url">
                  [iOS]IOS面试问题总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-22T17:47:48+08:00">
              2014-10-22
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/22/ios-iosmian-shi-wen-ti-zong-jie/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/22/ios-iosmian-shi-wen-ti-zong-jie/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过网络搜寻和自己总结经历找了一些IOS面试经常被问道的问题：</p>
<p>##1.搞清楚touch事件的传递(事件的响应链)</p>
<p>事件的响应（responder chain）<br></p>
<p>只有继承了UIResponder的类才能响应touch事件，从上图的响应者链可以看出，优先是最上层的view响应事件，如果该view有视图控制器的话会是下一个响应者，否者就是该view的父视图，这样至上而下传递事件。直到单例UIWindow对象，最后是单例UIApplication对象以终止，UIApplication的下一个响应者是nil，已结束整个响应循环。事件在传递过程中视图可以决定是否需要对该事件进行响应。<br></p>
<p>事件分发（Event Delivery）<br></p>
<p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。整个响应者链和事件分发的使命都是找出第一响应者。</p>
<p>UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。</p>
<p>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。</p>
<p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果pointInside:withEvent:返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。<br>hitTest:withEvent:方法的处理流程如下:<br>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;<br>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</p>
<p>##2.fame，bounds，center，alpha,opaque,hidden</p>
<p>这些都是view的一些基本属性。frame是描述该view在其父视图中的一块区域。其坐标系是在其父视图中的坐标。我们在进行view的初始化时会经常使用到frame。bounds也是描述该view的大小，是其在自身的坐标系中的位置大小。center是描述其在父视图的中心位置坐标。我们在进行view的位置改变而不改变view的大小的时，会使用center。alpha是用来描述改view的透明度从0到1，0表示的是透明，1表示不透明。alpha支持动画（animation），alpha = 0 与 hidden ＝ YES 效果一样都是看不到view，但是后者相比开销大。在alpha等于0时view接受touch事件，但是hidden则不接受。并且hidden和apaque 不支持动画。alpha并不影响镶嵌在其内部view行为，而hidden会影响。当把view设置为透明背景时，一般把opaque设置为NO，可以减少开销，优化内存.opaque影响图形绘制系统。设置为YES，会优化view的绘制。</p>
<p>##3，nil,NSNULL,NULL区别</p>
<p>nil是指向obj－c中对象的空指针，是一个对象，在o－c中ni对象调用方法不会引起crash。</p>
<p>Nil是指向obj－c中的类的空指针，表示的是一个空类。</p>
<p>NULL是指向任何类型的空指针（如c／c++中的空指针），在objective－c中是一个数值。</p>
<p>NSNULL用于集合操作，在集合对象中，表示一个空值的集合对象。</p>
<p>##4.KVC and KVO</p>
<p>KVC（key－value－coding）键值编码，是一种间接操作对象属性的一种机制，可以给属性设置值。通过setValue：forKey：和valueForKey，实现对属性的存取和访问。</p>
<p>KVO（key－value－observing）键值观察，是一种使用观察者模式来观察属性的变化以便通知注册的观察者。通过注册observing对象addObserver:forKeyPath:options:context:和观察者类必须重写方法 observeValueForKeyPath:ofObject:change:context:。常应用MVC模型中，数据库（dataModal）发生变化时，引起view改变。</p>
<p>##5.NSThread,NSOperation,GCD</p>
<p>NSThread,NSOperation,GCD是IOS中使用多线程的三种方式之一。他们各有优缺点。抽象层次是从低到高的，抽象度越高的使用越简单。</p>
<p>NSThread，缺点：需要自己维护线程的生命周期和线程的同步和互斥，但是这些都需要耗费系统的资源。优点：比其它两个更轻。</p>
<p>NSOperation,优点：不需要自己管理线程的生命周期和线程的同步和互斥等。只是需要关注自己的业务逻辑处理，需要和NSOperationQueue一起使用。</p>
<p>GCD，是Apple开发的一个多核编程解决方法，优点：比前面两者更高效更强大。</p>
<p>##6.autorelease ,ARC 和非ARC</p>
<p>autorelease 自动释放，与之相关联的是一个自动释放池（NSAutoReleasePool）.autorelease的变量会被放入自动释放池中。等到自动释放池释放时（drain）时，自动释放池中的自动释放变量会随之释放。ios系统应用程序在创建是有一个默认的NSAutoReleasePool，程序退出时会被销毁。但是对于每一个RunLoop，系统会隐含创建一个AutoReleasePool，所有的release pool会构成一个栈式结构，每一个RunLoop结束，当前栈顶的pool会被销毁。</p>
<p>ARC，自动应用计数。（iOS 6加入）IOS内存管理是基于变量的应用计数的。这样系统帮你管理变量的release，retain等操作。</p>
<p>非ARC，非自动应用计数。手动管理内存。自己负责系统变量的release，retain等操作。做到谁分配谁释放，及alloc和release像对应。函数返回对象时使用autorelease。</p>
<p>可以使用Xcode将非ARC转化为ARC，ARC和非ARC混编。可在在编译ARC时使用－fno－objc－arc，-fobjc-arc标签。实际需要看工程是支持还是不支持ARC模式。</p>
<p>##7.xib，storyboard，手动书写代码</p>
<p>xib（interface buider）,方便对界面进行编辑。可以在窗口上面直接添加各种视图，优点：直接看到界面的效果，操作简单。缺点：不方便对视图进行动态控制，不灵活。</p>
<p>手动编写代码，继承（主要是UIView，UIViewController），优点：可以对视图进行定制，灵活控制方便。缺点：不能马上看到效果，复杂。</p>
<p>storyboard（故事板在ios6加入）。优点：可以看到界面效果，能同时进行多个界面的交互，高效快速。缺点：不能进行进行界面的定制，却笑灵活性。</p>
<p>xib和storyboard主要用于界面中的元素位置固定和清楚里面有哪些元素。但是如果需要动态变化界面还是手动编写代码比较好。一般还是各种方式混合使用。</p>
<p>##8.loadView,viewDidLoad,ViewDidUnload,viewWillAppear,viewDidAppear,viewwilldDisappear,viewDidDisappear</p>
<p>当view的nib文件为nil时，手动创建界面时调用loadView，当view的nib文件存在时，会在viewDidLoad中实现。但是当你的程序运行期间内存不足时，视图控制器收到didReceiveMemoryWarning时，系统会检查当前的视图控制器的view是否还在使用，如果不在，这个view会被release，再次调用loadView来创建一个新的View。viewDidLoad ,不论是从xib中加载视图，还是从loadview生成视图，都会被调用。但是如果改view在栈中下一次显示是不会被调用。ViewWillAppear，ViewDidAppear会在view每次即将可见和完全显示时都会调用。我们会在ViewWillAppear里面进行一些view显示的准备工作，ViewDidDi sappear 和ViewWillDisAppear时会在view每次消失时都会调用。当系统收到didReceiveMemoryWarning通知时显示内存不足时，会调用ViewDidUnload来清理View中的数据和release后置为nil。</p>
<p>##9，copy 和retain区别</p>
<p>retain,相当于指针拷贝。变量的引用计数加一。另外一个指针也指向改地址。</p>
<p>copy，相当于内容拷贝。变量的引用计数加一。但是自己本身计数不变。开辟另外一个地址空间放入相同变量的值进去。</p>
<p>##10，手动写setter和getter方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) setOldValue: (<span class="built_in">NSString</span>*) newValue </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (newValue !=oldValue) &#123;</div><div class="line">        [oldValue release];</div><div class="line">        oldValue = [newValue <span class="keyword">retain</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##11，NSRunLoop 和NSOperationQueue</p>
<p>NSRunLoop 是所有要监视的输入源和定时源以及要通知的注册观察者的集合.用来处理诸如鼠标，键盘事件等的输入源。每一个线程拥有自己的RunLoop有系统自动创建。你不应该自己去创建，只能获取。一般不会用NSRunLoop,因为它不是线程安全的。一般都用CFRunLoop，这个是线程安全的，是一种消息处理模式，我们一般不用进行处理。</p>
<p>NSOperationQueue时一个管理NSOperation的队列。我们会把NSOperation放入queue中进行管理。</p>
<p>##12,IOS常用的设计模式</p>
<p>单例模式，DeafutCenter,Deafultqueue等</p>
<p>MVC模式，View，model,ViewController。</p>
<p>观察者模式，通知，KVO</p>
<p>工厂模式，</p>
<p>代理模式，delegate</p>
<p>##13.内存管理和优化</p>
<p>原则：</p>
<p>1.1    谁创建，谁释放（类似于“谁污染，谁治理”）。如果你通过alloc、new或copy来创建一个对象，那么你必须调用release或autorelease。换句话说，不是你创建的，就不用你去释放。<br>例如，你在一个函数中alloc生成了一个对象，且这个对象只在这个函数中被使用，那么你必须在这个函数中调用release或autorelease。如果你在一个class的某个方法中alloc一个成员对象，且没有调用autorelease，那么你需要在这个类的dealloc方法中调用release；如果调用了autorelease，那么在dealloc方法中什么都不需要做。<br>1.2  除了alloc、new或copy之外的方法创建的对象都被声明了autorelease。<br>1.3  谁retain，谁release。只要你调用了retain，无论这个对象是如何生成的，你都要调用release。有时候你的代码中明明没有retain，可是系统会在默认实现中加入retain。</p>
<p>优化：</p>
<p>在收到内存didReceiveMemoryWarning的警告时，释放掉一些不再需要的资源，注意编码规范，如一些变量不使用需要及时的释放。避免是占用太多的内存空间，有时需要用空间去换取时间，尽量使用一些高效的算法和数据结构节约内存空间。最后使用一些内存检测工具和代码的静态分析查找内存泄漏和分配（instrument，leaks，allocations）。</p>
<p>##14，tableview的优化</p>
<p>优化：</p>
<p>1.1 正确的复用cell。</p>
<p>1.2 减少在返回每个cell里面的处理逻辑和处理时间。尽量将数据进行缓存和复用。</p>
<p>1.3，尽量减少处理加载和计算的时间，不阻塞UI线程。</p>
<p>1.4，尽量使用绘制每个cell。</p>
<p>1.5，设置每个cell的opaque属性。</p>
<p>1.6，尽量返回每行固定的height。</p>
<p>1.7，在每个cell减少图形效果。</p>
<p>1.8，分段加载数据。</p>
<p>##15，opengl，quatarz 2d</p>
<p>上面2种方式是进行图形绘制会使用到的技术。</p>
<p>quatarz 2d 是Apple提供的基于Core graphic的绘制基本图形工具库。操作简单方便，能够满足大部分需要。只是适用于2D图形的绘制。</p>
<p>opengl，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。功能强大但是复杂。</p>
<p>##16, animation</p>
<p>IOS提供丰富的Core Animation动画满足用户的需要，主要实现方式如下3种：</p>
<p>1.1  commitAnimations方式使用UIView动画</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> Animations 动画: </div><div class="line">[<span class="built_in">UIView</span> beginAnimations:<span class="string">@"animationID"</span> context:<span class="literal">nil</span>]; </div><div class="line">[<span class="built_in">UIView</span> setAnimationDuration:<span class="number">0.5</span>f]; </div><div class="line">[<span class="built_in">UIView</span> setAnimationCurve:<span class="built_in">UIViewAnimationCurveEaseInOut</span>]; </div><div class="line">[<span class="built_in">UIView</span> setAnimationRepeatAutoreverses:<span class="literal">NO</span>]; </div><div class="line"><span class="comment">//以下四种效果 </span></div><div class="line"><span class="comment">/* </span></div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:self.view cache:YES];//oglFlip, fromLeft </div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.view cache:YES];//oglFlip, fromRight  </div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionCurlUp forView:self.view cache:YES]; </div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionCurlDown forView:self.view cache:YES]; </div><div class="line">*/ </div><div class="line"><span class="comment">//你自己的操作</span></div><div class="line">[<span class="built_in">UIView</span> commitAnimations];</div></pre></td></tr></table></figure>
<p>1.2、CATransition</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CATransition</span> *animation = [<span class="built_in">CATransitionanimation</span>];</div><div class="line">animation.duration = <span class="number">0.5</span>f;</div><div class="line">animation.timingFunction =<span class="built_in">UIViewAnimationCurveEaseInOut</span>;</div><div class="line">animation.fillMode = kCAFillModeForwards;</div><div class="line">animation.type = kCATransitionMoveIn;</div><div class="line">animation.subtype = kCATransitionFromTop;</div><div class="line">[<span class="keyword">self</span>.window.layeraddAnimation:animationforKey:<span class="string">@"animation"</span>];</div></pre></td></tr></table></figure>
<p>///自己的操作<br>1.3、UIView animateWithDuration</p>
<p>方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">void</span>)animateWithDuration:(<span class="built_in">NSTimeInterval</span>)duration animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations; </div><div class="line">+ (<span class="keyword">void</span>)animateWithDuration:(<span class="built_in">NSTimeInterval</span>)duration animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion; <span class="comment">//多一个动画结束后可以执行的操作. </span></div><div class="line"></div><div class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.25</span> animations:^&#123; </div><div class="line"><span class="built_in">CGAffineTransform</span> newTransform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.2</span>, <span class="number">1.2</span>); </div><div class="line">[firstImageView setTransform:newTransform]; </div><div class="line">[secondImageView setTransform:newTransform];&#125; </div><div class="line">completion:^(<span class="built_in">BOOL</span> finished)&#123; </div><div class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.2</span> animations:^&#123; </div><div class="line">／／自己的操作&#125; completion:^(<span class="built_in">BOOL</span> finished)&#123; 自己的操作&#125;]; </div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>##17,定制化view </p>
<p>需要自己自己继承自cocoa touch提供的丰富的类。如（UIView，UiScrollView，UITableView等等）。需要重载实现drawRect，touch事件，init，initFrame等方法。</p>
<p>##18.core Data,sqlite,file，NSUserDefaults</p>
<p>上面四种是IOS中数据存取的方式。</p>
<p>Core Data，sqlite涉及到数据库。sqlite需要通过sqlite语句操作数据库，而core data是Apple提供的一个基于sqlite更抽象成对象的一种对数据库操作方式。</p>
<p>file，主要是把数据存储在磁盘中。通过写和读文件操作。</p>
<p>NSUserDefaults，主要是存储应用程序中的一些轻量级数据如应用程序的设置和属性和用户信息等。</p>
<p>##19.机型和尺寸的适配</p>
<p>Iphone 的主要尺寸是3.5和4英寸。分辨率为：320<em>480,480</em>960（retina）。</p>
<p>IPad 主要尺寸是7.9和9.7英寸。分辨率为：1024<em>768，2048</em>1536（retina）。</p>
<p>##20.添加手势的方式（gesture和touches事件）</p>
<ol>
<li><p>自己重载实现touchMoved，touchBegin，touchEnd，touchCanceled事件。</p>
</li>
<li><p>通过UIGestureRecongnizer添加AddGestureRecognier事件。该方式方便添加一些诸如点击，双击，拖动等基本的手势事件。</p>
</li>
</ol>
<p>##21.应用程序的生命周期和状态<br>(参照：<a href="http://blog.csdn.net/totogo2010/article/details/8048652）" target="_blank" rel="external">http://blog.csdn.net/totogo2010/article/details/8048652）</a></p>
<ol>
<li><p>Not running  未运行  程序没启动</p>
</li>
<li><p>Inactive          未激活        程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态</p>
</li>
<li><p>Active             激活           程序在前台运行而且接收到了事件。这也是前台的一个正常的模式</p>
</li>
<li><p>Backgroud     后台           程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态</p>
</li>
<li><p>Suspended    挂起           程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。<br>下图是程序状态变化图：</p>
</li>
</ol>
<p>各个程序运行状态时代理的回调：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">      告诉代理进程启动但还没进入状态保存</div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">     告诉代理启动基本完成程序准备开始运行</div><div class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application</div><div class="line">    当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</div><div class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application </div><div class="line">     当应用程序入活动状态执行，这个刚好跟上面那个方法相反</div><div class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</div><div class="line">    当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</div><div class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application</div><div class="line">当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</div><div class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application</div><div class="line">当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要要设置<span class="built_in">UIApplicationExitsOnSuspend</span>的键值。</div><div class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">UIApplication</span>*)application</div><div class="line">当程序载入后执行</div></pre></td></tr></table></figure>
<p>加载应用程序进入前台</p>
<p>加载应用程序进入后台</p>
<p>##22.block编程</p>
<p>Block 是一种具有匿名功能的内嵌函数块。Block 一般是用来表示、简化一小段的程式码，它特别适合用来建立一些同步执行的程式片段、封装一些小型的工作或是用来做为某一个工作完成时的回传呼叫（callback） 。格式如下：^(传入参数列) {行为主体};</p>
<p>##23.常用的开源框架</p>
<p>网络框架：ASIHttpRequest，AFNetworking,coocaHttpServer等。</p>
<p>进度条：SVprogressHUD,MBprogressHUD,</p>
<p>工具类：SSToolKit等。</p>
<p>分享类：ShareKit等</p>
<p>日志框架：log4j，cocoa lumberJack 等。</p>
<p>##24.通知消息和代理的区别</p>
<p>通知：分为本地和远程通知。接受通知的接受者需要进行注册改通知。这样通知被NSNotificationCenter发送出来后会被注册的接受者所接受。远程通知需要借助苹果的服务器去实现通知的中转。</p>
<p>代理：把某个对象要做的事情委托给别的对象去做。</p>
<p>两者区别：</p>
<p>delegate针对one-to-one关系，用于sender接受到reciever的某个功能反馈值。</p>
<p>notification针对one-to-one/many/none,reciver,用于通知多个object某个事件，sender只是负责把notification发送出去。</p>
<p>##25.数据解析（json和XML）</p>
<p>json数据的解析通常借助一些开源的框架如：SBJson，TouchJson,jsonKit,Apple 提供的原生的JSon解析 NSJSON Serialization等。去json数据转化为IOS中常用的字典等。</p>
<p>XML数据的解析。xml分为SAX和DOM两种解析方式。</p>
<p>DOM解析XML时，读入整个XML文档并构建一个驻留内存的树结构（节点树），通过遍历树结构可以检索任意XML节点，读取它的属性和值。而且通常情况下，可以借助XPath，直接查询XML节点。</p>
<p>SAX解析XML，是基于事件通知的模式，一边读取XML文档一边处理，不必等整个文档加载完之后才采取操作，当在读取解析过程中遇到需要处理的对象，会发出通知对其进行处理。</p>
<p>一般在iOS平台下，比较常用的XML解析类库有如下几种：</p>
<p>NSXMLParser，，这是一个SAX方式解析XML的类库，默认包含在iOS SDK中，使用也比较简单。</p>
<p>libxml2，是一套默认包含在iOS SDK中的开源类库，它是基于C语言的API，所以使用起来可能不如NSXML方便。这套类库同时支持DOM和SAX解析，libxml2的SAX解析方式还是非常酷的，因为它可以边读取边解析，尤其是在从网上下载一个很大的XML文件，就可以一边下载一边对已经下载好的内容进行解析，极大的提高解析效率。</p>
<p>TBXML，这是一套轻量级的DOM方式的XML解析类库，有很好的性能和低内存占用，不过它不对XML格式进行校验，不支持XPath，并且只支持解析，不支持对XML进行修改。</p>
<p>TouchXML，这也是一套DOM方式的XML解析类库，支持XPath，不支持XML的修改。</p>
<p>KissXML，这是一套基于TouchXML的XML解析类库，和TouchXML相比，支持了XML的修改。</p>
<p>TinyXML，这是一套小巧的基于C语言的DOM方式进行XML解析的类库，支持对XML的读取和修改，不直接支持XPath，需要借助另一个相关的类库TinyXPath才可以支持XPath。</p>
<p>GDataXML，这是一套Google开发的DOM方式XML解析类库，支持读取和修改XML文档，支持XPath方式查询。</p>
<p>##26.webservice</p>
<p>Web service是一个平台独立的，松耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。技术支持包含如下：</p>
<p>1.1 xml 和xsd</p>
<p>1.2 Soap</p>
<p>1.3 wsdl</p>
<p>1.4 uddi</p>
<p>1.5 调用RPC和消息传递</p>
<p>##27.开发App的步骤，开发者账号，发布app到appstore</p>
<p>  证书分两种：开发者证书、发布者证书。前者开发时使用，后者发布使用 </p>
<p>（1） 模拟器调试无需代码签名；真机调试需开发者证书代码签名；发布时需发布证书签名 </p>
<p>（2） 代码签名需要：证书+私钥，</p>
<p>（3） 真机调试时要求在设备上安装描述文件（provision profile），该文件包含信息：调试者证书，</p>
<p>授权调试设备清单，应用ID。一个应用对应一个描述文件。</p>
<p>##28.类继承，类的扩展（extension），类别（category）</p>
<p>category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。<br>并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。<br>类别主要有3个作用：</p>
<p>(1)将类的实现分散到多个不同文件或多个不同框架中。</p>
<p>(2)创建对私有方法的前向引用。</p>
<p>(3)向对象添加非正式协议。</p>
<p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>
<p>category和extensions的不同在于后者可以添加属性。另外后者添加的方法是必须要实现的。<br>extensions可以认为是一个私有的Category。</p>
<p>##29.CAlayer介绍</p>
<p>一个UIView包含CALayer树，CALayer是一个数据模型。包含了一些用来显示的对象，在UIView的子类中都可以找到层这个组件，层是位于固定的画布上的一个子片，可以被覆盖。层是彼此堆叠在一起的最终产生一个界面。除此之层可以包含多个层，通过层可以操作位于此层上面的其他内容，例如旋转，动画，翻页等。</p>
<p>##30.ios 怎么实现多继承</p>
<p>IOS通过实现protocol委托代理，实现多个接口来实现多继承。</p>
<p>##31.app性能测试方式</p>
<p>通过Xcode提供的工具如Instrument，测试CPU，Mermory性能。也可以适用一些开源的自动化测试工具：如Frank，KIF等。</p>
<p>##32.NSArray可以放基本数据类型不（int，float，nil）怎么放进一个结构体</p>
<p>NSArray 只能存放objective－c对象数据模型，这些基本数据类型需要先转化为NSNumber对象再存放进数组中。</p>
<p>##33.objective-c和c，c++混合编写</p>
<p>在 Objective-C++中，可以用C++代码调用方法也可以从Objective-C调用方法。在这两种语言里对象都是指针，可以在任何地方使用。例 如，C++类可以使用Objective-C对象的指针作为数据成员，Objective-C类也可以有C++对象指针做实例变量。Xcode需要源文件以”.mm”为扩展名，这样才能启动编译器的Objective-C++扩展。</p>
<p>##34.常见的语言编码(utf-8,unicode,gb2312,gbk)</p>
<p>常见的语言编码有：</p>
<p>GB2312:简体中文编码，一个汉字占用2字节，在大陆是主要编码方式。</p>
<p>BIG5:繁体中文编码。主要在台湾地区采用。 </p>
<p>GBK:支持简体及繁体中文，但对他国非拉丁字母语言还是有问题。 </p>
<p>UTF-8:Unicode编码的一种。Unicode用一些基本的保留字符制定了三套编码方式，它们分别UTF-8,UTF-16和UTF-32。在UTF－8中，字符是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分。UTF-8俗称“万国码”，可以同屏显示多语种，一个汉字占用3字节。为了做到国际化，网页应尽可能采用UTF-8编码。</p>
<p>当然，处理中文时http头也要改成UTF-8编码的—–加上<meta http-equiv="Content-Type" content="text/html; charset=utf-8">。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>字符集</th>
<th>正式名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>英语、西欧语</td>
<td>ASCII，ISO-8859-1</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>简体中文</td>
<td>GB2312</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>繁体中文</td>
<td>BIG5</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>简繁中文</td>
<td>GBK</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>中文、日文及朝鲜语</td>
<td>GB18030</td>
<td>MBCS多字节</td>
</tr>
<tr>
<td>各国语言</td>
<td>UNICODE，UCS</td>
<td>DBCS宽字节</td>
</tr>
</tbody>
</table>
<p>##35.常见的加解密方式(rsa,aes,md5)</p>
<p>常见的加解密方式有：</p>
<p>RSA：基于公钥和私钥的非对程加密算法。适用范围广。</p>
<p>AES：是一种对程加密的流行方式。加密涉及矩阵运算。</p>
<p>MD5:将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，</p>
<p>##36.objective－c语言的优缺点</p>
<p>objc优点：</p>
<p>1) Cateogies</p>
<p>2) Posing</p>
<p>3) 动态识别</p>
<p>4) 指标计算</p>
<p>5）弹性讯息传递</p>
<p>6) 不是一个过度复杂的 C 衍生语言</p>
<p>7) Objective-C 与 C++ 可混合编程</p>
<p>缺点:<br>1) 不支援命名空間</p>
<p>2) 不支持运算符重载</p>
<p>3）不支持多重继承</p>
<p>4）使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。</p>
<p>##37，ios应用的调试技巧</p>
<p>1.如遇到crash，分析崩溃日志（symbolicatedrash工具的适用）保留崩溃版本的.dSYM文件</p>
<p>2.在 XCode 中进入断点管理窗口；然后点击右下方的 +，增加新的 Exception Breakpoint。</p>
<p>3.如遇到EXC_BAD_ACCESS，打开Scheme选项选择EditScheme。然后按图勾上Enable Zombie Objects和Malloc Stack那两项。</p>
<p>4.有效的日志管理。NSLog和加入一些开源的日志管理框架。</p>
<p>5.程序断点debug模式。</p>
<p>##38，应用程序性能的调优（转<a href="http://www.open-open.com/lib/view/open1365861753734.html）" target="_blank" rel="external">http://www.open-open.com/lib/view/open1365861753734.html）</a></p>
<ol>
<li><p>用ARC去管理内存（Use ARC to Manage Memory）</p>
<p>2.适当的地方使用reuseIdentifier（Use a reuseIdentifier Where Appropriate）</p>
<p>3.尽可能设置视图为不透明（Set View as Opaque When Possible）</p>
<p>4.避免臃肿的XIBs文件（Avoid Fat XiBs）</p>
<p>5.不要阻塞主进程（Don’t Block the Main Thread）</p>
<p>6.调整图像视图中的图像尺寸（Size Images to Image Views）</p>
<p>7.选择正确集合（Choose the Correct Collection）</p>
<p>8.启用Gzip压缩（Enable GZIP Compression）</p>
</li>
<li><p>重用和延迟加载视图（Reuse and Lazy Load Views）</p>
<p>10.缓存，缓存，缓存（Cache,Cache,Cache）</p>
<p>11.考虑绘图（Consider Drawing）</p>
<p>12.处理内存警告（Handle Memory Warnings）</p>
<p>13.重用大开销对象（Reuse Expensive Objects）</p>
<p>14.使用精灵表（Use Sprite Sheets ）</p>
<p>15.避免重复处理数据（Avoid Re-Processing Data）</p>
<p>16.选择正确的数据格式（Choose the Right Data Format）</p>
<p>17.适当的设置背景图片（Set  Background Images Appropriately）</p>
<p>18.减少你的网络占用（Reduce Your Web Footprint）  </p>
<p>19.设置阴影路径（Set the Shadow Path ）</p>
<p>20.你的表格视图Optimize Your Table Views）</p>
<p>21.选择正确的数据存储方式（Choose Correct Data Storage Option）</p>
<p>22.加速启动时间（Speed up Launch Time ）</p>
<p>23.使用自动释放池（Use AutoRelease Pool）</p>
<p>24.缓存图像（Cache Images-Or not ）</p>
<p>25.尽可能避免日期格式化器（Avoid Date Formatters Where Possible）</p>
</li>
</ol>
<p>##39.UIScrollView 的contentSize、contentOffSet和contentInset属性的区别</p>
<p>contentSize表示UIScrollView滚动区域的大小。UIScrollView的frame属性在设置好了以后不会随内容的变化而变化。</p>
<p>contentOffSet表示是UIScrollView当前显示区域顶点相对于frame顶点的偏移量，一般用来设置UIScrollView显示的位置。</p>
<p>contentInset表示是scrollview的contentView的顶点相对于scrollview的位置，假设你的contentInset = (0 ,100)，那么你的contentView就是从scrollview的(0 ,100)开始显示。一般都是（0，0）表示从scrollView的开始显示。</p>
<p>##40.IOS6 AutoLayout</p>
<p>AutoLayout是IOS6之后引进的自动布局功能，有点类型有android的相对布局属性。通过勾选AutoLayout设置各种Constraint约束来实现在不同设备和不同方向上的自动布局。autosizing mask也就是 “springs and struts” 模式。autosizing mask决定了一个view会发生什么当它的superview 改变大小的时候。而autolayout 不仅可以设置superview改变时view所做的变化，还支持当相邻view变化时自己所做的变化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/14/ios8-uipopoverpresentationcontroller-on-ios-8/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/14/ios8-uipopoverpresentationcontroller-on-ios-8/" itemprop="url">
                  [iOS]UIPopoverPresentationController on iOS 8
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-14T14:01:02+08:00">
              2014-10-14
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/14/ios8-uipopoverpresentationcontroller-on-ios-8/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/14/ios8-uipopoverpresentationcontroller-on-ios-8/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>In Tumblr for iOS, we have a view controller that gets presented differently on iPhone and on iPad:</p>
<pre><code>1. iPhone: Modally, as the child of a custom container view controller, presented with a custom animation controller
2. iPad: In a popover
</code></pre><p>I’m in the process of trying to implement this same behavior using the new UIPresentationController classes introduced in iOS 8, and seem to have already hit an unfortunate limitation.<br>It’s easy to get the popover showing up correctly on iPad, with just the following code:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">presentedController.modalPresentationStyle = <span class="built_in">UIModalPresentationPopover</span>;</div><div class="line">presentedController.popoverPresentationController.permittedArrowDirections = <span class="built_in">UIPopoverArrowDirectionUp</span>;</div><div class="line">presentedController.popoverPresentationController.sourceRect = button.bounds;</div><div class="line">presentedController.popoverPresentationController.sourceView = button;</div><div class="line">presentedController.popoverPresentationController.delegate = <span class="keyword">self</span>;</div><div class="line">[<span class="keyword">self</span> presentViewController:presentedController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>On iPhone, this same controller will be presented modally, but first we need to wrap it in a custom container view controller. To do this, we implement a couple of methods on the UIPopoverPresentationControllerDelegate protocol:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIModalPresentationStyle</span>)adaptivePresentationStyleForPresentationController:(<span class="built_in">UIPresentationController</span> *)controller &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UIModalPresentationOverFullScreen</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">UIViewController</span> *)presentationController:(<span class="built_in">UIPresentationController</span> *)presentationController viewControllerForAdaptivePresentationStyle:(<span class="built_in">UIModalPresentationStyle</span>)style &#123;</div><div class="line">    <span class="keyword">return</span> [[CustomContainerController alloc] initWithRootViewController:presentationController.presentedViewController];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Simple enough so far.<br>A “dimming view” is faded in as the view controller transitions on screen. The end result looks something like this:</p>
<p><img src="/uploads/2014/10/14/1.png" class="center"><br></p>
<p>The custom container controller is animated on screen using a custom animation controller conforming to <code>UIViewControllerAnimatedTransitioning</code>. In iOS 7, this animation controller was also responsible for showing the dimming view.<br>As of iOS 8, adding the dimming view to the view hierarchy and modifying its opacity should no longer be the responsibility of the animation controller. Instead, a custom <code>UIPresentationController</code> subclass should take care of this. The same <code>UIViewControllerTransitioningDelegate</code> that vends our custom animation controller can also vend a custom presentation controller, providing for a cleaner separation of concerns.</p>
<p>转自: <a href="http://cocoa.tumblr.com/post/92070238973/how-can-i-use-both-uipopoverpresentationcontroller-and" target="_blank" rel="external">http://cocoa.tumblr.com/post/92070238973/how-can-i-use-both-uipopoverpresentationcontroller-and</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/12/ios-something-about-objective-c-blocks/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/12/ios-something-about-objective-c-blocks/" itemprop="url">
                  [iOS] Something about Objective-C Blocks (Editing)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-12T14:56:51+08:00">
              2014-10-12
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/12/ios-something-about-objective-c-blocks/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/12/ios-something-about-objective-c-blocks/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Block基础知识"><a href="#1-Block基础知识" class="headerlink" title="1. Block基础知识"></a>1. Block基础知识</h2><h3 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">^(<span class="keyword">int</span> event)&#123;</div><div class="line">	printf(<span class="string">"print something"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即<code>^ 返回值 参数列表 表达式</code>，其中返回值可省略。</p>
<h3 id="1-2-有关Blocks自动变量"><a href="#1-2-有关Blocks自动变量" class="headerlink" title="1.2 有关Blocks自动变量"></a>1.2 有关Blocks自动变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> val = <span class="number">0</span>;</div><div class="line">   <span class="keyword">void</span> (^blk)() = ^&#123; val = <span class="number">1</span>;&#125;;</div><div class="line">   blk();</div><div class="line">   printf(<span class="string">"val = %d\n"</span>, val);</div></pre></td></tr></table></figure>
<p>若想再Block语法的表达式中将值复给在Block语法外声明的自动变量，需要在该自动变量上附加<code>__block</code>说明符。</p>
<h3 id="1-3-函数指针与Block对比"><a href="#1-3-函数指针与Block对比" class="headerlink" title="1.3 函数指针与Block对比"></a>1.3 函数指针与Block对比</h3><p>函数指针定义：<code>int func (int count)( return count +1) ;  int (*funcptr)(int) = &amp;func;</code><br><br>函数指针使用：<code>int result = (*funcptr)(10);</code><br><br>Blocks定义：<code>int (^blk)(int) = ^(int count){return count+1;};</code><br><br>Blocks使用：<code>int result = blk(10);</code><br></p>
<h3 id="1-4-Block的实质"><a href="#1-4-Block的实质" class="headerlink" title="1.4 Block的实质"></a>1.4 Block的实质</h3><p>Block实际上是作为极普通的C语言源代码来处理的。通过支持Block的编译器，含有Block语法的源代码转换为一般的C语言编译器能够处理的源代码，并作为极为普通的C语言源代码被编译。运用Clang，通过<code>-rewrite-objc</code> 选项就能将含有Block语法的源代码变换为C++源代码（struct结构）。<br><code>clang -rewrite-objc 源代码文件名</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">void</span> (^blk)() = ^&#123;printf(<span class="string">"Block!\n"</span>);&#125;;</div><div class="line">	blk();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转化以后为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用来描述block的数据结构</span></div><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">  <span class="keyword">void</span> *isa;	<span class="comment">//此处可以看出block被当做一个object来处理</span></div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;</div><div class="line">  <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//函数具体的数据结构描述</span></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//此处是block的具体实现，参数就是用来描述block的数据结构指针</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Block!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用来描述block的数据结构</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//先声明了一个指向描述block的数据结构，参数分别是调用的函数具体实现以及描述数据结构</span></div><div class="line"> 	<span class="keyword">void</span> (*blk)() = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</div><div class="line"> 	<span class="comment">//获取到block的数据结构以后，直接访问前面设置的函数指针，调用静态函数，参数就是上面得到的block的数据结构</span></div><div class="line"> 	((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查了下runtime.h, <code>Class</code>即<code>struct objc_class*</code>的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<h3 id="1-5-Writable-Variables"><a href="#1-5-Writable-Variables" class="headerlink" title="1.5 Writable Variables"></a>1.5 Writable Variables</h3><p>用<code>__block</code>在block外部声明block内部使用的变量，全名叫<code>__block storage-class-specifier</code>。C语言中的<code>storage-class-specifier</code>还有<code>typedef</code>,<code>extern</code>,<code>static</code>,<code>auto</code>,<code>register</code>。例如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;val = <span class="number">1</span>;&#125;;</div></pre></td></tr></table></figure>
<p>转化以后的代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个数据结构用来保存变量的，__forwarding指向自己的指针</span></div><div class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</div><div class="line">  <span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_val_0 *__forwarding;</div><div class="line"> <span class="keyword">int</span> __flags;</div><div class="line"> <span class="keyword">int</span> __size;</div><div class="line"> <span class="keyword">int</span> val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这个就是block的数据结构</span></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></div><div class="line">(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</div><div class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"> __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</div><div class="line"> <span class="keyword">void</span> (*blk)() = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>);</div><div class="line"> ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/11/core-animation/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/11/core-animation/" itemprop="url">
                  [iOS] Something about Core Animation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-11T16:01:25+08:00">
              2014-10-11
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/11/core-animation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/11/core-animation/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##1. Implicit and explicit Animation</p>
<p>Implicit Animation:<code>￼theLayer.opacity = 0.0;</code><br>Explicit Animation:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CABasicAnimation</span>* fadeAnim = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"opacity"</span>];</div><div class="line">fadeAnim.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>];</div><div class="line">fadeAnim.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.0</span>];</div><div class="line">fadeAnim.duration = <span class="number">1.0</span>;</div><div class="line">[theLayer addAnimation:fadeAnim forKey:<span class="string">@"opacity"</span>];</div><div class="line"><span class="comment">// Change the actual data value in the layer to the final value.</span></div><div class="line">theLayer.opacity = <span class="number">0.0</span>;</div></pre></td></tr></table></figure>
<p>Unlike an implicit animation, which updates the layer object’s data value, an explicit animation does not modify the data in the layer tree. Explicit animations only produce the animations. At the end of the animation, Core Animation removes the animation object from the layer and redraws the layer using its current data values. If you want the changes from an explicit animation to be permanent, you must also update the layer’s property as shown in the preceding example.</p>
<p>##2. Anchor Point</p>
<p><img src="/uploads/2014/10/11/1.png" class="center"><br><br><img src="/uploads/2014/10/11/2.png" class="center"><br></p>
<p>Rotation:<br><img src="/uploads/2014/10/11/3.png" class="center"><br></p>
<p>##3. Layer Trees<br>An app using Core Animation has three sets of layer objects. Each set of layer objects has a different role in making the content of your app appear onscreen:</p>
<ol>
<li>Objects in the <b>model layer tree</b> (or simply “layer tree”) are the ones your app interacts with the most. </li>
<li>Objects in the <b>presentation tree</b> contain the in-flight values for any running animations. </li>
<li>Objects in the <b>render tree</b> perform the actual animations and are private to Core Animation.</li>
</ol>
<p><img src="/uploads/2014/10/11/4.png" class="center"><br><br><img src="/uploads/2014/10/11/5.png" class="center"><br></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/06/c-plus-plus-cookbook/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/06/c-plus-plus-cookbook/" itemprop="url">
                  C++ CookBook读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-06T11:25:17+08:00">
              2014-10-06
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/06/c-plus-plus-cookbook/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/06/c-plus-plus-cookbook/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>C++创建静态库</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">g++ -c -o john.o john.cpp</div><div class="line">g++ -c -o paul.o paul.cpp</div><div class="line">g++ -c -o johnpaul.o johnpaul.cpp</div><div class="line">ar ru libjohnpaul.a john.o paul.o johnpaul.o</div><div class="line">ranlib libjohnpaul.a</div></pre></td></tr></table></figure>
<ol>
<li>使用预定义宏进行条件编译</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></div><div class="line"><span class="meta">#	<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span>	\\ not windows</span></div><div class="line"><span class="meta">#	<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<ol>
<li>使源文件自动链接到指定的库</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOHNPAUL_HPP_INCLUDED</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> JOHNPAUL_HPP_INCLUDED</span></div><div class="line"><span class="meta">#prama comment(lib, <span class="meta-string">"libjohnpaul"</span>)	<span class="comment">// 静态库</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<ol>
<li>包含一个内联文件</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VALUE_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUE_H_</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Value</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Value(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; val): val_(val)&#123;&#125;</div><div class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getVal</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> val_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Value.inl"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// Value.inl</span></div><div class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> Value::getVal() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (val_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/10/04/template-class-symbols-not-found/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/04/template-class-symbols-not-found/" itemprop="url">
                  Template Class - Symbols not found
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-10-04T10:03:51+08:00">
              2014-10-04
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/04/template-class-symbols-not-found/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/04/template-class-symbols-not-found/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Detailed Explanation available from <a href="http://www.parashift.com/c++-faq-lite/templates.html" target="_blank" rel="external">http://www.parashift.com/c++-faq-lite/templates.html</a></p>
<p>[35.12] Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file?</p>
<p>If all you want to know is how to fix this situation, read the next two FAQs. But in order to understand why things are the way they are, first accept these facts:</p>
<p>A template is not a class or a function. A template is a “pattern” that the compiler uses to generate a family of classes or functions.<br>In order for the compiler to generate the code, it must see both the template definition (not just declaration) and the specific types/whatever used to “fill in” the template. For example, if you’re trying to use a Foo, the compiler must see both the Foo template and the fact that you’re trying to make a specific Foo.<br>Your compiler probably doesn’t remember the details of one .cpp file while it is compiling another .cpp file. It could, but most do not and if you are reading this FAQ, it almost definitely does not. BTW this is called the “separate compilation model.”<br>Now based on those facts, here’s an example that shows why things are the way they are. Suppose you have a template Foo defined like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </div><div class="line"><span class="keyword">class</span> Foo &#123; </div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Foo();</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(T x)</span></span>;  </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T x;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Along with similar definitions for the member functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Foo&lt;T&gt;::Foo()</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> Foo&lt;T&gt;::someMethod(T x)</div><div class="line">&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now suppose you have some code in file Bar.cpp that uses Foo:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Bar.cpp</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">blah_blah_blah</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	Foo&lt;<span class="keyword">int</span>&gt; f;</div><div class="line">	f.someMethod(<span class="number">5</span>);</div><div class="line">	...</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Clearly somebody somewhere is going to have to use the “pattern” for the constructor definition and for the someMethod() definition and instantiate those when T is actually int. But if you had put the definition of the constructor and someMethod() into file Foo.cpp, the compiler would see the template code when it compiled Foo.cpp and it would see Foo when it compiled Bar.cpp, but there would never be a time when it saw both the template code and Foo. So by rule #2 above, it could never generate the code for Foo::someMethod().</p>
<p>A note to the experts: I have obviously made several simplifications above. This was intentional so please don’t complain too loudly. If you know the difference between a .cpp file and a compilation unit, the difference between a class template and a template class, and the fact that templates really aren’t just glorified macros, then don’t complain: this particular question/answer wasn’t aimed at you to begin with. I simplified things so newbies would “get it,” even if doing so offends some experts.</p>
<p>[35.13] How can I avoid linker errors with my template functions?</p>
<p>Tell your C++ compiler which instantiations to make while it is compiling your template function’s .cpp file.</p>
<p>As an example, consider the header file foo.h which contains the following template function declaration:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "foo.h"</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>Now suppose file foo.cpp actually defines that template function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "foo.cpp"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Here I am!\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Suppose file main.cpp uses this template function by calling foo():</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "main.cpp"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	foo&lt;<span class="keyword">int</span>&gt;();</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If you compile and (try to) link these two .cpp files, most compilers will generate linker errors. There are three solutions for this. The first solution is to physically move the definition of the template function into the .h file, even if it is not an inline function. This solution may (or may not!) cause significant code bloat, meaning your executable size may increase dramatically (or, if your compiler is smart enough, may not; try it and see).</p>
<p>The other solution is to leave the definition of the template function in the .cpp file and simply add the line template void foo(); to that file:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "foo.cpp"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Here I am!\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> <span class="keyword">void</span> foo&lt;<span class="keyword">int</span>&gt;();</div></pre></td></tr></table></figure>
<p>If you can’t modify foo.cpp, simply create a new .cpp file such as foo-impl.cpp as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// File "foo-impl.cpp"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.cpp"</span></span></div><div class="line"><span class="keyword">template</span> <span class="keyword">void</span> foo&lt;<span class="keyword">int</span>&gt;();</div></pre></td></tr></table></figure>
<p>Notice that foo-impl.cpp #includes a .cpp file, not a .h file.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/09/30/c-plus-plus-11-new-features/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/30/c-plus-plus-11-new-features/" itemprop="url">
                  C++ Primer 读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-30T16:29:22+08:00">
              2014-09-30
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/09/30/c-plus-plus-11-new-features/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/30/c-plus-plus-11-new-features/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###1. Array</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; a3 = &#123;<span class="number">3.14</span>, <span class="number">2.72</span>, <span class="number">1.62</span>, <span class="number">1.41</span>&#125;;</div><div class="line">   <span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; a4;</div><div class="line">   a4 = a3;</div></pre></td></tr></table></figure>
<p>###2. cin</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getline(<span class="built_in">cin</span>, first_name);</div><div class="line"><span class="built_in">cin</span>.getline(first_name, <span class="number">20</span>);</div></pre></td></tr></table></figure>
<p>###3. File - fstream</p>
<ol>
<li>包含头文件fstream</li>
<li>创建一个ofstream对象</li>
<li>将该ofstream对象同一个文件关联起来</li>
<li>就像使用cout那样使用该ofstream对象</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ofstream outFile;</div><div class="line">   outFile.open(<span class="string">"fish.txt"</span>);</div><div class="line">   <span class="built_in">string</span> filename;</div><div class="line">   getline(<span class="built_in">cin</span>, filename);</div><div class="line">   outFile&lt;&lt;filename;</div><div class="line">   outFile.close();</div><div class="line">   ifstream inFile;</div><div class="line">   inFile.open(<span class="string">"fish.txt"</span>);</div><div class="line">   <span class="built_in">string</span> resultname;</div><div class="line">   getline(inFile, resultname);</div><div class="line">   <span class="built_in">cout</span>&lt;&lt;resultname;</div><div class="line">   inFile.close();</div></pre></td></tr></table></figure>
<p>###4. 在函数传参过程中，尽量使用const</p>
<ol>
<li>这样可以避免由于五一间修改数据而导致的编程错误，</li>
<li>使用const使得函数能够处理const 和非const 实参，否则将只能接受非const数据。</li>
</ol>
<p>###5. 声明函数指针</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">double betsy(int);</div><div class="line">double pam1(int);</div><div class="line">void estimate(int lines, double (*pf)(int));</div><div class="line">double betsy(int lns)</div><div class="line">&#123;</div><div class="line">    return 0.05*lns;</div><div class="line">&#125;</div><div class="line"></div><div class="line">double pam1(int lns)</div><div class="line">&#123;</div><div class="line">    return 0.03*lns + lns;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void estimate(int lines, double (*pf)(int))</div><div class="line">&#123;</div><div class="line">    cout&lt;&lt;lines&lt;&lt;" lines will take ";</div><div class="line">    cout&lt;&lt;(*pf)(lines)&lt;&lt;" hour(s)\n";</div><div class="line">&#125;</div><div class="line"></div><div class="line">int code;</div><div class="line">   cout&lt;&lt;"how many lines?";</div><div class="line">   cin&gt;&gt;code;</div><div class="line">   cout&lt;&lt;"betsy estimate::";</div><div class="line">   estimate(code, betsy);</div><div class="line">   cout&lt;&lt;"pam1 estimate::";</div><div class="line">   estimate(code, pam1);</div></pre></td></tr></table></figure>
<p>###6. cout.precision(2)</p>
<p>###7. 显示具体化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> swap&lt;Job&gt;(Job&amp; a, Job&amp; b)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> t1;</div><div class="line">    <span class="keyword">int</span> t2;</div><div class="line">    t1 = a.salary;</div><div class="line">    a.salary = b.salary;</div><div class="line">    b.salary = t1;</div><div class="line">    t2 = a.<span class="built_in">floor</span>;</div><div class="line">    a.<span class="built_in">floor</span> = b.<span class="built_in">floor</span>;</div><div class="line">    b.<span class="built_in">floor</span> = t2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###8. 关键字decltype </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">decltype</span>(x) y; <span class="comment">//将x的类型复制给y</span></div></pre></td></tr></table></figure>
<p>给decltype提供的参数可以是表达式，编译器遍历一个核对表来实现声明.</p>
<p>###9. 声明和定义函数的语法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">double h(int x, float y);</div><div class="line">auto h(int x, float y) -&gt; double</div></pre></td></tr></table></figure>
<p>###10. 在同一个文件中只能讲同一个头文件包含一次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COORDIN_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> COORDIN_H_</span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>###11. 名词修饰</p>
<p>重载函数，编译时， 名称修饰</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">long MyFunctionFoo(int, float)</div><div class="line">MyFunctionFoo@@YAXH</div></pre></td></tr></table></figure>
<p>###12. thread_local 变量的声明周期与所属的线程一样长</p>
<p>###13. register 使用CPU寄存器来存储变量</p>
<p><code>register int count_fast;</code></p>
<p>###14. 未解决c++查抄c里面的函数原型问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">// use c protocol for name look-up</span></div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">spoff</span><span class="params">(<span class="keyword">int</span>)</span></span>;	<span class="comment">//use c++ protocol for name look-up</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="function"><span class="keyword">void</span> <span class="title">spaff</span><span class="params">(<span class="keyword">int</span>)</span></span>;	<span class="comment">//use c++ protocol for name look-up</span></div></pre></td></tr></table></figure>
<p>###15. int <em> pi = new int;<br>    int </em> pi = new int(sizeof(int));<br>    delete pi;<br>    delete (pi);</p>
<p>###16. 作用域内枚举 C++11, (struct)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> <span class="keyword">class</span> egg &#123;Small, Medium, Large, Jumbo&#125;;</div><div class="line"><span class="keyword">enum</span> <span class="keyword">class</span> shirt &#123;Small, Medium, Large, Jumbo&#125;;</div><div class="line">egg choise = egg::Large;</div><div class="line">   shirt floyd = shirt::Large;</div></pre></td></tr></table></figure>
<p>###17. 转换函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>;</div><div class="line"><span class="function">Stonewt <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;</div><div class="line">   <span class="keyword">double</span> host = <span class="keyword">double</span> (wolfe);</div><div class="line">   <span class="keyword">double</span> thinker = (<span class="keyword">double</span>) wolfe;</div></pre></td></tr></table></figure>
<ol>
<li>转换函数必须是类方法</li>
<li>转换函数不能指定返回类型</li>
<li>转换函数不能有参数</li>
</ol>
<p>可以在声明构造函数时使用关键字<code>explicit</code>, 以防止它被用于隐式转换</p>
<p>###18. C++11 空指针</p>
<p>引入新关键字<code>nullptr</code>用于表示空指针</p>
<p>###19. 静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HowMany</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> num_string;&#125;</div><div class="line"><span class="keyword">int</span> count = String::HowMany();</div></pre></td></tr></table></figure>
<p>###20. 通过char*创建string</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> s[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</div><div class="line"><span class="built_in">string</span>* test1 = <span class="keyword">new</span> <span class="built_in">string</span>(&amp;s[<span class="number">1</span>]);</div></pre></td></tr></table></figure>
<p>###21. 重载&lt;&lt;运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Stonewt&amp; obj);</div><div class="line">	ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Stonewt&amp; obj)</div><div class="line">&#123;</div><div class="line">    os&lt;&lt;obj.stone&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###22. 类的静态变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;</div><div class="line"><span class="keyword">int</span> Stonewt::count = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>###23. 使用explicit，让编译器不强转类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class Student</div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function">Sutdent <span class="title">doh</span><span class="params">(<span class="string">"test"</span>, <span class="number">10</span>)</span></span>;</div><div class="line">doh = <span class="number">5</span>;</div></pre></td></tr></table></figure>
<p>C++提供了关键字<code>explicit</code>，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用。</p>
<p>###24. virtual public继承，为解决菱形集成问题</p>
<p>###25. 泛型编程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Stack::push(<span class="keyword">const</span> Item&amp; item)</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<p>应改为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">bool</span> Stack&lt;Type&gt;::push(<span class="keyword">const</span> TYpe&amp; item)</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<p>###26. 模板别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> arrtype = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, <span class="number">12</span>&gt;</div></pre></td></tr></table></figure>
<p>###27. try block</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">       z = hmean(x, y);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* s) &#123;</div><div class="line">       <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"enter new two number: "</span>;</div><div class="line">       <span class="keyword">continue</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="string">"bad hmean() arguments a== -b"</span>;</div></pre></td></tr></table></figure>
<p>###28. 未捕获异常不会导致程序立刻异常终止。</p>
<p>相反，程序将首先调用函数terminate（）。在默认情况下， terminate（）调用abort（）函数，可以指定terminate（）应调用的函数（而不是abort（））来修改terminate（）的这种行为。为此，可调用set_terminate()函数。set_terminate（）和terminate（）都是在头文件exception中声明的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQuit</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Terminating due to uncaught exception!"</span>;</div><div class="line">    <span class="built_in">exit</span>(<span class="number">5</span>);</div><div class="line">&#125;</div><div class="line">set_terminate(myQuit);</div></pre></td></tr></table></figure>
<p>###29. RTTI (Runtime Type Identification)工作原理</p>
<ol>
<li>如果可能的话， dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则， 该运算符返回0——空指针</li>
<li>typeid运算符返回一个指出对象的类型的值</li>
<li>type_info结构存储了有关特定类型的信息。</li>
</ol>
<p>###30. dynamic_cast&lt;&gt;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Worker* wk = <span class="keyword">new</span> Waiter();</div><div class="line">   Singer* sg = <span class="keyword">dynamic_cast</span>&lt;Singer*&gt;(wk);	<span class="comment">// null</span></div><div class="line">   Waiter* wt = <span class="keyword">dynamic_cast</span>&lt;Waiter*&gt;(wk);	<span class="comment">// not null</span></div></pre></td></tr></table></figure>
<p>###31. typeid, type_info</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"name = "</span>&lt;&lt;<span class="keyword">typeid</span>(Worker).name()&lt;&lt;<span class="string">", id = "</span>&lt;&lt;<span class="keyword">typeid</span>(Worker).hash_code()&lt;&lt;<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>###32. dynamic_cast ：使得在类层次结构中进行向上转换    dynamic_cast<type_name>()</type_name></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const_cast</span> ：用于执行只有一种用途的类型转换，即改变值为<span class="keyword">const</span> 或<span class="keyword">volatile</span>，	<span class="keyword">const_cast</span>&lt;type_name&gt;()</div></pre></td></tr></table></figure>
<p>###33. 智能指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       <span class="built_in">auto_ptr</span>&lt;Report&gt; ps(<span class="keyword">new</span> Report(<span class="string">"using auto_ptr"</span>));</div><div class="line">       ps-&gt;comment();</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   &#123;</div><div class="line">       <span class="built_in">shared_ptr</span>&lt;Report&gt; ps(<span class="keyword">new</span> Report(<span class="string">"using share_ptr"</span>));</div><div class="line">       ps-&gt;comment();</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   &#123;</div><div class="line">       <span class="built_in">unique_ptr</span>&lt;Report&gt; ps(<span class="keyword">new</span> Report(<span class="string">"using unique_ptr"</span>));</div><div class="line">       ps-&gt;comment();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>###34. 问题:会删除ps</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ps(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"t"</span>));</div><div class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; vocation;</div><div class="line">vacation = ps;</div></pre></td></tr></table></figure>
<p>解决方案：</p>
<ol>
<li>定义复制运算符，是指执行深复制</li>
<li>简历所有权概念，对于特定的对象，只能有一个智能指针可拥有它， 这样只有拥有对象的智能指针的构造函数会删除该对象。然后，让复制操作转让所有权。这就是用于auto_ptr和unique_ptr的策略， 但unique_ptr的策略更严格。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">auto_ptr</span>&lt;Report&gt; ps(<span class="keyword">new</span> Report(<span class="string">"using auto_ptr"</span>));</div><div class="line">      <span class="built_in">auto_ptr</span>&lt;Report&gt; ps1 = ps;</div><div class="line">      ps-&gt;comment();	<span class="comment">// ps = NULL</span></div></pre></td></tr></table></figure>
<ol>
<li>创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。仅当最后一个指针过期时，才调用delete。share_ptr</li>
</ol>
<p>###35. Lambda函数</p>
<p><code>[](int x) {return x % 3 == 0;}    或 [](int x) -&gt; double {return x % 3 == 0;}</code>，类似 <code>bool f(int x) {return x % 3 == 0;}</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> mode3 = [](<span class="keyword">int</span> x) &#123;<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;&#125;</div><div class="line">count <span class="number">3</span> = <span class="built_in">std</span>::count_if(numbers.begin(), numbers.end(), mode3);</div></pre></td></tr></table></figure>
<p>###36. static_assert</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> assert_static(e)    \</span></div><div class="line">    do&#123;   \</div><div class="line">        enum &#123;assert_static__ = 1/(e)&#125;;\</div><div class="line">    &#125;while(0)</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bit_copy</span><span class="params">(T&amp; a, U&amp; b)</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">//    assert_static(sizeof(a) == sizeof(b));</span></div><div class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(a) == <span class="keyword">sizeof</span>(b), <span class="string">"error"</span>);<span class="comment">//此处会报错</span></div><div class="line">    <span class="built_in">memcpy</span>(&amp;a, &amp;b, <span class="keyword">sizeof</span>(a));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">0x2468</span>;</div><div class="line">    <span class="keyword">double</span> b;</div><div class="line">    bit_copy(a, b);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/09/03/auto-ptrde-shi-xian-c-plus-plus/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/03/auto-ptrde-shi-xian-c-plus-plus/" itemprop="url">
                  auto_ptr的实现及CTCI
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-03T21:47:49+08:00">
              2014-09-03
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/09/03/auto-ptrde-shi-xian-c-plus-plus/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/03/auto-ptrde-shi-xian-c-plus-plus/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>代码是参考auto_ptr的真实实现，其实大部分都一样，只是自己实现了一遍。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> <span class="keyword">auto_ptr_t</span> &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T* __ptr;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	* Use a T pointer to init the auto_ptr</div><div class="line">	*/</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="title">auto_ptr_t</span><span class="params">(T* <span class="keyword">__t</span> = <span class="number">0</span>)</span> </span>&#123;__ptr = <span class="keyword">__t</span>;&#125;</div><div class="line">    <span class="keyword">inline</span> ~<span class="keyword">auto_ptr_t</span>() &#123;<span class="keyword">delete</span> __ptr;&#125;</div><div class="line">    <span class="function"><span class="keyword">inline</span> T* <span class="title">release</span><span class="params">()</span> </span>&#123; T* __tmp = __ptr; __ptr = <span class="literal">NULL</span>; <span class="keyword">return</span> __tmp; &#125;</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* <span class="keyword">__t</span>)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (__ptr != <span class="keyword">__t</span>)</div><div class="line">            <span class="keyword">delete</span> __ptr;</div><div class="line">        __ptr = <span class="keyword">__t</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">inline</span> <span class="keyword">auto_ptr_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">auto_ptr_t</span>&amp; <span class="keyword">__t</span>)</div><div class="line">    &#123;</div><div class="line">        reset(<span class="keyword">__t</span>.release());</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> __up&gt; <span class="keyword">inline</span> <span class="keyword">auto_ptr_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">auto_ptr_t</span>&lt;__up&gt;&amp; __p)</div><div class="line">    &#123;</div><div class="line">        reset(__p.release());</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">inline</span> <span class="keyword">auto_ptr_t</span>&amp; <span class="keyword">operator</span>=(auto_ptr_ref&lt;T&gt; __p)</div><div class="line">    &#123;</div><div class="line">        reset(__p.release());</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">inline</span> T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> __ptr; &#125;</div><div class="line">    <span class="keyword">inline</span> T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *__ptr;&#125;</div><div class="line">    <span class="function"><span class="keyword">inline</span> T* <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __ptr;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> __up&gt; <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="keyword">auto_ptr_t</span>&lt;__up&gt;()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">auto_ptr_t</span>&lt;__up&gt;(release());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.njiang.cn/2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="姜楠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天空の城">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="天空の城" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/" itemprop="url">
                  C++智能指针详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-02T11:38:11+08:00">
              2014-09-02
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-26T16:40:34+08:00">
              2016-12-26
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/02/c-plus-plus-zhi-neng-zhi-zhen-xiang-jie/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##一、简介<br>由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete。程序员忘记 delete，流程太复杂，最终导致没有 delete，异常导致程序过早退出，没有执行 delete 的情况并不罕见。<br>用智能指针便可以有效缓解这类问题，本文主要讲解参见的智能指针的用法。包括：<code>std::auto_ptr</code>、<code>boost::scoped_ptr</code>、<code>boost::shared_ptr</code>、<code>boost::scoped_array</code>、<code>boost::shared_array</code>、<code>boost::weak_ptr</code>、<code>boost:: intrusive_ptr</code>。你可能会想，如此多的智能指针就为了解决new、delete匹配问题，真的有必要吗？看完这篇文章后，我想你心里自然会有答案。下面就按照顺序讲解如上 7 种智能指针（smart_ptr）。</p>
<p>##二、具体使用</p>
<p>###1、总括<br>对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。<br>访问智能指针包含的裸指针则可以用 get() 函数。由于智能指针是一个对象，所以<code>if (my_smart_object)</code>永远为真，要判断智能指针的裸指针是否为空，需要这样判断：<code>if (my_smart_object.get())</code>。<br>智能指针包含了 <code>reset()</code> 方法，如果不传递参数（或者传递 NULL），则智能指针会释放当前管理的内存。如果传递一个对象，则智能指针会释放当前对象，来管理新传入的对象。<br>我们编写一个测试类来辅助分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Simple &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Simple(<span class="keyword">int</span> param = <span class="number">0</span>) &#123;</div><div class="line">    number = param;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  ~Simple() &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PrintSomething: "</span> &lt;&lt; info_extend.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> info_extend;</div><div class="line">  <span class="keyword">int</span> number;</div><div class="line">&#125;;</div><div class="line">``` </div><div class="line"></div><div class="line">###<span class="number">2</span>、<span class="built_in">std</span>::<span class="built_in">auto_ptr</span></div><div class="line">`<span class="built_in">std</span>::<span class="built_in">auto_ptr</span>` 属于 STL，当然在 <span class="keyword">namespace</span> <span class="built_in">std</span> 中，包含头文件 <span class="string">"#include&lt;memory&gt;"</span>便可以使用。<span class="built_in">std</span>::<span class="built_in">auto_ptr</span> 能够方便的管理单个堆内存对象。</div><div class="line">我们从代码开始分析：</div><div class="line"></div><div class="line">```<span class="function">cpp</span></div><div class="line"><span class="keyword">void</span> <span class="title">TestAutoPtr</span><span class="params">()</span> </div><div class="line">&#123;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));   <span class="comment">// 创建对象，输出：Simple：1</span></div><div class="line"><span class="keyword">if</span> (my_memory.get()) &#123;                            <span class="comment">// 判断智能指针是否为空</span></div><div class="line">my_memory-&gt;PrintSomething();                    <span class="comment">// 使用 operator-&gt; 调用智能指针对象中的函数</span></div><div class="line">my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>;      <span class="comment">// 使用 get() 返回裸指针，然后给内部对象赋值</span></div><div class="line">my_memory-&gt;PrintSomething();                    <span class="comment">// 再次打印，表明上述赋值成功</span></div><div class="line"></div><div class="line">(*my_memory).info_extend += <span class="string">" other"</span>;			<span class="comment">// 使用 operator* 返回智能指针内部对象，然后用"."调用智能指针对象中的函数</span></div><div class="line"></div><div class="line">my_memory-&gt;PrintSomething();                    <span class="comment">// 再次打印，表明上述赋值成功</span></div><div class="line">&#125;</div><div class="line">&#125;                                              <span class="comment">// my_memory 栈对象即将结束生命期，析构堆对象 Simple(1)</span></div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">1</span></div><div class="line">PrintSomething:</div><div class="line">PrintSomething: Addition</div><div class="line">PrintSomething: Addition other</div><div class="line"></div><div class="line">~Simple: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>上述为正常使用 <code>std::auto_ptr</code>的代码，一切似乎都良好，无论如何不用我们显示使用该死的 delete 了。</p>
<p>其实好景不长，我们看看如下的另一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr2</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory2;   <span class="comment">// 创建一个新的 my_memory2 对象</span></div><div class="line">    my_memory2 = my_memory;             <span class="comment">// 复制旧的 my_memory 给 my_memory2</span></div><div class="line">    my_memory2-&gt;PrintSomething();       <span class="comment">// 输出信息，复制成功 </span></div><div class="line">  	my_memory-&gt;PrintSomething();        <span class="comment">// 崩溃</span></div><div class="line">  	</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终如上代码导致崩溃，如上代码时绝对符合 C++ 编程思想的，居然崩溃了，跟进 std::auto_ptr 的源码后，我们看到，罪魁祸首是<code>my_memory2 = my_memory</code>，这行代码，my_memory2 完全夺取了 my_memory 的内存管理所有权，导致 my_memory 悬空，最后使用时导致崩溃。<br>所以，使用 <code>std::auto_ptr</code> 时，绝对不能使用“operator=”操作符。作为一个库，不允许用户使用，确没有明确拒绝[1]，多少会觉得有点出乎预料。</p>
<p>看完 <code>std::auto_ptr</code> 好景不长的第一个例子后，让我们再来看一个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line"> </div><div class="line"> <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory.release();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>看到什么异常了吗？我们创建出来的对象没有被析构，没有输出“~Simple: 1”，导致内存泄露。当我们不想让 my_memory 继续生存下去，我们调用 release() 函数释放内存，结果却导致内存泄露（在内存受限系统中，如果my_memory占用太多内存，我们会考虑在使用完成后，立刻归还，而不是等到 my_memory 结束生命期后才归还）。正确的代码应该为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    Simple* temp_memory = my_memory.release();</div><div class="line">    <span class="keyword">delete</span> temp_memory;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory.reset();  <span class="comment">// 释放 my_memory 内部管理的内存</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来<code>std::auto_ptr</code>的 release() 函数只是让出内存所有权，这显然也不符合 C++ 编程思想。<br>总结：<code>std::auto_ptr</code>可用来管理单个对象的对内存，但是，请注意如下几点：<br>（1）    尽量不要使用“operator=”。如果使用了，请不要再使用先前对象。<br>（2）    记住 release() 函数不会释放对象，仅仅归还所有权。<br>（3）    std::auto_ptr 最好不要当成参数传递（读者可以自行写代码确定为什么不能）。<br>（4）    由于<code>std::auto_ptr</code>的“operator=”问题，有其管理的对象不能放入<code>std::vector</code>等容器中。<br>（5）    ……<br>使用一个<code>std::auto_ptr</code>的限制还真多，还不能用来管理堆内存数组，这应该是你目前在想的事情吧，我也觉得限制挺多的，哪天一个不小心，就导致问题了。<br>由于<code>std::auto_ptr</code>引发了诸多问题，一些设计并不是非常符合 C++ 编程思想，所以引发了下面 boost 的智能指针，boost 智能指针可以解决如上问题。<br>让我们继续向下看。</p>
<p>###3、boost::scoped_ptr<br><code>boost::scoped_ptr</code>属于 boost 库，定义在<code>namespace boost</code>中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt;</code>便可以使用。<code>boost::scoped_ptr</code>跟<code>std::auto_ptr</code>一样，可以方便的管理单个堆内存对象，特别的是，boost::scoped_ptr 独享所有权，避免了 <code>std::auto_ptr</code>恼人的几个问题。<br>我们还是从代码开始分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestScopedPtr</span><span class="params">()</span> </span>&#123;</div><div class="line">  boost::scoped_ptr&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">    my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">    (*my_memory).info_extend += <span class="string">" other"</span>;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">   </div><div class="line">   	my_memory.release();           <span class="comment">// 编译 error: scoped_ptr 没有 release 函数</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory2;</div><div class="line">    my_memory2 = my_memory;        <span class="comment">// 编译 error: scoped_ptr 没有重载 operator=，不会导致所有权转移</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们可以看到，<code>boost::scoped_ptr</code>也可以像<code>auto_ptr</code>一样正常使用。但其没有<code>release()</code>函数，不会导致先前的内存泄露问题。其次，由于<code>boost::scoped_ptr</code>是独享所有权的，所以明确拒绝用户写“my_memory2 = my_memory”之类的语句，可以缓解<code>std::auto_ptr</code>几个恼人的问题。</p>
<p>由于<code>boost::scoped_ptr</code>独享所有权，当我们真真需要复制智能指针时，需求便满足不了了，如此我们再引入一个智能指针，专门用于处理复制，参数传递的情况，这便是如下的<code>boost::shared_ptr</code>。</p>
<p>###4、boost::shared_ptr<br><code>boost::shared_ptr</code>属于 boost 库，定义在 namespace boost 中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt;</code>便可以使用。在上面我们看到<code>boost::scoped_ptr</code>独享所有权，不允许赋值、拷贝，<code>boost::shared_ptr</code>是专门用于共享所有权的，由于要共享所有权，其在内部使用了引用计数。boost::shared_ptr 也是用于管理单个堆内存对象的。<br>我们还是从代码开始分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedPtr</span><span class="params">(boost::<span class="built_in">shared_ptr</span>&lt;Simple&gt; memory)</span> </span>&#123;  <span class="comment">// 注意：无需使用 reference (或 const reference)</span></div><div class="line">  memory-&gt;PrintSomething();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedPtr UseCount: "</span> &lt;&lt; memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedPtr2</span><span class="params">()</span> </span>&#123;</div><div class="line">  boost::<span class="built_in">shared_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">    my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">    (*my_memory).info_extend += <span class="string">" other"</span>;</div><div class="line">    my_memory-&gt;PrintSomething();</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedPtr2 UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  TestSharedPtr(my_memory);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedPtr2 UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="comment">//my_memory.release();// 编译 error: 同样，shared_ptr 也没有 release 函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">1</span></div><div class="line">PrintSomething:</div><div class="line">PrintSomething: Addition</div><div class="line">PrintSomething: Addition other</div><div class="line">TestSharedPtr2 UseCount: <span class="number">1</span></div><div class="line">PrintSomething: Addition other</div><div class="line">TestSharedPtr UseCount: <span class="number">2</span></div><div class="line">TestSharedPtr2 UseCount: <span class="number">1</span></div><div class="line"></div><div class="line">~Simple: <span class="number">1</span></div></pre></td></tr></table></figure>
<p><code>boost::shared_ptr</code>也可以很方便的使用。并且没有<code>release()</code>函数。关键的一点，boost::shared_ptr 内部维护了一个引用计数，由此可以支持复制、参数传递等。boost::shared_ptr 提供了一个函数 use_count() ，此函数返回 boost::shared_ptr 内部的引用计数。查看执行结果，我们可以看到在 TestSharedPtr2 函数中，引用计数为 1，传递参数后（此处进行了一次复制），在函数TestSharedPtr 内部，引用计数为2，在 TestSharedPtr 返回后，引用计数又降低为 1。当我们需要使用一个共享对象的时候，boost::shared_ptr 是再好不过的了。<br>在此，我们已经看完单个对象的智能指针管理，关于智能指针管理数组，我们接下来讲到。</p>
<p>###5、boost::scoped_array<br><code>boost::scoped_array</code> 属于 boost 库，定义在<code>namespace boost</code>中，包含头文件 #include<boost smart_ptr.hpp=""> 便可以使用。<br>    boost::scoped_array 便是用于管理动态数组的。跟 boost::scoped_ptr 一样，也是独享所有权的。<br>我们还是从代码开始分析：</boost></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestScopedArray</span><span class="params">()</span> </span>&#123;</div><div class="line">   boost::scoped_array&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple[<span class="number">2</span>]); <span class="comment">// 使用内存数组来初始化</span></div><div class="line">   <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">     my_memory[<span class="number">0</span>].PrintSomething();</div><div class="line">     my_memory.get()[<span class="number">0</span>].info_extend = <span class="string">"Addition"</span>;</div><div class="line">     my_memory[<span class="number">0</span>].PrintSomething();</div><div class="line">     </div><div class="line">  	(*my_memory)[<span class="number">0</span>].info_extend += <span class="string">" other"</span>;            <span class="comment">// 编译 error，scoped_ptr 没有重载 operator*</span></div><div class="line">     my_memory[<span class="number">0</span>].release();                             <span class="comment">// 同上，没有 release 函数</span></div><div class="line">     boost::scoped_array&lt;Simple&gt; my_memory2;</div><div class="line">     my_memory2 = my_memory;                             <span class="comment">// 编译 error，同上，没有重载 operator=</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>boost::scoped_array 的使用跟 boost::scoped_ptr 差不多，不支持复制，并且初始化的时候需要使用动态数组。另外，boost::scoped_array 没有重载“operator*”，其实这并无大碍，一般情况下，我们使用 get() 函数更明确些。</p>
<p>下面肯定应该讲 boost::shared_array 了，一个用引用计数解决复制、参数传递的智能指针类。</p>
<p>###6、boost::shared_array<br>boost::shared_array 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost smart_ptr.hpp=""> 便可以使用。</boost></p>
<p>由于 boost::scoped_array 独享所有权，显然在很多情况下（参数传递、对象赋值等）不满足需求，由此我们引入 boost::shared_array。跟 boost::shared_ptr 一样，内部使用了引用计数。<br>我们还是从代码开始分析:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedArray</span><span class="params">(boost::shared_array&lt;Simple&gt; memory)</span> </span>&#123;  <span class="comment">// 注意：无需使用 reference (或 const reference)</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedArray UseCount: "</span> &lt;&lt; memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSharedArray2</span><span class="params">()</span> </span>&#123;</div><div class="line">  boost::shared_array&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple[<span class="number">2</span>]);</div><div class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</div><div class="line">    my_memory[<span class="number">0</span>].PrintSomething();</div><div class="line">    my_memory.get()[<span class="number">0</span>].info_extend = <span class="string">"Addition 00"</span>;</div><div class="line">    my_memory[<span class="number">0</span>].PrintSomething();</div><div class="line">    my_memory[<span class="number">1</span>].PrintSomething();</div><div class="line">    my_memory.get()[<span class="number">1</span>].info_extend = <span class="string">"Addition 11"</span>;</div><div class="line">    my_memory[<span class="number">1</span>].PrintSomething();</div><div class="line">    <span class="comment">//(*my_memory)[0].info_extend += " other";  // 编译 error，scoped_ptr 没有重载 operator*</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedArray2 UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  TestSharedArray(my_memory);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestSharedArray2 UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">0</span></div><div class="line">Simple: <span class="number">0</span></div><div class="line">PrintSomething:</div><div class="line">PrintSomething: Addition <span class="number">00</span></div><div class="line">PrintSomething:</div><div class="line">PrintSomething: Addition <span class="number">11</span></div><div class="line">TestSharedArray2 UseCount: <span class="number">1</span></div><div class="line">TestSharedArray UseCount: <span class="number">2</span></div><div class="line">TestSharedArray2 UseCount: <span class="number">1</span></div><div class="line"></div><div class="line">~Simple: <span class="number">0</span></div><div class="line">~Simple: <span class="number">0</span></div></pre></td></tr></table></figure>
<p>跟<code>boost::shared_ptr</code>一样，使用了引用计数，可以复制，通过参数来传递。</p>
<p>至此，我们讲过的智能指针有<code>std::auto_ptr</code>、<code>boost::scoped_ptr</code>、<code>boost::shared_ptr</code>、<code>boost::scoped_array</code>、<code>boost::shared_array</code>。这几个智能指针已经基本够我们使用了，90% 的使用过标准智能指针的代码就这 5 种。可如下还有两种智能指针，它们肯定有用，但有什么用处呢，一起看看吧。</p>
<p>###7、boost::weak_ptr<br>boost::weak_ptr 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost smart_ptr.hpp=""> 便可以使用。<br>在讲 boost::weak_ptr 之前，让我们先回顾一下前面讲解的内容。似乎 boost::scoped_ptr、boost::shared_ptr 这两个智能指针就可以解决所有单个对象内存的管理了，这儿还多出一个 boost::weak_ptr，是否还有某些情况我们没纳入考虑呢？<br>回答：有。首先 boost::weak_ptr 是专门为 boost::shared_ptr 而准备的。有时候，我们只关心能否使用对象，并不关心内部的引用计数。boost::weak_ptr 是 boost::shared_ptr 的观察者（Observer）对象，观察者意味着 boost::weak_ptr 只对 boost::shared_ptr 进行引用，而不改变其引用计数，当被观察的 boost::shared_ptr 失效后，相应的 boost::weak_ptr 也相应失效。<br>我们还是从代码开始分析：</boost></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestWeakPtr</span><span class="params">()</span> </span>&#123;</div><div class="line">  boost::weak_ptr&lt;Simple&gt; my_memory_weak;</div><div class="line">  boost::<span class="built_in">shared_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestWeakPtr boost::shared_ptr UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  my_memory_weak = my_memory;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestWeakPtr boost::shared_ptr UseCount: "</span> &lt;&lt; my_memory.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Simple: <span class="number">1</span></div><div class="line">TestWeakPtr boost::<span class="built_in">shared_ptr</span> UseCount: <span class="number">1</span></div><div class="line">TestWeakPtr boost::<span class="built_in">shared_ptr</span> UseCount: <span class="number">1</span></div><div class="line"></div><div class="line">~Simple: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们看到，尽管被赋值了，内部的引用计数并没有什么变化，当然，读者也可以试试传递参数等其他情况。<br>现在要说的问题是，<code>boost::weak_ptr</code>到底有什么作用呢？从上面那个例子看来，似乎没有任何作用，其实<code>boost::weak_ptr</code>主要用在软件架构设计中，可以在基类（此处的基类并非抽象基类，而是指继承于抽象基类的虚基类）中定义一个<code>boost::weak_ptr</code>，用于指向子类的 boost::shared_ptr，这样基类仅仅观察自己的 boost::weak_ptr 是否为空就知道子类有没对自己赋值了，而不用影响子类 boost::shared_ptr 的引用计数，用以降低复杂度，更好的管理对象。</p>
<p>###8、boost::intrusive_ptr<br><code>boost::intrusive_ptr</code>属于 boost 库，定义在 namespace boost 中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt;</code>便可以使用。<br>讲完如上 6 种智能指针后，对于一般程序来说 C++ 堆内存管理就够用了，现在有多了一种<code>boost::intrusive_ptr</code>，这是一种插入式的智能指针，内部不含有引用计数，需要程序员自己加入引用计数，不然编译不过（⊙﹏⊙b汗）。个人感觉这个智能指针没太大用处，至少我没用过。有兴趣的朋友自己研究一下源代码哦J。</p>
<p>##三、总结<br>如上讲了这么多智能指针，有必要对这些智能指针做个总结：<br>1、在可以使用 boost 库的场合下，拒绝使用 std::auto_ptr，因为其不仅不符合 C++ 编程思想，而且极容易出错[2]。<br>2、在确定对象无需共享的情况下，使用 boost::scoped_ptr（当然动态数组使用 boost::scoped_array）。<br>3、在对象需要共享的情况下，使用 boost::shared_ptr（当然动态数组使用 boost::shared_array）。<br>4、在需要访问 boost::shared_ptr 对象，而又不想改变其引用计数的情况下，使用 boost::weak_ptr，一般常用于软件框架设计中。<br>5、最后一点，也是要求最苛刻一点：在你的代码中，不要出现 delete 关键字（或 C 语言的 free 函数），因为可以用智能指针去管理。</p>
<hr>
<p>[1]参见《effective C++（3rd）》，条款06 。<br>[2]关于 boost 库的使用，可本博客另外一篇文章：《在 Windows 中编译 boost1.42.0》。<br>[3]读者应该看到了，在我所有的名字前，都加了命名空间标识符std::（或boost::），这不是我不想写 using namespace XXX 之类的语句，在大型项目中，有可能会用到 N 个第三方库，如果把命名空间全放出来，命名污染（Naming conflicts）问题很难避免，到时要改回来是极端麻烦的事情。当然，如果你只是写 Demo，可以例外。</p>
<p>转自：<a href="http://blog.csdn.net/xt_xiaotian/article/details/5714477" target="_blank" rel="external">http://blog.csdn.net/xt_xiaotian/article/details/5714477</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar/avatar.jpg"
               alt="姜楠" />
          <p class="site-author-name" itemprop="name">姜楠</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">115</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/njiang1987" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姜楠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"njiang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
